	TITLE	D:\Klingons\Render\Src\UnRender.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_02DILL@?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03IDPP@new?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09NHFI@NameEntry?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@IOIP@UObject?5assignment?5operator?5call@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CJ@JMDF@UObject?5copy?5constructor?5operato@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EN@PEDE@Check?5failed?3?5i?$DO?$DN0?5?$CG?$CG?5i?$DMGetMax?$CI?$CJ@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EA@NHOH@Check?5failed?3?5Class?5?$FLFile?3?4?4?2?4?4?2@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@LMKJ@FProperty?3?3Init?3?5invalid?5type?5?$CFi@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03FBGG@F?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05DGIH@Actor?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PFH@A?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01MHL@U?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DCMN@?$CFs?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FO@DCOG@Check?5failed?3?5Defaults?4Num?$CI?$CJ?$DN?$DNPr@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EI@FNEO@Check?5failed?3?5Defaults?4Num?$CI?$CJ?5?$FLFi@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PNHD@Vector?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GCLC@Rotation?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FF@JPBM@Check?5failed?3?5InType?$DN?$DNCPT_Object@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EM@PLEE@Check?5failed?3?5InType?$DN?$DNCPT_Struct@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EK@EHMC@Check?5failed?3?5InType?$DN?$DNCPT_Byte?5?$FL@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@OIEJ@Unhashed?5item?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FH@FKFD@Check?5failed?3?5ActiveChunks?$DM?$DNMem?9@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04FKCF@?$CI?$CFs?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EK@LHBB@Check?5failed?3?5i?$DM?$CIDWORD?$CJNumBits?5?$FL@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EI@EGOH@Check?5failed?3?5i?$DMSide?$CG?$CGj?$DMSide?5?$FLFi@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EA@FMAN@Check?5failed?3?5Brush?5?$FLFile?3?4?4?2?4?4?2@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EA@JAE@Check?5failed?3?5Other?5?$FLFile?3?4?4?2?4?4?2@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EH@GBPM@Check?5failed?3?5Other?9?$DOBrush?5?$FLFile@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05BFNK@Index?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EE@NGOK@Check?5failed?3?5Num?$CI?$CJ?$DO?$DN2?5?$FLFile?3?4?4?2@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EL@ELKL@Check?5failed?3?5Actors?$CI1?$CJ?$CB?$DNNULL?5?$FLF@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FC@PNII@Check?5failed?3?5Actors?$CI1?$CJ?9?$DOBrush?$CB?$DN@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@FGCD@Actor?5not?5found?3?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EF@LODM@Check?5failed?3?5Actors?$CI0?$CJ?5?$FLFile?3?4?4@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0GD@NDIK@Check?5failed?3?5Actors?$CI0?$CJ?9?$DOIsA?$CIALe@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09DEGN@HHitProxy?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08CHIE@HBspSurf?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PDIP@HActor?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07IDGH@HCoords?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
drectve	SEGMENT DWORD USE32 PUBLIC ''
drectve	ENDS
;	COMDAT ??_C@_0DP@NFMJ@Check?5failed?3?5Index?$DO?$DN0?5?$FLFile?3?4?4?2@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EG@OGEE@Check?5failed?3?5Index?$DM?$DNArrayNum?5?$FLF@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EM@GAIE@Check?5failed?3?5Index?$CLCount?$DM?$DNArray@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?appFloor@@YAHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appCycles@@YAKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appSeconds@@YANXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appToUpper@@YADD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AA_K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FIteratorList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FIteratorList@@QAE@PAU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??EFObjectIterator@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUPackage@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUTextBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUEnum@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUStruct@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAPAVUClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUClass@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??EFPropertyIterator@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GHash@@YAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAVFMemStack@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAVFMemStack@@W4EMemZeroed@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeCacheID@@YA_KW4ECacheIDBase@@PAVUObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unfix@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FSnap@@YAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FSheerSnap@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FAddAngleConfined@@YAGHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVFVector@@MABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAVFPlane@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReduceAngle@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FPointPlaneDist@@YAMABVFVector@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FDistSquared@@YAMABVFVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FParallel@@YAHABVFVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCsg@FBspNode@@QBEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChildOutside@FBspNode@@QBEHHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAVFZoneProperties@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUBspNodes@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUBspSurfs@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUPolys@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUVectors@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUVerts@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUBitArray@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUBitMatrix@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUPalette@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAPAVUTexture@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUFont@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FIteratorActorList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FIteratorActorList@@QAE@PAU0@PAVAActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FCheckResult@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUPrimitive@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUModel@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAPAVAActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__unnamed@?1??Damage@AActor@@QAEXHPAVAPawn@@VFVector@@1VFName@@@Z@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__unnamed@?1??Landed@AActor@@QAEXVFVector@@@Z@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__unnamed@?1??HitWall@AActor@@QAEXVFVector@@PAV2@@Z@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAActor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__unnamed@?1??ClientHearSound@APawn@@QAEXPAVAActor@@HPAVUSound@@VFVector@@MMM@Z@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPawn@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__unnamed@?1??PlayerCalcView@APlayerPawn@@QAEXAAPAVAActor@@AAVFVector@@AAVFRotation@@@Z@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0__unnamed@?1??ClientPush@APlayerPawn@@QAEXVFVector@@PAVAActor@@0@Z@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPlayerPawn@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GACamera@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAScout@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GABrush@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAMover@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAZoneInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAWarpZoneInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GASkyZoneInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GALevelInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAGameInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAMenu@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAHUD@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATriggers@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATrigger@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInventory@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAWeapon@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAKeypoint@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInterpolationPoint@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAProjectile@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GADecoration@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GANavigationPoint@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAWarpZoneMarker@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAButtonMarker@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATriggerMarker@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInventorySpot@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPlayerStart@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATeleporter@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPathNode@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FCollisionHashBase@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFCollisionHashBase@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GULevel@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??EFStaticBrushIterator@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UInput@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UInput@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUInput@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUGameEngine@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUCanvas@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAUFMeshUV@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAUFMeshAnimNotify@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FMeshAnimNotify@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUMesh@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FActorLink@@QAE@PAVAActor@@PAU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUSound@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUMusic@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Project@FTransform@@QAEXPBUFSceneNode@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FTransform@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FOutVector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FTransSample@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FTransTexture@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FSpan@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FSpanBuffer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FSpanBuffer@@QAE@ABV0@AAVFMemStack@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FVolActorLink@@QAE@AAVFCoords@@PAVAActor@@PAU0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FVolActorLink@@QAE@AAU0@PAU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FDynamicItem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Filter@FDynamicItem@@UAEXPAVUViewport@@PAUFSceneNode@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PreRender@FDynamicItem@@UAEXPAVUViewport@@PAUFSceneNode@@PAVFSpanBuffer@@HPAUFVolActorLink@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DivSqrtApprox@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1URender@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2URender@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalConstructor@URender@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dynamic@URender@@QAEAAPAUFDynamicItem@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GURender@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EURender@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FBspDrawList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Compare@@YAHABUFBspDrawListPtr@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FSurfaceInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FTextureInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FSurfaceFacet@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@D@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@D@@QAEAADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@D@@QBEABDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Num@?$TArray@D@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@D@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shrink@?$TArray@D@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddItem@?$TArray@D@@QAEHABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TArray@D@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSize@?$TArray@D@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@PAUFNameEntry@@@@QAEAAPAUFNameEntry@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Num@?$TArray@PAUFNameEntry@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@H@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddUniqueItem@?$TArray@H@@QAEHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@PAVUObject@@@@QAEAAPAVUObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Num@?$TArray@PAVUObject@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFString@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFProperty@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFProperty@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFProperty@@@@QAEAAVFProperty@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Num@?$TArray@VFProperty@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@VFProperty@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFName@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFName@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFConst@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFConst@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFStackNode@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFStackNode@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFStackNode@@@@QAEAAVFStackNode@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFDependency@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFDependency@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@E@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@E@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@E@@QAEAAEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Num@?$TArray@E@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TArray@E@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@K@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@K@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@K@@QAEAAKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TArray@K@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFColor@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFColor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFColor@@@@QAEAAVFColor@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMipmap@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFMipmap@@@@QAEAAUFMipmap@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Num@?$TArray@UFMipmap@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFFontCharacter@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFLightMapIndex@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFLightMapIndex@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFLightMapIndex@@@@QAEAAVFLightMapIndex@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Num@?$TArray@VFLightMapIndex@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFBox@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFBox@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFBox@@@@QAEAAVFBox@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFLeaf@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFLeaf@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFLeaf@@@@QAEAAVFLeaf@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Num@?$TArray@VFLeaf@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@PAVAActor@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@PAVAActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@PAVAActor@@@@QAEAAPAVAActor@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFReachSpec@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFReachSpec@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@PAVUViewport@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFMeshAnimNotify@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshAnimNotify@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshVert@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshTri@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshAnimSeq@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFMeshAnimSeq@@@@QAEAAUFMeshAnimSeq@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFMeshAnimSeq@@@@QBEABUFMeshAnimSeq@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Num@?$TArray@UFMeshAnimSeq@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshVertConnect@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFSphere@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@PAVUTexture@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@PAVUTexture@@@@QAEAAPAVUTexture@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@H@@QAEAAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddItem@?$TArray@H@@QAEHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TArray@H@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@D@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@H@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFString@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFProperty@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFName@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFConst@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFStackNode@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFDependency@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@E@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Align@@YAPAEQAEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Abs@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clamp@@YAMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Sgn@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Min@@YAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Max@@YAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Square@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Abs@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Square@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@E@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@K@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clamp@@YAHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFColor@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMipmap@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFFontCharacter@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFLightMapIndex@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFBox@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFLeaf@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@PAVAActor@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clamp@@YANNNN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFReachSpec@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@PAVUViewport@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshAnimNotify@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@UFMeshAnimNotify@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshVert@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshTri@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshAnimSeq@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshVertConnect@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFSphere@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@PAVUTexture@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Abs@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Exchange@@YAXAAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Max@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Min@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Exchange@@YAXAAPAUFTransform@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Exchange@@YAXAAUFBspDrawListPtr@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appSort@@YAXPAUFBspDrawListPtr@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFString@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFConst@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFStackNode@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFMipmap@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFMeshAnimSeq@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FMeshAnimSeq@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFString@@@@QAEAAVFString@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFConst@@@@QAEAAUFConst@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@E@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFMeshAnimNotify@@@@QAEAAUFMeshAnimNotify@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Num@?$TArray@UFMeshAnimNotify@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@UFMeshAnimNotify@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@E@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@UFMeshAnimNotify@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TArray@UFMeshAnimNotify@@@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@UFConst@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7URender@@6BFExec@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@K@@QAEAAKH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@D@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUCanvas@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInventory@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???6@YAAAVFArchive@@AAV1@AAV?$TArray@E@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@VFDependency@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R0PAX@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?OutXMinTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Add@?$TArray@E@@QAEHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@H@@QAEAAHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???6@YAAAVFArchive@@AAV1@AAVFPoly@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???6@YAAAVFArchive@@AAV1@AAVFFontCharacter@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@E@@QAEAAEH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??AddItem@?$TArray@D@@QAEHABD@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@VFProperty@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???2@YAPAXIPBD@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Half@?1??appFloor@@YAHM@Z@4MA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7UInput@@6BUObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@UFMeshAnimNotify@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Empty@?$TArray@E@@QAEXXZ@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@VFColor@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??AllocateNameEntry@@YAPAUFNameEntry@@PBDKKPAU2@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@PAVUObject@@@@QAEAAPAVUObject@@H@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???6@YAAAVFArchive@@AAV1@AAVFGuid@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SULevel@@6BUDatabase@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@VFBox@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAPawn@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUVectors@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SABrush@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???6@YAAAVFArchive@@AAV1@AAVFVert@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUPrimitive@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAPlayerPawn@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@UFMeshAnimNotify@@@@QAEAAUFMeshAnimNotify@@H@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAPlayerStart@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???3@YAXPAX@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAWeapon@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R0PAD@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_SAPathNode@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAMover@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Shrink@?$TArray@D@@QAEXXZ@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7URender@@6BUObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAActor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUEnum@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Add@?$TArray@K@@QAEHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Empty@?$TArray@UFMeshAnimNotify@@@@QAEXXZ@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@E@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SANavigationPoint@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@VFStackNode@@@@QAEAAVFStackNode@@H@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@UFMeshVert@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUMesh@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAZoneInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAButtonMarker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAGameInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATriggers@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???6@YAAAVFArchive@@AAV1@AAUFMipmap@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUBspSurfs@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@PAVUViewport@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Add@?$TArray@D@@QAEHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??appSort@@YAXPAUFBspDrawListPtr@@HH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Add@?$TArray@H@@QAEHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@UFMeshAnimSeq@@@@QAEAAUFMeshAnimSeq@@H@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATeleporter@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???6@YAAAVFArchive@@AAV1@AAVFZoneProperties@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAScout@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SASkyZoneInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUBspNodes@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FDynamicSprite@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUBitMatrix@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FDynamicItem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUGameEngine@@6BUObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???6@YAAAVFArchive@@AAV1@AAVFLeaf@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???6@YAAAVFArchive@@AAV1@AAVFReachSpec@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@UFMipmap@@@@QAEAAUFMipmap@@H@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???6@YAAAVFArchive@@AAV1@AAVFBspNode@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAKeypoint@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUPackage@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CT??_R0PAD@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?__FUNC_NAME__@?2???6@YAAAVFArchive@@AAV1@AAVFBspSurf@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@D@@QAEAADH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@UFMeshTri@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUPalette@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@VFProperty@@@@QAEAAVFProperty@@H@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUMusic@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAHUD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@VFColor@@@@QAEAAVFColor@@H@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???2@YAPAXIAAVFMemStack@@W4EMemOned@@HH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@VFSphere@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@VFLightMapIndex@@@@QAEAAVFLightMapIndex@@H@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@VFLightMapIndex@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@VFStackNode@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAWarpZoneMarker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATriggerMarker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SADecoration@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInterpolationPoint@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUPolys@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???2@YAPAXIAAVFMemStack@@HH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Add@?$TArray@UFMeshAnimNotify@@@@QAEHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@PAVAActor@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@UFMipmap@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7UInput@@6BFExec@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???2@YAPAXIAAV?$TArray@E@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUBitArray@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Empty@?$TArray@D@@QAEXXZ@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATrigger@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?OutYMinTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@UFConst@@@@QAEAAUFConst@@H@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???2@YAPAXI@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@PAVUTexture@@@@QAEAAPAVUTexture@@H@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??AddUniqueItem@?$TArray@H@@QAEHABH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?OutXMaxTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@VFName@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FCollisionHashBase@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAMenu@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUStruct@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@VFString@@@@QAEAAVFString@@H@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@VFFontCharacter@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?OutYMaxTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUVerts@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???2@YAPAXIAAV?$TArray@UFMeshAnimNotify@@@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@PAVUTexture@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@VFLeaf@@@@QAEAAVFLeaf@@H@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Empty@?$TArray@VFProperty@@@@QAEXXZ@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???6@YAAAVFArchive@@AAV1@AAUFStackNodePtr@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@VFString@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAWarpZoneInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@VFLeaf@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???6@YAAAVFArchive@@AAV1@AAUFNameEntry@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@K@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@H@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInventorySpot@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@PAUFNameEntry@@@@QAEAAPAUFNameEntry@@H@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUModel@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??AddItem@?$TArray@H@@QAEHABH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???6@YAAAVFArchive@@AAV1@AAVFLightMapIndex@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??SetSize@?$TArray@D@@QAEXH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CTA2PAD
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@VFBox@@@@QAEAAVFBox@@H@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???6@YAAAVFArchive@@AAV1@AAV?$TArray@UFMeshAnimNotify@@@@@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??FIntersectPlanes2@@YAHAAVFVector@@0ABVFPlane@@1@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@VFReachSpec@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???2@YAPAXIAAVFMemStack@@W4EMemZeroed@@HH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SALevelInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@UFMeshAnimSeq@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUTextBuffer@@6BUObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SACamera@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2???R?$TArray@PAVAActor@@@@QAEAAPAVAActor@@H@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FLightManagerBase@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??Remove@?$TArray@UFMeshVertConnect@@@@QAEXHH@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2PAD
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_SAProjectile@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUClass@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__FUNC_NAME__@?2??FIntersectPlanes3@@YAHAAVFVector@@ABVFPlane@@11@Z@4PBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, drectve, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ, xdata$x
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?HackRaster@@3PAUFRasterSpan@@A			; HackRaster
PUBLIC	?RasterStartY@@3HA				; RasterStartY
PUBLIC	?RasterEndY@@3HA				; RasterEndY
PUBLIC	?RasterStartX@@3HA				; RasterStartX
PUBLIC	?RasterEndX@@3HA				; RasterEndX
PUBLIC	?GStat@@3UFRenderStats@@A			; GStat
PUBLIC	?StaticClass@URender@@2PAVUClass@@A		; URender::StaticClass
PUBLIC	?NumDynLightSurfs@URender@@2HA			; URender::NumDynLightSurfs
PUBLIC	?NumDynLightLeaves@URender@@2HA			; URender::NumDynLightLeaves
PUBLIC	?MaxSurfLights@URender@@2HA			; URender::MaxSurfLights
PUBLIC	?MaxLeafLights@URender@@2HA			; URender::MaxLeafLights
PUBLIC	?DynLightSurfs@URender@@2PAHA			; URender::DynLightSurfs
PUBLIC	?DynLightLeaves@URender@@2PAHA			; URender::DynLightLeaves
PUBLIC	?SurfLights@URender@@2PAPAUFActorLink@@A	; URender::SurfLights
PUBLIC	?LeafLights@URender@@2PAPAUFVolActorLink@@A	; URender::LeafLights
PUBLIC	?DynamicsCache@URender@@2PAUFDynamicsCache@1@A	; URender::DynamicsCache
PUBLIC	?PointCache@URender@@2PAUFStampedPoint@1@A	; URender::PointCache
PUBLIC	?VectorMem@URender@@2VFMemStack@@A		; URender::VectorMem
PUBLIC	?Stamp@URender@@2KA				; URender::Stamp
PUBLIC	?GRender@@3PAVURender@@A			; GRender
PUBLIC	_autoclassURender
_BSS	SEGMENT
?HackRaster@@3PAUFRasterSpan@@A DQ 04b0H DUP (?)	; HackRaster
?RasterStartY@@3HA DD 01H DUP (?)			; RasterStartY
?RasterEndY@@3HA DD 01H DUP (?)				; RasterEndY
?RasterStartX@@3HA DD 01H DUP (?)			; RasterStartX
?RasterEndX@@3HA DD 01H DUP (?)				; RasterEndX
?GStat@@3UFRenderStats@@A DB 0140H DUP (?)		; GStat
?NumDynLightSurfs@URender@@2HA DD 01H DUP (?)		; URender::NumDynLightSurfs
?NumDynLightLeaves@URender@@2HA DD 01H DUP (?)		; URender::NumDynLightLeaves
?MaxSurfLights@URender@@2HA DD 01H DUP (?)		; URender::MaxSurfLights
?MaxLeafLights@URender@@2HA DD 01H DUP (?)		; URender::MaxLeafLights
?DynLightSurfs@URender@@2PAHA DD 0800H DUP (?)		; URender::DynLightSurfs
?DynLightLeaves@URender@@2PAHA DD 0400H DUP (?)		; URender::DynLightLeaves
?SurfLights@URender@@2PAPAUFActorLink@@A DD 01H DUP (?)	; URender::SurfLights
?LeafLights@URender@@2PAPAUFVolActorLink@@A DD 01H DUP (?) ; URender::LeafLights
?DynamicsCache@URender@@2PAUFDynamicsCache@1@A DD 01H DUP (?) ; URender::DynamicsCache
?PointCache@URender@@2PAUFStampedPoint@1@A DD 01H DUP (?) ; URender::PointCache
?VectorMem@URender@@2VFMemStack@@A DB 0101cH DUP (?)	; URender::VectorMem
?Stamp@URender@@2KA DD 01H DUP (?)			; URender::Stamp
?GRender@@3PAVURender@@A DD 01H DUP (?)			; GRender
_autoclassURender DB 0e4H DUP (?)
$SG15262 DB	01H DUP (?)
	ALIGN	4

$SG15266 DB	01H DUP (?)
	ALIGN	4

$SG15275 DB	01H DUP (?)
	ALIGN	4

$SG15282 DB	01H DUP (?)
	ALIGN	4

$SG15289 DB	01H DUP (?)
	ALIGN	4

$SG15293 DB	01H DUP (?)
	ALIGN	4

$SG15298 DB	01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_$S106$S15152 DD FLAT:_$E105
CRT$XCU	ENDS
_DATA	SEGMENT
?StaticClass@URender@@2PAVUClass@@A DD FLAT:_autoclassURender ; URender::StaticClass
_DATA	ENDS
CRT$XCU	SEGMENT
_$S109$S15157 DD FLAT:_$E108
CRT$XCU	ENDS
CONST	SEGMENT
_?__FUNC_NAME__@?2???0URender@@QAE@XZ@4PBDB$S15161 DB 'URender::URender', 00H
	ORG $+7
_?__FUNC_NAME__@?2??InternalClassInitializer@URender@@SAXPAVUClass@@@Z@4PBDB$S15182 DB 
	DB	'URender::InternalClassInitializer', 00H
	ORG $+6
_?__FUNC_NAME__@?2??Init@URender@@UAEXPAVUEngine@@@Z@4PBDB$S15191 DB 'URe'
	DB	'nder::Init', 00H
	ORG $+2
_?__FUNC_NAME__@?2??Destroy@URender@@UAEXXZ@4PBDB$S15207 DB 'URender::Des'
	DB	'troy', 00H
	ORG $+7
_?__FUNC_NAME__@?2??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S15223 DB 
	DB	'URender::DrawStats', 00H
	ORG $+5
_?__FUNC_NAME__@?2??ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ@4PBDB$S15309 DB 
	DB	'URender::ShowStat', 00H
CONST	ENDS
CRT$XCU	SEGMENT
_$S112$S15323 DD FLAT:_$E111
CRT$XCU	ENDS
CONST	SEGMENT
	ORG $+6
_?__FUNC_NAME__@?2??PreRender@URender@@UAEXPAUFSceneNode@@@Z@4PBDB$S15328 DB 
	DB	'URender::PreRender', 00H
	ORG $+5
_?__FUNC_NAME__@?2??PostRender@URender@@UAEXPAUFSceneNode@@@Z@4PBDB$S15337 DB 
	DB	'URender::PostRender', 00H
	ORG $+4
_?__FUNC_NAME__@?2??Exec@URender@@UAEHPBDPAVFOutputDevice@@@Z@4PBDB$S15359 DB 
	DB	'URender::Exec', 00H
	ORG $+2
_?__FUNC_NAME__@?2??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PBDB$S15442 DB 
	DB	'URender::ClipBspSurf', 00H
	ORG $+3
_?__FUNC_NAME__@?2??CreateMasterFrame@URender@@UAEPAUFSceneNode@@PAVUViewport@@VFVector@@VFRotation@@PAUFScreenBounds@@@Z@4PBDB$S15518 DB 
	DB	'URender::CreateMasterFrame', 00H
	ORG $+5
_?__FUNC_NAME__@?2??CreateChildFrame@URender@@UAEPAUFSceneNode@@PAU3@PAVFSpanBuffer@@PAVULevel@@HHMABVFPlane@@ABVFCoords@@MPAUFScreenBounds@@@Z@4PBDB$S15547 DB 
	DB	'URender::CreateChildFrame', 00H
	ORG $+6
_?__FUNC_NAME__@?2??SetupRaster@@YAHPAPAUFTransform@@HPAVFSpanBuffer@@H@Z@4PBDB$S15589 DB 
	DB	'SetupRaster', 00H
	ORG $+4
_?__FUNC_NAME__@?2??GetVisibleSurfs@URender@@UAEXPAVUViewport@@AAV?$TArray@H@@@Z@4PBDB$S15655 DB 
	DB	'URender::GetVisibleSurfs', 00H
	ORG $+7
_?__FUNC_NAME__@?2??BoundVisible@URender@@UAEHPAUFSceneNode@@PAVFBox@@PAVFSpanBuffer@@AAUFScreenBounds@@@Z@4PBDB$S15695 DB 
	DB	'URender::BoundVisible', 00H
	ORG $+2
_?__FUNC_NAME__@?2??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S15975 DB 
	DB	'URender::OccludeBsp', 00H
	ORG $+4
_?__FUNC_NAME__@?BB@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S15992 DB 
	DB	'HandleInWarp', 00H
	ORG $+3
_?__FUNC_NAME__@?GJ@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S16087 DB 
	DB	'HandleSkyWarp', 00H
	ORG $+2
_?__FUNC_NAME__@?HB@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S16099 DB 
	DB	'HandleMirrorWarp', 00H
	ORG $+7
_?__FUNC_NAME__@?JF@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S16138 DB 
	DB	'HandleWarpPortal', 00H
	ORG $+7
_?__FUNC_NAME__@?2??OccludeFrame@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S16301 DB 
	DB	'URender::DrawLevel', 00H
	ORG $+5
_?__FUNC_NAME__@?2??DrawFrame@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S16355 DB 
	DB	'URender::DrawFrame', 00H
	ORG $+5
_?__FUNC_NAME__@?2??DrawWorld@URender@@UAEXPAUFSceneNode@@@Z@4PBDB$S16542 DB 
	DB	'URender::DrawWorld', 00H
CONST	ENDS
drectve	SEGMENT
$SG15128 DB	'-INCLUDE:___@@_PchSym_@00@UpormtlmhUivmwviUhixUivovzhvUi'
	DB	'vmwviOlyq@', 00H
drectve	ENDS
_DATA	SEGMENT
$SG15140 DB	'URender', 00H
$SG15164 DB	'Render size mismatch: C=%i U=%i', 00H
$SG15166 DB	'Check failed: FBspNode::MAX_NODE_VERTICES<=FPoly::MAX_VE'
	DB	'RTICES [File:D:\Klingons\Render\Src\UnRender.cpp] [Line: %i]', 00H
	ORG $+3
$SG15169 DB	'Check failed: sizeof(FVector)==12 [File:D:\Klingons\Rend'
	DB	'er\Src\UnRender.cpp] [Line: %i]', 00H
$SG15172 DB	'Check failed: sizeof(FRotation)==12 [File:D:\Klingons\Re'
	DB	'nder\Src\UnRender.cpp] [Line: %i]', 00H
	ORG $+2
$SG15175 DB	'Check failed: sizeof(FCoords)==48 [File:D:\Klingons\Rend'
	DB	'er\Src\UnRender.cpp] [Line: %i]', 00H
$SG15178 DB	'%s', 00H
	ORG $+1
$SG15186 DB	'%s', 00H
	ORG $+1
$SG15200 DB	'Rendering initialized', 00H
	ORG $+2
$SG15203 DB	'%s', 00H
	ORG $+1
$SG15213 DB	'Rendering shut down', 00H
$SG15216 DB	'%s', 00H
	ORG $+1
$SG15248 DB	'Frame=%05.1f (%05.1f/%05.1f) FPS Render=%05.1f MSEC Node'
	DB	's=%03i Polys=%03i', 00H
	ORG $+2
$SG15250 DB	'%s', 00H
	ORG $+1
$SG15253 DB	'GLOBAL:', 00H
$SG15259 DB	'  FRAME=%04.1f: GAME=%04.1f CLIENT=%04.1f BLIT=%04.1f PL'
	DB	'ATFM=%04.1f', 00H
$SG15260 DB	'  %s', 00H
	ORG $+3
$SG15261 DB	'  RENDER=%04.1f MESH=%04.1f POLYV=%04.1f ILLUM=%04.1f OC'
	DB	'C=%04.1f FILT=%04.1f EX=%04.1f', 00H
	ORG $+1
$SG15264 DB	'HARDWARE:', 00H
	ORG $+2
$SG15265 DB	'  %s', 00H
	ORG $+3
$SG15271 DB	'MESH: %04.1f', 00H
	ORG $+3
$SG15272 DB	'  GetFrame=%04.1f Process=%04.1f LightSet=%04.1f Light=%'
	DB	'04.1f', 00H
	ORG $+2
$SG15273 DB	'  Sub=%04.1f Clip=%04.1f Tmap=%04.1f', 00H
	ORG $+3
$SG15274 DB	'  MeshCount=%i MeshPolyCount=%i MeshSubCount=%i MeshLigh'
	DB	'ts=%i MeshVtrics=%i VertLights=%i', 00H
	ORG $+2
$SG15281 DB	'Zones: Visible=%i/%i Reject=%i', 00H
	ORG $+1
$SG15285 DB	'Occlusion=%04.1f:', 00H
	ORG $+2
$SG15286 DB	'   Clip=%04.1f Raster=%04.1f Span=%04.1f Visit=%i/%i Poi'
	DB	'nts=%i', 00H
	ORG $+1
$SG15287 DB	'   Transform=%i Clip=%i Raster=%i RasterAccept=%i DrawNo'
	DB	'des=%i', 00H
	ORG $+1
$SG15288 DB	'   BoxTime=%04.1f BoxChecks=%i BoxBacks=%i BoxIn=%i BoxO'
	DB	'utPyr=%i BoxSpanOcc=%i', 00H
	ORG $+1
$SG15291 DB	'GAME:', 00H
	ORG $+2
$SG15292 DB	'   %s', 00H
	ORG $+2
$SG15296 DB	'CACHE:', 00H
	ORG $+1
$SG15297 DB	'   %s', 00H
	ORG $+2
$SG15301 DB	'%s', 00H
	ORG $+1
$SG15313 DB	'%s', 00H
	ORG $+1
$SG15314 DB	' ', 00H
	ORG $+2
$SG15317 DB	'%s', 00H
	ORG $+1
$SG15332 DB	'%s', 00H
	ORG $+1
$SG15342 DB	'Check failed: Frame->Viewport->Actor->FlashTexture [File'
	DB	':D:\Klingons\Render\Src\UnRender.cpp] [Line: %i]', 00H
	ORG $+3
$SG15353 DB	'%s', 00H
	ORG $+1
$SG15363 DB	'STAT', 00H
	ORG $+3
$SG15365 DB	'Fps', 00H
$SG15367 DB	'Global', 00H
	ORG $+1
$SG15369 DB	'Mesh', 00H
	ORG $+3
$SG15371 DB	'Actor', 00H
	ORG $+2
$SG15373 DB	'Filter', 00H
	ORG $+1
$SG15375 DB	'Reject', 00H
	ORG $+1
$SG15377 DB	'Span', 00H
	ORG $+3
$SG15379 DB	'Zone', 00H
	ORG $+3
$SG15381 DB	'Light', 00H
	ORG $+2
$SG15383 DB	'Occlusion', 00H
	ORG $+2
$SG15385 DB	'Game', 00H
	ORG $+3
$SG15387 DB	'Soft', 00H
	ORG $+3
$SG15389 DB	'Cache', 00H
	ORG $+2
$SG15391 DB	'PolyV', 00H
	ORG $+2
$SG15393 DB	'PolyC', 00H
	ORG $+2
$SG15395 DB	'Illum', 00H
	ORG $+2
$SG15397 DB	'Hardware', 00H
	ORG $+3
$SG15400 DB	'REND', 00H
	ORG $+3
$SG15402 DB	'LEAK', 00H
	ORG $+3
$SG15405 DB	'T', 00H
	ORG $+2
$SG15407 DB	'Rendering option recognized', 00H
$SG15411 DB	'%s', 00H
	ORG $+1
$SG15510 DB	'%s', 00H
	ORG $+1
$SG15529 DB	'%s', 00H
	ORG $+1
$SG15576 DB	'%s', 00H
	ORG $+1
$SG15649 DB	'%s', 00H
	ORG $+1
$SG15687 DB	'%s', 00H
	ORG $+1
$SG15837 DB	'%s', 00H
	ORG $+1
$SG15978 DB	'Check failed: Frame->Level->Model->Nodes->Max()<MAX_NODE'
	DB	'S [File:D:\Klingons\Render\Src\UnRender.cpp] [Line: %i]', 00H
$SG15980 DB	'Check failed: Frame->Level->Model->Points->Max()<MAX_POI'
	DB	'NTS [File:D:\Klingons\Render\Src\UnRender.cpp] [Line: %i]', 00H
	ORG $+2
$SG15999 DB	'%s', 00H
	ORG $+1
$SG16095 DB	'%s', 00H
	ORG $+1
$SG16114 DB	'%s', 00H
	ORG $+1
$SG16153 DB	'%s', 00H
	ORG $+1
$SG16245 DB	'%s', 00H
	ORG $+1
$SG16307 DB	'Check failed: Model->Nodes->Num()>0 [File:D:\Klingons\Re'
	DB	'nder\Src\UnRender.cpp] [Line: %i]', 00H
	ORG $+2
$SG16312 DB	'SurfLights', 00H
	ORG $+1
$SG16318 DB	'LeafLights', 00H
	ORG $+1
$SG16350 DB	'%s', 00H
	ORG $+1
$SG16360 DB	'Check failed: Model->Nodes->Num()>0 [File:D:\Klingons\Re'
	DB	'nder\Src\UnRender.cpp] [Line: %i]', 00H
	ORG $+2
$SG16505 DB	'Check failed: Light->IsValid() [File:D:\Klingons\Render\'
	DB	'Src\UnRender.cpp] [Line: %i]', 00H
	ORG $+3
$SG16531 DB	'%s', 00H
	ORG $+1
$SG16552 DB	'%s', 00H
_DATA	ENDS
PUBLIC	?InternalConstructor@URender@@SAXPAX@Z		; URender::InternalConstructor
PUBLIC	?InternalClassInitializer@URender@@SAXPAVUClass@@@Z ; URender::InternalClassInitializer
EXTRN	__imp_?StaticClass@URenderBase@@2PAVUClass@@A:DWORD
EXTRN	__imp_??0FName@@QAE@PBDW4EFindName@@@Z:NEAR
EXTRN	_atexit:NEAR
EXTRN	__imp_??0UClass@@QAE@KKKPAV0@VFGuid@@PBDVFName@@P6AXPAX@ZP6AX0@Z@Z:NEAR
EXTRN	_GPackage:BYTE
_TEXT	SEGMENT
$T18834 = -4
_$E105	PROC NEAR
	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	push	OFFSET FLAT:?InternalClassInitializer@URender@@SAXPAVUClass@@@Z ; URender::InternalClassInitializer
	push	OFFSET FLAT:?InternalConstructor@URender@@SAXPAX@Z ; URender::InternalConstructor
	push	1
	push	OFFSET FLAT:_GPackage
	lea	ecx, DWORD PTR $T18834[esp+36]
	xor	esi, esi
	xor	edi, edi
	xor	ebx, ebx
	xor	ebp, ebp
	call	DWORD PTR __imp_??0FName@@QAE@PBDW4EFindName@@@Z
	mov	eax, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?StaticClass@URenderBase@@2PAVUClass@@A
	push	eax
	push	OFFSET FLAT:$SG15140
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR [edx]
	mov	ecx, esp
	push	eax
	push	4
	mov	DWORD PTR [ecx], esi
	push	ebp
	push	240					; 000000f0H
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+12], ebp
	mov	ecx, OFFSET FLAT:_autoclassURender
	call	DWORD PTR __imp_??0UClass@@QAE@KKKPAV0@VFGuid@@PBDVFName@@P6AXPAX@ZP6AX0@Z@Z
	push	OFFSET FLAT:_$E103
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
_$E105	ENDP
_TEXT	ENDS
EXTRN	__imp_??1UClass@@UAE@XZ:NEAR
_TEXT	SEGMENT
_$E103	PROC NEAR
	mov	ecx, OFFSET FLAT:_autoclassURender
	jmp	DWORD PTR __imp_??1UClass@@UAE@XZ
_$E103	ENDP
_$E108	PROC NEAR
	ret	0
_$E108	ENDP
_TEXT	ENDS
PUBLIC	??0URender@@QAE@XZ				; URender::URender
PUBLIC	?Destroy@URender@@UAEXXZ			; URender::Destroy
PUBLIC	?Init@URender@@UAEXPAVUEngine@@@Z		; URender::Init
PUBLIC	?Exec@URender@@UAEHPBDPAVFOutputDevice@@@Z	; URender::Exec
PUBLIC	?PreRender@URender@@UAEXPAUFSceneNode@@@Z	; URender::PreRender
PUBLIC	?PostRender@URender@@UAEXPAUFSceneNode@@@Z	; URender::PostRender
PUBLIC	?DrawWorld@URender@@UAEXPAUFSceneNode@@@Z	; URender::DrawWorld
PUBLIC	??_R0PAD@8					; char * `RTTI Type Descriptor'
PUBLIC	__TI2PAD
PUBLIC	__CTA2PAD
PUBLIC	__CT??_R0PAD@84
PUBLIC	??_R0PAX@8					; void * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAX@84
PUBLIC	?GetVisibleSurfs@URender@@UAEXPAVUViewport@@AAV?$TArray@H@@@Z ; URender::GetVisibleSurfs
PUBLIC	?BoundVisible@URender@@UAEHPAUFSceneNode@@PAVFBox@@PAVFSpanBuffer@@AAUFScreenBounds@@@Z ; URender::BoundVisible
PUBLIC	?CreateMasterFrame@URender@@UAEPAUFSceneNode@@PAVUViewport@@VFVector@@VFRotation@@PAUFScreenBounds@@@Z ; URender::CreateMasterFrame
PUBLIC	?CreateChildFrame@URender@@UAEPAUFSceneNode@@PAU2@PAVFSpanBuffer@@PAVULevel@@HHMABVFPlane@@ABVFCoords@@MPAUFScreenBounds@@@Z ; URender::CreateChildFrame
PUBLIC	??_7URender@@6BUObject@@@			; URender::`vftable'
PUBLIC	??_7URender@@6BFExec@@@				; URender::`vftable'
PUBLIC	??_EURender@@UAEPAXI@Z				; URender::`vector deleting destructor'
EXTRN	__imp_??1URenderBase@@UAE@XZ:NEAR
EXTRN	__CxxThrowException@8:NEAR
EXTRN	?FunctionIsRemote@UObject@@UAEHAAUFStackNodePtr@@@Z:NEAR ; UObject::FunctionIsRemote
EXTRN	?IsPendingKill@UObject@@UAEHXZ:NEAR		; UObject::IsPendingKill
EXTRN	__imp_??0UObject@@QAE@XZ:NEAR
EXTRN	__imp_?appErrorf@@YAXPBDZZ:NEAR
EXTRN	__imp_?appUnwindf@@YAXPBDZZ:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	__imp_??_7FExec@@6B@:DWORD
EXTRN	?Deproject@URender@@UAEHPAUFSceneNode@@HHAAVFVector@@@Z:NEAR ; URender::Deproject
EXTRN	?Project@URender@@UAEHPAUFSceneNode@@ABVFVector@@AAM2PAM@Z:NEAR ; URender::Project
EXTRN	?DrawActor@URender@@UAEXPAUFSceneNode@@PAVAActor@@@Z:NEAR ; URender::DrawActor
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	?DrawLevelActors@URender@@UAEXPAUFSceneNode@@PAVAActor@@@Z:NEAR ; URender::DrawLevelActors
EXTRN	?GlobalLighting@URender@@UAEXHPAVAActor@@AAMAAVFPlane@@@Z:NEAR ; URender::GlobalLighting
EXTRN	?Draw2DClippedLine@URender@@UAEXPAUFSceneNode@@VFPlane@@KVFVector@@2@Z:NEAR ; URender::Draw2DClippedLine
EXTRN	?Draw3DLine@URender@@UAEXPAUFSceneNode@@VFPlane@@KVFVector@@2@Z:NEAR ; URender::Draw3DLine
EXTRN	?DrawCircle@URender@@UAEXPAUFSceneNode@@VFPlane@@KAAVFVector@@M@Z:NEAR ; URender::DrawCircle
EXTRN	?DrawBox@URender@@UAEXPAUFSceneNode@@VFPlane@@KVFVector@@2@Z:NEAR ; URender::DrawBox
EXTRN	?QueryInterface@UObject@@UAGKABVFGuid@@PAPAX@Z:NEAR ; UObject::QueryInterface
EXTRN	?AddRef@UObject@@UAGKXZ:NEAR			; UObject::AddRef
EXTRN	?Release@UObject@@UAGKXZ:NEAR			; UObject::Release
EXTRN	?ProcessEvent@UObject@@UAEXVFName@@PAX@Z:NEAR	; UObject::ProcessEvent
EXTRN	?ProcessState@UObject@@UAEXM@Z:NEAR		; UObject::ProcessState
EXTRN	?CallInternal@UObject@@UAEXAAUFExecStack@@@Z:NEAR ; UObject::CallInternal
EXTRN	?ExportToFile@UObject@@UAEHPBD@Z:NEAR		; UObject::ExportToFile
EXTRN	?CRC@UObject@@UAEKXZ:NEAR			; UObject::CRC
EXTRN	?MemUsage@UObject@@UAEHXZ:NEAR			; UObject::MemUsage
EXTRN	?Modify@UObject@@UAEXXZ:NEAR			; UObject::Modify
EXTRN	?Export@UObject@@UAEXAAVFOutputDevice@@PBDH@Z:NEAR ; UObject::Export
EXTRN	?PostLoad@UObject@@UAEXK@Z:NEAR			; UObject::PostLoad
EXTRN	?Serialize@UObject@@UAEXAAVFArchive@@@Z:NEAR	; UObject::Serialize
EXTRN	?Lock@UObject@@UAEHK@Z:NEAR			; UObject::Lock
EXTRN	?Unlock@UObject@@UAEXK@Z:NEAR			; UObject::Unlock
EXTRN	?GotoState@UObject@@UAEHVFName@@@Z:NEAR		; UObject::GotoState
EXTRN	?GotoLabel@UObject@@UAEHVFName@@@Z:NEAR		; UObject::GotoLabel
EXTRN	?InitExecution@UObject@@UAEXXZ:NEAR		; UObject::InitExecution
EXTRN	?BeginExecution@UObject@@UAEXXZ:NEAR		; UObject::BeginExecution
EXTRN	?ShutdownAfterError@UObject@@UAEXXZ:NEAR	; UObject::ShutdownAfterError
EXTRN	?PreEditChange@UObject@@UAEXXZ:NEAR		; UObject::PreEditChange
EXTRN	?PostEditChange@UObject@@UAEXXZ:NEAR		; UObject::PostEditChange
;	COMDAT ??_R0PAD@8
; File ..\..\Core\Inc\UnClass.h
_DATA	SEGMENT
??_R0PAD@8 DD	FLAT:??_7type_info@@6B@			; char * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAD', 00H
_DATA	ENDS
;	COMDAT ??_R0PAX@8
_DATA	SEGMENT
??_R0PAX@8 DD	FLAT:??_7type_info@@6B@			; void * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAX', 00H
_DATA	ENDS
;	COMDAT __CT??_R0PAD@84
xdata$x	SEGMENT
__CT??_R0PAD@84 DD 01H
	DD	FLAT:??_R0PAD@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT
__CT??_R0PAX@84 DD 01H
	DD	FLAT:??_R0PAX@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CTA2PAD
xdata$x	SEGMENT
__CTA2PAD DD	02H
	DD	FLAT:__CT??_R0PAD@84
	DD	FLAT:__CT??_R0PAX@84
xdata$x	ENDS
;	COMDAT __TI2PAD
xdata$x	SEGMENT
__TI2PAD DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2PAD
xdata$x	ENDS
;	COMDAT ??_7URender@@6BUObject@@@
CONST	SEGMENT
??_7URender@@6BUObject@@@ DD FLAT:?QueryInterface@UObject@@UAGKABVFGuid@@PAPAX@Z ; URender::`vftable'
	DD	FLAT:?AddRef@UObject@@UAGKXZ
	DD	FLAT:?Release@UObject@@UAGKXZ
	DD	FLAT:??_EURender@@UAEPAXI@Z
	DD	FLAT:?ProcessEvent@UObject@@UAEXVFName@@PAX@Z
	DD	FLAT:?ProcessState@UObject@@UAEXM@Z
	DD	FLAT:?CallInternal@UObject@@UAEXAAUFExecStack@@@Z
	DD	FLAT:?FunctionIsRemote@UObject@@UAEHAAUFStackNodePtr@@@Z
	DD	FLAT:?ExportToFile@UObject@@UAEHPBD@Z
	DD	FLAT:?CRC@UObject@@UAEKXZ
	DD	FLAT:?MemUsage@UObject@@UAEHXZ
	DD	FLAT:?Modify@UObject@@UAEXXZ
	DD	FLAT:?Export@UObject@@UAEXAAVFOutputDevice@@PBDH@Z
	DD	FLAT:?PostLoad@UObject@@UAEXK@Z
	DD	FLAT:?Destroy@URender@@UAEXXZ
	DD	FLAT:?Serialize@UObject@@UAEXAAVFArchive@@@Z
	DD	FLAT:?Lock@UObject@@UAEHK@Z
	DD	FLAT:?Unlock@UObject@@UAEXK@Z
	DD	FLAT:?IsPendingKill@UObject@@UAEHXZ
	DD	FLAT:?GotoState@UObject@@UAEHVFName@@@Z
	DD	FLAT:?GotoLabel@UObject@@UAEHVFName@@@Z
	DD	FLAT:?InitExecution@UObject@@UAEXXZ
	DD	FLAT:?BeginExecution@UObject@@UAEXXZ
	DD	FLAT:?ShutdownAfterError@UObject@@UAEXXZ
	DD	FLAT:?PreEditChange@UObject@@UAEXXZ
	DD	FLAT:?PostEditChange@UObject@@UAEXXZ
	DD	FLAT:?Init@URender@@UAEXPAVUEngine@@@Z
	DD	FLAT:?PreRender@URender@@UAEXPAUFSceneNode@@@Z
	DD	FLAT:?PostRender@URender@@UAEXPAUFSceneNode@@@Z
	DD	FLAT:?CreateMasterFrame@URender@@UAEPAUFSceneNode@@PAVUViewport@@VFVector@@VFRotation@@PAUFScreenBounds@@@Z
	DD	FLAT:?CreateChildFrame@URender@@UAEPAUFSceneNode@@PAU2@PAVFSpanBuffer@@PAVULevel@@HHMABVFPlane@@ABVFCoords@@MPAUFScreenBounds@@@Z
	DD	FLAT:?DrawWorld@URender@@UAEXPAUFSceneNode@@@Z
	DD	FLAT:?DrawActor@URender@@UAEXPAUFSceneNode@@PAVAActor@@@Z
	DD	FLAT:?Project@URender@@UAEHPAUFSceneNode@@ABVFVector@@AAM2PAM@Z
	DD	FLAT:?Deproject@URender@@UAEHPAUFSceneNode@@HHAAVFVector@@@Z
	DD	FLAT:?DrawLevelActors@URender@@UAEXPAUFSceneNode@@PAVAActor@@@Z
	DD	FLAT:?BoundVisible@URender@@UAEHPAUFSceneNode@@PAVFBox@@PAVFSpanBuffer@@AAUFScreenBounds@@@Z
	DD	FLAT:?GetVisibleSurfs@URender@@UAEXPAVUViewport@@AAV?$TArray@H@@@Z
	DD	FLAT:?GlobalLighting@URender@@UAEXHPAVAActor@@AAMAAVFPlane@@@Z
	DD	FLAT:?Draw2DClippedLine@URender@@UAEXPAUFSceneNode@@VFPlane@@KVFVector@@2@Z
	DD	FLAT:?Draw3DLine@URender@@UAEXPAUFSceneNode@@VFPlane@@KVFVector@@2@Z
	DD	FLAT:?DrawCircle@URender@@UAEXPAUFSceneNode@@VFPlane@@KAAVFVector@@M@Z
	DD	FLAT:?DrawBox@URender@@UAEXPAUFSceneNode@@VFPlane@@KVFVector@@2@Z
CONST	ENDS
;	COMDAT ??_7URender@@6BFExec@@@
CONST	SEGMENT
??_7URender@@6BFExec@@@ DD FLAT:?Exec@URender@@UAEHPBDPAVFOutputDevice@@@Z ; URender::`vftable'
CONST	ENDS
xdata$x	SEGMENT
$T18868	DD	019930520H
	DD	03H
	DD	FLAT:$T18872
	DD	01H
	DD	FLAT:$T18873
	DD	2 DUP(00H)
	ORG $+4
$T18872	DD	0ffffffffH
	DD	FLAT:$L18845
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T18873	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	FLAT:$T18874
	ORG $+4
$T18874	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffecH
	DD	FLAT:$L18842
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L18843
xdata$x	ENDS
_TEXT	SEGMENT
$T18840 = -20
__$EHRec$ = -16
_this$ = -24
_Err$15176 = -20
??0URender@@QAE@XZ PROC NEAR				; URender::URender

; 51   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L18870
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	call	DWORD PTR __imp_??0UObject@@QAE@XZ
	mov	eax, DWORD PTR __imp_??_7FExec@@6B@
	mov	DWORD PTR [esi+88], eax

; 52   : 	guard(URender::URender);
; 53   : 
; 54   : 	// Validate stuff.
; 55   : 	if(sizeof(*this)!=GetClass()->Properties.GetSize())

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR [esi], OFFSET FLAT:??_7URender@@6BUObject@@@ ; URender::`vftable'
	mov	DWORD PTR [esi+88], OFFSET FLAT:??_7URender@@6BFExec@@@ ; URender::`vftable'
	mov	ecx, DWORD PTR [eax+116]
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	ecx, 240				; 000000f0H
	je	SHORT $L15174

; 56   : 		appErrorf( "Render size mismatch: C=%i U=%i", sizeof(*this), GetClass()->Properties.GetSize() );

	push	ecx
	push	240					; 000000f0H
	push	OFFSET FLAT:$SG15164
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 12					; 0000000cH

; 63   : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L18842:

; 57   : 	check(FBspNode::MAX_NODE_VERTICES<=FPoly::MAX_VERTICES);
; 58   : 	check(sizeof(FVector)==12);
; 59   : 	check(sizeof(FRotation)==12);
; 60   : 	check(sizeof(FCoords)==48);
; 61   : 
; 62   : 	unguard;

	mov	edx, DWORD PTR _Err$15176[ebp]
	lea	eax, DWORD PTR $T18840[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	eax
	mov	DWORD PTR $T18840[ebp], edx
	call	__CxxThrowException@8
	mov	eax, $L18869
	ret	0
$L18843:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2???0URender@@QAE@XZ@4PBDB$S15161
	push	OFFSET FLAT:$SG15178
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L18869
	ret	0
$L18869:
	mov	esi, DWORD PTR _this$[ebp]
$L15174:

; 63   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
$L18845:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1URenderBase@@UAE@XZ
$L18870:
	mov	eax, OFFSET FLAT:$T18868
	jmp	___CxxFrameHandler
text$x	ENDS
??0URender@@QAE@XZ ENDP					; URender::URender
_TEXT	SEGMENT
?InternalClassInitializer@URender@@SAXPAVUClass@@@Z PROC NEAR ; URender::InternalClassInitializer

; 70   : 	guard(URender::InternalClassInitializer);
; 71   : 	unguard;
; 72   : }

	ret	0
?InternalClassInitializer@URender@@SAXPAVUClass@@@Z ENDP ; URender::InternalClassInitializer
_TEXT	ENDS
PUBLIC	??2@YAPAXI@Z					; operator new
EXTRN	__imp_?GSystem@@3PAVFGlobalPlatform@@A:DWORD
EXTRN	__imp_?GCache@@3VFMemCache@@A:BYTE
EXTRN	__imp_?appMemset@@YAPAXPAXHH@Z:NEAR
EXTRN	?GLightManager@@3PAVFLightManagerBase@@A:DWORD	; GLightManager
EXTRN	__imp_?Logf@FOutputDevice@@QAAXW4EName@@PBDZZ:NEAR
EXTRN	?InitDither@@YAXXZ:NEAR				; InitDither
EXTRN	__imp_?Flush@FMemCache@@QAEX_KKH@Z:NEAR
EXTRN	__imp_?Init@FMemStack@@QAEXAAVFMemCache@@HH@Z:NEAR
xdata$x	SEGMENT
$T18888	DD	019930520H
	DD	02H
	DD	FLAT:$T18891
	DD	01H
	DD	FLAT:$T18892
	DD	2 DUP(00H)
	ORG $+4
$T18891	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T18892	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T18893
	ORG $+4
$T18893	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffecH
	DD	FLAT:$L18884
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L18885
xdata$x	ENDS
_TEXT	SEGMENT
$T18882 = 8
__$EHRec$ = -16
_InEngine$ = 8
_Err$15201 = -20
?Init@URender@@UAEXPAVUEngine@@@Z PROC NEAR		; URender::Init

; 79   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L18890
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ecx

; 80   : 	guard(URender::Init);
; 81   : 
; 82   : 	// Call base.
; 83   : 	URenderBase::Init( InEngine );

	mov	eax, DWORD PTR _InEngine$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 84   : 
; 85   : 	// Set global render pointer.
; 86   : 	GRender = this;
; 87   : 
; 88   : 	// Init.
; 89   : 	NumDynLightSurfs  = 0;
; 90   : 	NumDynLightLeaves = 0;
; 91   : 
; 92   : 	// Allocate rendering stuff.
; 93   : 	PointCache		= new FStampedPoint [MAX_POINTS];

	push	1024000					; 000fa000H
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR [ecx+92], eax
	mov	DWORD PTR ?GRender@@3PAVURender@@A, ecx	; GRender
	mov	DWORD PTR ?NumDynLightSurfs@URender@@2HA, 0 ; URender::NumDynLightSurfs
	mov	DWORD PTR ?NumDynLightLeaves@URender@@2HA, 0 ; URender::NumDynLightLeaves
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR ?PointCache@URender@@2PAUFStampedPoint@1@A, eax ; URender::PointCache

; 94   : 	DynamicsCache   = new FDynamicsCache[MAX_NODES];

	push	524288					; 00080000H
	call	??2@YAPAXI@Z				; operator new

; 95   : 	appMemset( DynamicsCache, 0, MAX_NODES * sizeof(FDynamicsCache) );

	mov	esi, DWORD PTR __imp_?appMemset@@YAPAXPAXHH@Z
	add	esp, 4
	mov	DWORD PTR ?DynamicsCache@URender@@2PAUFDynamicsCache@1@A, eax ; URender::DynamicsCache
	push	524288					; 00080000H
	push	0
	push	eax
	call	esi
	add	esp, 12					; 0000000cH

; 96   : 
; 97   : 	InitDither();

	call	?InitDither@@YAXXZ			; InitDither

; 98   : 	GCache.Flush();

	mov	ecx, DWORD PTR __imp_?GCache@@3VFMemCache@@A
	push	0
	push	-1
	push	0
	push	0
	call	DWORD PTR __imp_?Flush@FMemCache@@QAEX_KKH@Z

; 99   : 
; 100  : 	// Caches.
; 101  : 	for( INT i=0; i<MAX_POINTS;  i++ )

	mov	ecx, DWORD PTR ?PointCache@URender@@2PAUFStampedPoint@1@A ; URender::PointCache
	mov	edx, DWORD PTR ?Stamp@URender@@2KA	; URender::Stamp
	xor	eax, eax
$L15197:
	cmp	eax, 128000				; 0001f400H
	jge	SHORT $L15199

; 102  : 		PointCache [i].Stamp = Stamp;

	mov	DWORD PTR [ecx+eax*8+4], edx
	inc	eax
	jmp	SHORT $L15197
$L15199:

; 103  : 	VectorMem.Init( GCache, 16384, 65536 );

	mov	ecx, DWORD PTR __imp_?GCache@@3VFMemCache@@A
	push	65536					; 00010000H
	push	16384					; 00004000H
	push	ecx
	mov	ecx, OFFSET FLAT:?VectorMem@URender@@2VFMemStack@@A
	call	DWORD PTR __imp_?Init@FMemStack@@QAEXAAVFMemCache@@HH@Z

; 104  : 
; 105  : 	// Init stats.
; 106  : 	STAT(appMemset(&GStat,0,sizeof(GStat));)

	push	320					; 00000140H
	push	0
	push	OFFSET FLAT:?GStat@@3UFRenderStats@@A	; GStat
	call	esi

; 107  : 
; 108  : 	// Light manager.
; 109  : 	GLightManager->Init();

	mov	ecx, DWORD PTR ?GLightManager@@3PAVFLightManagerBase@@A ; GLightManager
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx]

; 110  : 
; 111  : 	debugf( NAME_Init, "Rendering initialized" );

	mov	eax, DWORD PTR __imp_?GSystem@@3PAVFGlobalPlatform@@A
	push	OFFSET FLAT:$SG15200
	push	762					; 000002faH
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp_?Logf@FOutputDevice@@QAAXW4EName@@PBDZZ
	add	esp, 12					; 0000000cH

; 113  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L18884:

; 112  : 	unguard;

	mov	edx, DWORD PTR _Err$15201[ebp]
	lea	eax, DWORD PTR $T18882[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	eax
	mov	DWORD PTR $T18882[ebp], edx
	call	__CxxThrowException@8
	mov	eax, $L15192
	ret	0
$L18885:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??Init@URender@@UAEXPAVUEngine@@@Z@4PBDB$S15191
	push	OFFSET FLAT:$SG15203
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L15192
	ret	0
$L15192:

; 113  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
$L18890:
	mov	eax, OFFSET FLAT:$T18888
	jmp	___CxxFrameHandler
text$x	ENDS
?Init@URender@@UAEXPAVUEngine@@@Z ENDP			; URender::Init
PUBLIC	??3@YAXPAX@Z					; operator delete
EXTRN	__imp_?Destroy@UObject@@UAEXXZ:NEAR
EXTRN	__imp_?appFree@@YAXPAX@Z:NEAR
EXTRN	__imp_?Exit@FMemStack@@QAEXXZ:NEAR
xdata$x	SEGMENT
$T18901	DD	019930520H
	DD	02H
	DD	FLAT:$T18904
	DD	01H
	DD	FLAT:$T18905
	DD	2 DUP(00H)
	ORG $+4
$T18904	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T18905	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T18906
	ORG $+4
$T18906	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffecH
	DD	FLAT:$L18898
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L18899
xdata$x	ENDS
_TEXT	SEGMENT
$T18896 = -20
__$EHRec$ = -16
_Err$15214 = -20
?Destroy@URender@@UAEXXZ PROC NEAR			; URender::Destroy

; 119  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L18903
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ecx

; 120  : 	guard(URender::Destroy);
; 121  : 
; 122  : 	delete PointCache;

	mov	eax, DWORD PTR ?PointCache@URender@@2PAUFStampedPoint@1@A ; URender::PointCache
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??3@YAXPAX@Z				; operator delete

; 123  : 	delete DynamicsCache;

	mov	eax, DWORD PTR ?DynamicsCache@URender@@2PAUFDynamicsCache@1@A ; URender::DynamicsCache
	add	esp, 4
	push	eax
	call	??3@YAXPAX@Z				; operator delete

; 124  : 	if( SurfLights ) appFree(SurfLights);

	mov	eax, DWORD PTR ?SurfLights@URender@@2PAPAUFActorLink@@A ; URender::SurfLights
	add	esp, 4
	test	eax, eax
	je	SHORT $L15211
	push	eax
	call	DWORD PTR __imp_?appFree@@YAXPAX@Z
	add	esp, 4
$L15211:

; 125  : 	if( LeafLights ) appFree(LeafLights);

	mov	eax, DWORD PTR ?LeafLights@URender@@2PAPAUFVolActorLink@@A ; URender::LeafLights
	test	eax, eax
	je	SHORT $L15212
	push	eax
	call	DWORD PTR __imp_?appFree@@YAXPAX@Z
	add	esp, 4
$L15212:

; 126  : 
; 127  : 	GLightManager->Exit();

	mov	ecx, DWORD PTR ?GLightManager@@3PAVFLightManagerBase@@A ; GLightManager
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]

; 128  : 	VectorMem.Exit();

	mov	ecx, OFFSET FLAT:?VectorMem@URender@@2VFMemStack@@A
	call	DWORD PTR __imp_?Exit@FMemStack@@QAEXXZ

; 129  : 
; 130  : 	debugf( NAME_Exit, "Rendering shut down" );

	mov	ecx, DWORD PTR __imp_?GSystem@@3PAVFGlobalPlatform@@A
	push	OFFSET FLAT:$SG15213
	push	763					; 000002fbH
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp_?Logf@FOutputDevice@@QAAXW4EName@@PBDZZ
	add	esp, 12					; 0000000cH

; 131  : 
; 132  : 	URenderBase::Destroy();

	mov	ecx, esi
	call	DWORD PTR __imp_?Destroy@UObject@@UAEXXZ

; 134  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L18898:

; 133  : 	unguard;

	mov	eax, DWORD PTR _Err$15214[ebp]
	lea	ecx, DWORD PTR $T18896[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	ecx
	mov	DWORD PTR $T18896[ebp], eax
	call	__CxxThrowException@8
	mov	eax, $L15208
	ret	0
$L18899:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??Destroy@URender@@UAEXXZ@4PBDB$S15207
	push	OFFSET FLAT:$SG15216
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L15208
	ret	0
$L15208:

; 134  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
$L18903:
	mov	eax, OFFSET FLAT:$T18901
	jmp	___CxxFrameHandler
text$x	ENDS
?Destroy@URender@@UAEXXZ ENDP				; URender::Destroy
PUBLIC	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ	; URender::ShowStat
PUBLIC	?DrawStats@URender@@QAEXPAUFSceneNode@@@Z	; URender::DrawStats
EXTRN	__imp_?GSecondsPerCycle@@3NA:QWORD
EXTRN	__imp_?appSprintf@@YAHPADPBDZZ:NEAR
EXTRN	__ftol:NEAR
EXTRN	__fltused:NEAR
EXTRN	__imp_?Status@FMemCache@@QAEXPAD@Z:NEAR
EXTRN	__imp_?GetStats@ULevel@@QAEXPAD@Z:NEAR
_BSS	SEGMENT
	ALIGN	4

_?CurrentFPS@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4MA$S15229 DD 01H DUP (?)
_?Last64FPS@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4PAMA$S15231 DD 040H DUP (?)
_?Last64Total@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4MA$S15233 DD 01H DUP (?)
_?TotalFPS@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4MA$S15235 DD 01H DUP (?)
_?i@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4JA$S15237 DD 01H DUP (?)
_?Last64Index@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4JA$S15239 DD 01H DUP (?)
_?TotalFPSCount@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4JA$S15241 DD 01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
	ORG $+5
$T18923	DQ	0408f400000000000r		; 1000
$T18924	DD	000000000r			; 0
	ORG $+4
$T18925	DQ	03f90000000000000r		; 0.015625
CONST	ENDS
xdata$x	SEGMENT
$T18920	DD	019930520H
	DD	02H
	DD	FLAT:$T18934
	DD	01H
	DD	FLAT:$T18935
	DD	2 DUP(00H)
	ORG $+4
$T18934	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T18935	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T18936
	ORG $+4
$T18936	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffd0H
	DD	FLAT:$L18909
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L18910
xdata$x	ENDS
_TEXT	SEGMENT
$T18907 = 8
__$EHRec$ = -16
_Frame$ = 8
_FrameTime$15225 = -40
_RenderTime$15226 = -32
_TempStr$15227 = -304
_XL$15243 = -24
_YL$15244 = -44
_StatYL$15251 = -20
_Err$15299 = -48
?DrawStats@URender@@QAEXPAUFSceneNode@@@Z PROC NEAR	; URender::DrawStats

; 143  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L18930
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi

; 144  : 	guard(URender::DrawStats);

	xor	edi, edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp+12], edi

; 146  : 	DWORD FrameTime  = ThisEndTime - LastEndTime;

	xor	eax, eax

; 147  : 	DWORD RenderTime = ThisEndTime - ThisStartTime;

	DB	15					; 0000000fH

; 148  : 	char TempStr[256];

	DB	49					; 00000031H

; 149  : 	static float CurrentFPS,

	xor	edx, edx

; 145  : 	ThisEndTime      = appCycles();

	mov	DWORD PTR -36+[ebp], eax
	mov	DWORD PTR -36+[ebp+4], edi
	fild	QWORD PTR -36+[ebp]
	fst	QWORD PTR [esi+136]

; 146  : 	DWORD FrameTime  = ThisEndTime - LastEndTime;

	fld	ST(0)
	fsub	QWORD PTR [esi+120]
	call	__ftol

; 147  : 	DWORD RenderTime = ThisEndTime - ThisStartTime;

	fsub	QWORD PTR [esi+128]
	mov	ebx, eax
	mov	DWORD PTR _FrameTime$15225[ebp], ebx
	call	__ftol
	mov	edx, eax

; 150  : 				Last64FPS[64],Last64Total,
; 151  : 				TotalFPS;
; 152  : 	static long	i,
; 153  : 				Last64Index,
; 154  : 				TotalFPSCount;
; 155  : 
; 156  : 	if( FpsStats )

	mov	eax, DWORD PTR [esi+152]
	cmp	eax, edi
	mov	DWORD PTR _RenderTime$15226[ebp], edx
	je	$L18926

; 157  : 	{
; 158  : 		INT XL,YL;
; 159  : 
; 160  : 		CurrentFPS=1000.0/(GSecondsPerCycle*1000.0*FrameTime);

	mov	ecx, DWORD PTR __imp_?GSecondsPerCycle@@3NA
	mov	DWORD PTR -28+[ebp], ebx
	mov	DWORD PTR -28+[ebp+4], edi

; 161  : 		Last64FPS[Last64Index]=CurrentFPS;

	mov	eax, DWORD PTR _?Last64Index@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4JA$S15239
	fild	QWORD PTR -28+[ebp]

; 162  : 		Last64Index=(Last64Index+1)&63;

	inc	eax
	fmul	QWORD PTR [ecx]
	fmul	QWORD PTR $T18923
	fdivr	QWORD PTR $T18923
	fst	DWORD PTR _?CurrentFPS@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4MA$S15229
	fstp	DWORD PTR _?Last64FPS@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4PAMA$S15231[eax*4-4]

; 163  : 		Last64Total=0.0;

	fld	DWORD PTR $T18924
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _?Last64Index@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4JA$S15239, eax

; 164  : 		for (i=0 ; i < 64 ; i++) {

	xor	eax, eax
$L18931:
	cmp	eax, 64					; 00000040H
	mov	DWORD PTR _?i@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4JA$S15237, eax
	jge	SHORT $L15247

; 165  : 			Last64Total+=Last64FPS[i];

	fadd	DWORD PTR _?Last64FPS@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4PAMA$S15231[eax*4]
	inc	eax
	jmp	SHORT $L18931
$L15247:

; 166  : 		}
; 167  : 		Last64Total/=64.0;

	fmul	QWORD PTR $T18925

; 168  : 		TotalFPS+=CurrentFPS;
; 169  : 		TotalFPSCount++;

	mov	eax, DWORD PTR _?TotalFPSCount@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4JA$S15241

; 170  : 
; 171  : 		appSprintf
; 172  : 		(
; 173  : 			TempStr,
; 174  : 			"Frame=%05.1f (%05.1f/%05.1f) FPS Render=%05.1f MSEC Nodes=%03i Polys=%03i",
; 175  : 			CurrentFPS,Last64Total,TotalFPS/TotalFPSCount,
; 176  : 			GSecondsPerCycle*1000 * RenderTime,
; 177  : 			NodesDraw,
; 178  : 			PolysDraw
; 179  : 		);

	mov	DWORD PTR -28+[ebp], edx
	mov	DWORD PTR -28+[ebp+4], edi
	inc	eax
	mov	DWORD PTR _?TotalFPSCount@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4JA$S15241, eax
	mov	eax, DWORD PTR [esi+148]
	fstp	DWORD PTR _?Last64Total@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4MA$S15233
	fld	DWORD PTR _?TotalFPS@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4MA$S15235
	fadd	DWORD PTR _?CurrentFPS@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4MA$S15229
	push	eax
	mov	eax, DWORD PTR [esi+144]
	push	eax
	sub	esp, 8
	fstp	DWORD PTR _?TotalFPS@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4MA$S15235
	fild	QWORD PTR -28+[ebp]
	sub	esp, 8
	sub	esp, 8
	fmul	QWORD PTR [ecx]
	sub	esp, 8
	lea	ecx, DWORD PTR _TempStr$15227[ebp]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp+24]
	fild	DWORD PTR _?TotalFPSCount@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4JA$S15241
	fdivr	DWORD PTR _?TotalFPS@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4MA$S15235
	fstp	QWORD PTR [esp+16]
	fld	DWORD PTR _?Last64Total@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4MA$S15233
	fstp	QWORD PTR [esp+8]
	fld	DWORD PTR _?CurrentFPS@?3??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4MA$S15229
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:$SG15248
	push	ecx
	call	DWORD PTR __imp_?appSprintf@@YAHPADPBDZZ

; 180  : 		Frame->Viewport->Canvas->StrLen( Frame->Viewport->Canvas->SmallFont, XL, YL, TempStr );

	mov	edi, DWORD PTR _Frame$[ebp]
	add	esp, 48					; 00000030H
	lea	ecx, DWORD PTR _TempStr$15227[ebp]
	mov	edx, DWORD PTR [edi]
	push	2147483647				; 7fffffffH
	push	0
	push	ecx
	mov	ebx, DWORD PTR [edx+104]
	lea	edx, DWORD PTR _YL$15244[ebp]
	push	edx
	lea	ecx, DWORD PTR _XL$15243[ebp]
	mov	edx, DWORD PTR [ebx+152]
	mov	eax, DWORD PTR [ebx]
	push	ecx
	push	edx
	mov	ecx, ebx
	call	DWORD PTR [eax+108]

; 181  : 		INT Y=Frame->Y;
; 182  : 		Frame->Viewport->Canvas->Printf( Frame->Viewport->Canvas->SmallFont, (Frame->X-XL)/2, Y-YL-2, "%s", TempStr );

	mov	eax, DWORD PTR [edi+180]
	lea	edx, DWORD PTR _TempStr$15227[ebp]
	push	edx
	mov	edx, DWORD PTR _YL$15244[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR _XL$15243[ebp]
	sub	eax, 2
	push	OFFSET FLAT:$SG15250
	push	eax
	mov	eax, DWORD PTR [edi+176]
	sub	eax, edx
	mov	ecx, DWORD PTR [ebx]
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+152]
	sar	eax, 1
	push	eax
	push	edx
	push	ebx
	call	DWORD PTR [ecx+116]
	mov	ebx, DWORD PTR _FrameTime$15225[ebp]
	add	esp, 24					; 00000018H
$L15242:

; 183  : 	}
; 184  : #if STATS
; 185  : 	INT	StatYL=0;
; 186  : 	if( GlobalStats )

	mov	eax, DWORD PTR [esi+156]
	mov	DWORD PTR _StatYL$15251[ebp], 0
	test	eax, eax
	je	$L15252

; 187  : 	{
; 188  : 		ShowStat( Frame, StatYL, "GLOBAL:" );

	lea	eax, DWORD PTR _StatYL$15251[ebp]
	push	OFFSET FLAT:$SG15253
	push	eax
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat

; 189  : 		ShowStat
; 190  : 		(
; 191  : 			Frame,
; 192  : 			StatYL,
; 193  : 			"  FRAME=%04.1f: GAME=%04.1f CLIENT=%04.1f BLIT=%04.1f PLATFM=%04.1f",
; 194  : 			GSecondsPerCycle*1000 * FrameTime,
; 195  : 			GSecondsPerCycle*1000 * Engine->GameCycles,
; 196  : 			GSecondsPerCycle*1000 * (Engine->ClientCycles-Frame->Viewport->Client->DrawCycles),
; 197  : 			GSecondsPerCycle*1000 * Frame->Viewport->Client->DrawCycles,
; 198  : 			GSecondsPerCycle*1000 * Abs((INT)FrameTime - (INT)Engine->TickCycles)
; 199  : 		);

	mov	ecx, DWORD PTR [esi+92]
	mov	eax, ebx
	add	esp, 16					; 00000010H
	sub	eax, DWORD PTR [ecx+108]
	jns	SHORT $L18932
	neg	eax
$L18932:
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR 8+[ebp], eax
	fild	DWORD PTR 8+[ebp]
	mov	eax, DWORD PTR [edx+96]
	sub	esp, 8
	mov	ebx, DWORD PTR [ecx+116]
	sub	esp, 8
	mov	edx, DWORD PTR [eax+108]
	mov	eax, DWORD PTR __imp_?GSecondsPerCycle@@3NA
	mov	DWORD PTR -24+[ebp], edx
	sub	ebx, edx
	fmul	QWORD PTR [eax]
	mov	DWORD PTR 8+[ebp], ebx
	sub	esp, 8
	sub	esp, 8
	xor	ebx, ebx
	fmul	QWORD PTR $T18923
	sub	esp, 8
	lea	edx, DWORD PTR _StatYL$15251[ebp]
	fstp	QWORD PTR [esp+32]
	fild	DWORD PTR -24+[ebp]
	mov	DWORD PTR -28+[ebp+4], ebx
	fmul	QWORD PTR [eax]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp+24]
	fild	DWORD PTR 8+[ebp]
	fmul	QWORD PTR [eax]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp+16]
	fild	DWORD PTR [ecx+112]
	mov	ecx, DWORD PTR _FrameTime$15225[ebp]
	mov	DWORD PTR -28+[ebp], ecx
	fmul	QWORD PTR [eax]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp+8]
	fild	QWORD PTR -28+[ebp]
	fmul	QWORD PTR [eax]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:$SG15259
	push	edx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat

; 200  : 		Frame->Viewport->Actor->XLevel->GetStats( TempStr );

	mov	ecx, DWORD PTR [edi]
	add	esp, 56					; 00000038H
	lea	eax, DWORD PTR _TempStr$15227[ebp]
	mov	edx, DWORD PTR [ecx+92]
	push	eax
	mov	ecx, DWORD PTR [edx+96]
	call	DWORD PTR __imp_?GetStats@ULevel@@QAEXPAD@Z

; 201  : 		ShowStat( Frame, StatYL, "  %s", TempStr );

	lea	eax, DWORD PTR _TempStr$15227[ebp]
	lea	ecx, DWORD PTR _StatYL$15251[ebp]
	push	eax
	push	OFFSET FLAT:$SG15260
	push	ecx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat

; 202  : 		ShowStat
; 203  : 		(
; 204  : 			Frame,
; 205  : 			StatYL,
; 206  : 			"  RENDER=%04.1f MESH=%04.1f POLYV=%04.1f ILLUM=%04.1f OCC=%04.1f FILT=%04.1f EX=%04.1f",
; 207  : 			GSecondsPerCycle*1000 * RenderTime,
; 208  : 			GSecondsPerCycle*1000 * GStat.MeshTime,
; 209  : 			GSecondsPerCycle*1000 * GStat.PolyVTime,
; 210  : 			GSecondsPerCycle*1000 * GStat.IllumTime,
; 211  : 			GSecondsPerCycle*1000 * GStat.OcclusionTime,
; 212  : 			GSecondsPerCycle*1000 * GStat.FilterTime,
; 213  : 			GSecondsPerCycle*1000 * GStat.ExtraTime
; 214  : 		);

	fild	DWORD PTR ?GStat@@3UFRenderStats@@A
	mov	eax, DWORD PTR __imp_?GSecondsPerCycle@@3NA
	add	esp, 20					; 00000014H
	sub	esp, 8
	fmul	QWORD PTR [eax]
	sub	esp, 8
	sub	esp, 8
	fmul	QWORD PTR $T18923
	sub	esp, 8
	fstp	QWORD PTR [esp+24]
	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+60
	fmul	QWORD PTR [eax]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp+16]
	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+64
	fmul	QWORD PTR [eax]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp+8]
	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+132
	fmul	QWORD PTR [eax]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp]
	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+136
	sub	esp, 8
	mov	edx, DWORD PTR _RenderTime$15226[ebp]
	sub	esp, 8
	mov	DWORD PTR -36+[ebp], edx
	fmul	QWORD PTR [eax]
	mov	DWORD PTR -36+[ebp+4], ebx
	sub	esp, 8
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp+16]
	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+4
	fmul	QWORD PTR [eax]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp+8]
	fild	QWORD PTR -36+[ebp]
	fmul	QWORD PTR [eax]
	lea	eax, DWORD PTR _StatYL$15251[ebp]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:$SG15261
	push	eax
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat
	add	esp, 72					; 00000048H

; 215  : 		ShowStat( Frame, StatYL, "" );

	lea	ecx, DWORD PTR _StatYL$15251[ebp]
	push	OFFSET FLAT:$SG15262
	push	ecx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat
	add	esp, 16					; 00000010H
$L15252:

; 216  : 	}
; 217  : 	if( HardwareStats )

	mov	eax, DWORD PTR [esi+216]
	test	eax, eax
	je	SHORT $L15263

; 218  : 	{
; 219  : 		ShowStat( Frame, StatYL, "HARDWARE:" );

	lea	edx, DWORD PTR _StatYL$15251[ebp]
	push	OFFSET FLAT:$SG15264
	push	edx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat

; 220  : 		Frame->Viewport->RenDev->GetStats( TempStr );

	mov	eax, DWORD PTR [edi]
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR [eax+112]
	lea	eax, DWORD PTR _TempStr$15227[ebp]
	push	eax
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+156]

; 221  : 		ShowStat( Frame, StatYL, "  %s", TempStr );

	lea	ecx, DWORD PTR _TempStr$15227[ebp]
	lea	edx, DWORD PTR _StatYL$15251[ebp]
	push	ecx
	push	OFFSET FLAT:$SG15265
	push	edx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat
	add	esp, 20					; 00000014H

; 222  : 		ShowStat( Frame, StatYL, "" );

	lea	eax, DWORD PTR _StatYL$15251[ebp]
	push	OFFSET FLAT:$SG15266
	push	eax
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat
	add	esp, 16					; 00000010H
$L15263:

; 223  : 	}
; 224  : 	if( PolyVStats )
; 225  : 	{
; 226  : 	}
; 227  : 	if( PolyCStats )
; 228  : 	{
; 229  : 	}
; 230  : 	if( IllumStats )
; 231  : 	{
; 232  : 	}
; 233  : 	if( MeshStats )

	mov	eax, DWORD PTR [esi+160]
	test	eax, eax
	je	$L15270

; 234  : 	{
; 235  : 		ShowStat( Frame, StatYL, "MESH: %04.1f", GSecondsPerCycle*1000 * GStat.MeshTime );

	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+4
	mov	ecx, DWORD PTR __imp_?GSecondsPerCycle@@3NA
	sub	esp, 8
	lea	edx, DWORD PTR _StatYL$15251[ebp]
	fmul	QWORD PTR [ecx]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:$SG15271
	push	edx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat

; 236  : 		ShowStat
; 237  : 		(
; 238  : 			Frame,
; 239  : 			StatYL,
; 240  : 			"  GetFrame=%04.1f Process=%04.1f LightSet=%04.1f Light=%04.1f",
; 241  : 			GSecondsPerCycle*1000 * GStat.MeshGetFrameTime,
; 242  : 			GSecondsPerCycle*1000 * GStat.MeshProcessTime,
; 243  : 			GSecondsPerCycle*1000 * GStat.MeshLightSetupTime,
; 244  : 			GSecondsPerCycle*1000 * GStat.MeshLightTime
; 245  : 		);

	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+20
	mov	eax, DWORD PTR __imp_?GSecondsPerCycle@@3NA
	add	esp, 24					; 00000018H
	sub	esp, 8
	fmul	QWORD PTR [eax]
	sub	esp, 8
	sub	esp, 8
	fmul	QWORD PTR $T18923
	sub	esp, 8
	fstp	QWORD PTR [esp+24]
	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+16
	fmul	QWORD PTR [eax]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp+16]
	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+12
	fmul	QWORD PTR [eax]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp+8]
	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+8
	fmul	QWORD PTR [eax]
	lea	eax, DWORD PTR _StatYL$15251[ebp]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:$SG15272
	push	eax
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat

; 246  : 		ShowStat
; 247  : 		(
; 248  : 			Frame,
; 249  : 			StatYL,
; 250  : 			"  Sub=%04.1f Clip=%04.1f Tmap=%04.1f",
; 251  : 			GSecondsPerCycle*1000 * GStat.MeshSubTime,
; 252  : 			GSecondsPerCycle*1000 * GStat.MeshClipTime,
; 253  : 			GSecondsPerCycle*1000 * GStat.MeshTmapTime
; 254  : 		);

	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+32
	mov	eax, DWORD PTR __imp_?GSecondsPerCycle@@3NA
	add	esp, 48					; 00000030H
	sub	esp, 8
	lea	ecx, DWORD PTR _StatYL$15251[ebp]
	fmul	QWORD PTR [eax]
	sub	esp, 8
	sub	esp, 8
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp+16]
	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+28
	fmul	QWORD PTR [eax]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp+8]
	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+24
	fmul	QWORD PTR [eax]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:$SG15273
	push	ecx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat

; 255  : 		ShowStat
; 256  : 		(
; 257  : 			Frame,
; 258  : 			StatYL,
; 259  : 			"  MeshCount=%i MeshPolyCount=%i MeshSubCount=%i MeshLights=%i MeshVtrics=%i VertLights=%i",
; 260  : 			GStat.MeshCount,
; 261  : 			GStat.MeshPolyCount,
; 262  : 			GStat.MeshSubCount,
; 263  : 			GStat.MeshLightCount,
; 264  : 			GStat.MeshVtricCount,
; 265  : 			GStat.MeshVertLightCount
; 266  : 		);

	mov	edx, DWORD PTR ?GStat@@3UFRenderStats@@A+48
	mov	eax, DWORD PTR ?GStat@@3UFRenderStats@@A+56
	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+52
	add	esp, 40					; 00000028H
	push	edx
	mov	edx, DWORD PTR ?GStat@@3UFRenderStats@@A+44
	push	eax
	mov	eax, DWORD PTR ?GStat@@3UFRenderStats@@A+40
	push	ecx
	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+36
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR _StatYL$15251[ebp]
	push	OFFSET FLAT:$SG15274
	push	edx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat
	add	esp, 40					; 00000028H

; 267  : 		ShowStat( Frame, StatYL, "" );

	lea	eax, DWORD PTR _StatYL$15251[ebp]
	push	OFFSET FLAT:$SG15275
	push	eax
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat
	add	esp, 16					; 00000010H
$L15270:

; 268  : 	}
; 269  : 	if( ActorStats )
; 270  : 	{
; 271  : 	}
; 272  : 	if( FilterStats )
; 273  : 	{
; 274  : 	}
; 275  : 	if( RejectStats )
; 276  : 	{
; 277  : 	}
; 278  : 	if( SpanStats )
; 279  : 	{
; 280  : 	}
; 281  : 	if( ZoneStats )

	mov	eax, DWORD PTR [esi+180]
	test	eax, eax
	je	SHORT $L15280

; 282  : 	{
; 283  : 		ShowStat
; 284  : 		(
; 285  : 			Frame,
; 286  : 			StatYL,
; 287  : 			"Zones: Visible=%i/%i Reject=%i",
; 288  : 			GStat.VisibleZones,
; 289  : 			GStat.NumZones,
; 290  : 			GStat.MaskRejectZones
; 291  : 		);

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+204
	mov	edx, DWORD PTR ?GStat@@3UFRenderStats@@A+196
	mov	eax, DWORD PTR ?GStat@@3UFRenderStats@@A+200
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _StatYL$15251[ebp]
	push	OFFSET FLAT:$SG15281
	push	ecx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat
	add	esp, 28					; 0000001cH

; 292  : 		ShowStat( Frame, StatYL, "" );

	lea	edx, DWORD PTR _StatYL$15251[ebp]
	push	OFFSET FLAT:$SG15282
	push	edx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat
	add	esp, 16					; 00000010H
$L15280:

; 293  : 	}
; 294  : 	if( LightStats )
; 295  : 	{
; 296  : 	}
; 297  : 	if( OcclusionStats )

	mov	eax, DWORD PTR [esi+188]
	test	eax, eax
	je	$L15284

; 298  : 	{
; 299  : 		ShowStat
; 300  : 		(
; 301  : 			Frame,
; 302  : 			StatYL,
; 303  : 			"Occlusion=%04.1f:",
; 304  : 			GSecondsPerCycle*1000 * GStat.OcclusionTime
; 305  : 		);

	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+64
	mov	eax, DWORD PTR __imp_?GSecondsPerCycle@@3NA
	sub	esp, 8
	lea	ecx, DWORD PTR _StatYL$15251[ebp]
	fmul	QWORD PTR [eax]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:$SG15285
	push	ecx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat

; 306  : 		ShowStat
; 307  : 		(
; 308  : 			Frame,
; 309  : 			StatYL,
; 310  : 			"   Clip=%04.1f Raster=%04.1f Span=%04.1f Visit=%i/%i Points=%i",
; 311  : 			GSecondsPerCycle*1000 * GStat.ClipTime,
; 312  : 			GSecondsPerCycle*1000 * GStat.RasterTime,
; 313  : 			GSecondsPerCycle*1000 * GStat.SpanTime,
; 314  : 			GStat.NodesDone,
; 315  : 			GStat.NodesTotal,
; 316  : 			GStat.NumPoints
; 317  : 		);

	mov	edx, DWORD PTR ?GStat@@3UFRenderStats@@A+128
	mov	eax, DWORD PTR ?GStat@@3UFRenderStats@@A+84
	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+76
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+80
	push	edx
	push	eax
	mov	eax, DWORD PTR __imp_?GSecondsPerCycle@@3NA
	push	ecx
	sub	esp, 8
	lea	edx, DWORD PTR _StatYL$15251[ebp]
	fmul	QWORD PTR [eax]
	sub	esp, 8
	sub	esp, 8
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp+16]
	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+72
	fmul	QWORD PTR [eax]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp+8]
	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+68
	fmul	QWORD PTR [eax]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:$SG15286
	push	edx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat

; 318  : 		ShowStat
; 319  : 		(
; 320  : 			Frame,
; 321  : 			StatYL,
; 322  : 			"   Transform=%i Clip=%i Raster=%i RasterAccept=%i DrawNodes=%i",
; 323  : 			GStat.NumTransform,
; 324  : 			GStat.NumClip,
; 325  : 			GStat.NumRasterPolys+GStat.NumRasterBoxReject,
; 326  : 			GStat.NumRasterPolys,
; 327  : 			NodesDraw
; 328  : 		);

	mov	eax, DWORD PTR [esi+144]
	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+92
	add	esp, 52					; 00000034H
	mov	edx, DWORD PTR ?GStat@@3UFRenderStats@@A+100
	push	eax
	mov	eax, DWORD PTR ?GStat@@3UFRenderStats@@A+88
	push	eax
	add	eax, ecx
	push	eax
	mov	eax, DWORD PTR ?GStat@@3UFRenderStats@@A+96
	push	edx
	push	eax
	lea	ecx, DWORD PTR _StatYL$15251[ebp]
	push	OFFSET FLAT:$SG15287
	push	ecx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat

; 329  : 		ShowStat
; 330  : 		(
; 331  : 			Frame,
; 332  : 			StatYL,
; 333  : 			"   BoxTime=%04.1f BoxChecks=%i BoxBacks=%i BoxIn=%i BoxOutPyr=%i BoxSpanOcc=%i",
; 334  : 			GSecondsPerCycle*1000 * GStat.BoxTime,
; 335  : 			GStat.BoxChecks,
; 336  : 			GStat.BoxBacks,
; 337  : 			GStat.BoxIn,
; 338  : 			GStat.BoxOutOfPyramid,
; 339  : 			GStat.BoxSpanOccluded
; 340  : 		);

	mov	edx, DWORD PTR ?GStat@@3UFRenderStats@@A+124
	mov	eax, DWORD PTR ?GStat@@3UFRenderStats@@A+120
	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+116
	add	esp, 36					; 00000024H
	fild	DWORD PTR ?GStat@@3UFRenderStats@@A+104
	push	edx
	mov	edx, DWORD PTR ?GStat@@3UFRenderStats@@A+112
	push	eax
	mov	eax, DWORD PTR ?GStat@@3UFRenderStats@@A+108
	push	ecx
	mov	ecx, DWORD PTR __imp_?GSecondsPerCycle@@3NA
	push	edx
	push	eax
	fmul	QWORD PTR [ecx]
	sub	esp, 8
	lea	edx, DWORD PTR _StatYL$15251[ebp]
	fmul	QWORD PTR $T18923
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:$SG15288
	push	edx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat
	add	esp, 44					; 0000002cH

; 341  : 		ShowStat( Frame, StatYL, "" );

	lea	eax, DWORD PTR _StatYL$15251[ebp]
	push	OFFSET FLAT:$SG15289
	push	eax
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat
	add	esp, 16					; 00000010H
$L15284:

; 342  : 	}
; 343  : 	if( GameStats )

	mov	eax, DWORD PTR [esi+192]
	test	eax, eax
	je	SHORT $L15290

; 344  : 	{
; 345  : 		ShowStat( Frame, StatYL, "GAME:" );

	lea	ecx, DWORD PTR _StatYL$15251[ebp]
	push	OFFSET FLAT:$SG15291
	push	ecx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat

; 346  : 		Frame->Viewport->Actor->XLevel->GetStats( TempStr );

	mov	eax, DWORD PTR [edi]
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR _TempStr$15227[ebp]
	mov	ecx, DWORD PTR [eax+92]
	push	edx
	mov	ecx, DWORD PTR [ecx+96]
	call	DWORD PTR __imp_?GetStats@ULevel@@QAEXPAD@Z

; 347  : 		ShowStat( Frame, StatYL, "   %s", TempStr );

	lea	edx, DWORD PTR _TempStr$15227[ebp]
	lea	eax, DWORD PTR _StatYL$15251[ebp]
	push	edx
	push	OFFSET FLAT:$SG15292
	push	eax
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat
	add	esp, 20					; 00000014H

; 348  : 		ShowStat( Frame, StatYL, "" );

	lea	ecx, DWORD PTR _StatYL$15251[ebp]
	push	OFFSET FLAT:$SG15293
	push	ecx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat
	add	esp, 16					; 00000010H
$L15290:

; 349  : 	}
; 350  : 	if( SoftStats )
; 351  : 	{
; 352  : 	}
; 353  : 	if( CacheStats )

	mov	eax, DWORD PTR [esi+200]
	test	eax, eax
	je	$L15295

; 354  : 	{
; 355  : 		ShowStat( Frame, StatYL, "CACHE:" );

	lea	edx, DWORD PTR _StatYL$15251[ebp]
	push	OFFSET FLAT:$SG15296
	push	edx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat

; 356  : 		GCache.Status( TempStr );

	mov	ecx, DWORD PTR __imp_?GCache@@3VFMemCache@@A
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR _TempStr$15227[ebp]
	push	eax
	call	DWORD PTR __imp_?Status@FMemCache@@QAEXPAD@Z

; 357  : 		ShowStat( Frame, StatYL, "   %s", TempStr );

	lea	ecx, DWORD PTR _TempStr$15227[ebp]
	lea	edx, DWORD PTR _StatYL$15251[ebp]
	push	ecx
	push	OFFSET FLAT:$SG15297
	push	edx
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat
	add	esp, 20					; 00000014H

; 358  : 		ShowStat( Frame, StatYL, "" );

	lea	eax, DWORD PTR _StatYL$15251[ebp]
	push	OFFSET FLAT:$SG15298
	push	eax
	push	edi
	push	esi
	call	?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ; URender::ShowStat
	add	esp, 16					; 00000010H

; 362  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L18909:

; 359  : 	}
; 360  : #endif // STATS
; 361  : 	unguard;

	mov	ecx, DWORD PTR _Err$15299[ebp]
	lea	edx, DWORD PTR $T18907[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	edx
	mov	DWORD PTR $T18907[ebp], ecx
	call	__CxxThrowException@8
	mov	eax, $L15295
	ret	0
$L18910:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??DrawStats@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S15223
	push	OFFSET FLAT:$SG15301
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L15295
	ret	0
$L15295:

; 362  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L18926:

; 181  : 		INT Y=Frame->Y;
; 182  : 		Frame->Viewport->Canvas->Printf( Frame->Viewport->Canvas->SmallFont, (Frame->X-XL)/2, Y-YL-2, "%s", TempStr );

	mov	edi, DWORD PTR _Frame$[ebp]
	jmp	$L15242
_TEXT	ENDS
text$x	SEGMENT
$L18930:
	mov	eax, OFFSET FLAT:$T18920
	jmp	___CxxFrameHandler
text$x	ENDS
?DrawStats@URender@@QAEXPAUFSceneNode@@@Z ENDP		; URender::DrawStats
PUBLIC	??_C@_02DILL@?$CFs?$AA@				; `string'
PUBLIC	?__FUNC_NAME__@?2???2@YAPAXI@Z@4PBDB		; __FUNC_NAME__
PUBLIC	??_C@_03IDPP@new?$AA@				; `string'
EXTRN	__imp_?appMalloc@@YAPAXHPBD@Z:NEAR
;	COMDAT ?__FUNC_NAME__@?2???2@YAPAXI@Z@4PBDB
; File ..\..\Core\Inc\UnFile.h
CONST	SEGMENT
?__FUNC_NAME__@?2???2@YAPAXI@Z@4PBDB DB '"operator new"', 00H ; __FUNC_NAME__
CONST	ENDS
;	COMDAT ??_C@_02DILL@?$CFs?$AA@
_DATA	SEGMENT
??_C@_02DILL@?$CFs?$AA@ DB '%s', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03IDPP@new?$AA@
_DATA	SEGMENT
??_C@_03IDPP@new?$AA@ DB 'new', 00H			; `string'
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T18942	DD	019930520H
	DD	02H
	DD	FLAT:$T18944
	DD	01H
	DD	FLAT:$T18945
	DD	2 DUP(00H)
	ORG $+4
$T18944	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T18945	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T18946
	ORG $+4
$T18946	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffecH
	DD	FLAT:$L18939
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L18940
xdata$x	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
$T18937 = 8
__$EHRec$ = -16
_Size$ = 8
_Err$628 = -20
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 363  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L18943
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ecx

; 364  : 	guard( "operator new" );
; 365  : 	return appMalloc( Size, "new" );

	mov	eax, DWORD PTR _Size$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	OFFSET FLAT:??_C@_03IDPP@new?$AA@	; `string'
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	DWORD PTR __imp_?appMalloc@@YAPAXHPBD@Z
	add	esp, 8

; 367  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L18939:

; 366  : 	unguard;

	mov	ecx, DWORD PTR _Err$628[ebp]
	lea	edx, DWORD PTR $T18937[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	edx
	mov	DWORD PTR $T18937[ebp], ecx
	call	__CxxThrowException@8
	mov	eax, $L626
	ret	0
$L18940:
	push	OFFSET FLAT:?__FUNC_NAME__@?2???2@YAPAXI@Z@4PBDB ; __FUNC_NAME__
	push	OFFSET FLAT:??_C@_02DILL@?$CFs?$AA@	; `string'
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L626
	ret	0
$L626:

; 367  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L18943:
	mov	eax, OFFSET FLAT:$T18942
	jmp	___CxxFrameHandler
text$x	ENDS
??2@YAPAXI@Z ENDP					; operator new
PUBLIC	?__FUNC_NAME__@?2???3@YAXPAX@Z@4PBDB		; __FUNC_NAME__
;	COMDAT ?__FUNC_NAME__@?2???3@YAXPAX@Z@4PBDB
; File ..\..\Core\Inc\UnFile.h
CONST	SEGMENT
?__FUNC_NAME__@?2???3@YAXPAX@Z@4PBDB DB '"operator delete"', 00H ; __FUNC_NAME__
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T18954	DD	019930520H
	DD	02H
	DD	FLAT:$T18956
	DD	01H
	DD	FLAT:$T18957
	DD	2 DUP(00H)
	ORG $+4
$T18956	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T18957	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T18958
	ORG $+4
$T18958	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffecH
	DD	FLAT:$L18951
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L18952
xdata$x	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
$T18949 = 8
__$EHRec$ = -16
_Ptr$ = 8
_Err$635 = -20
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 369  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L18955
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ecx

; 370  : 	guard( "operator delete" );
; 371  : 	appFree( Ptr );

	mov	eax, DWORD PTR _Ptr$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	DWORD PTR __imp_?appFree@@YAXPAX@Z
	add	esp, 4

; 373  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L18951:

; 372  : 	unguard;

	mov	ecx, DWORD PTR _Err$635[ebp]
	lea	edx, DWORD PTR $T18949[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	edx
	mov	DWORD PTR $T18949[ebp], ecx
	call	__CxxThrowException@8
	mov	eax, $L634
	ret	0
$L18952:
	push	OFFSET FLAT:?__FUNC_NAME__@?2???3@YAXPAX@Z@4PBDB ; __FUNC_NAME__
	push	OFFSET FLAT:??_C@_02DILL@?$CFs?$AA@	; `string'
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L634
	ret	0
$L634:

; 373  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L18955:
	mov	eax, OFFSET FLAT:$T18954
	jmp	___CxxFrameHandler
text$x	ENDS
??3@YAXPAX@Z ENDP					; operator delete
EXTRN	__imp_?appGetVarArgs@@YAHPADAAPBD@Z:NEAR
EXTRN	__chkstk:NEAR
xdata$x	SEGMENT
$T18966	DD	019930520H
	DD	02H
	DD	FLAT:$T18969
	DD	01H
	DD	FLAT:$T18970
	DD	2 DUP(00H)
	ORG $+4
$T18969	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T18970	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T18971
	ORG $+4
$T18971	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffecH
	DD	FLAT:$L18963
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L18964
xdata$x	ENDS
_TEXT	SEGMENT
$T18961 = 12
__$EHRec$ = -16
_Frame$ = 12
_StatYL$ = 16
_Fmt$ = 20
_TempStr$ = -4116
_XL$15311 = 16
_YL$15312 = 12
_Err$15315 = -20
?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ PROC NEAR ; URender::ShowStat

; 368  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L18967
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	eax, 4100				; 00001004H
	call	__chkstk
	push	ebx
	push	esi
	push	edi

; 369  : 	char TempStr[4096];
; 370  : 	GET_VARARGS(TempStr,Fmt);

	lea	eax, DWORD PTR _Fmt$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	lea	ecx, DWORD PTR _TempStr$[ebp]
	push	eax
	push	ecx
	call	DWORD PTR __imp_?appGetVarArgs@@YAHPADAAPBD@Z

; 371  : 
; 372  : 	guard(URender::ShowStat);
; 373  : 	INT XL, YL;
; 374  : 	Frame->Viewport->Canvas->Printf( Frame->Viewport->Canvas->SmallFont, 8, STAT_Y + StatYL, "%s", TempStr );

	mov	edx, DWORD PTR _Frame$[ebp]
	mov	ebx, DWORD PTR _StatYL$[ebp]
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR [edx]
	mov	edi, DWORD PTR [ebx]
	lea	edx, DWORD PTR _TempStr$[ebp]
	mov	esi, DWORD PTR [eax+104]
	push	edx
	lea	eax, DWORD PTR [edi+16]
	push	OFFSET FLAT:$SG15313
	mov	edx, DWORD PTR [esi+152]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	8
	push	edx
	push	esi
	call	DWORD PTR [ecx+116]
	add	esp, 24					; 00000018H

; 375  :     Frame->Viewport->Canvas->StrLen( Frame->Viewport->Canvas->SmallFont, XL, YL, " " );

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _YL$15312[ebp]
	lea	edx, DWORD PTR _XL$15311[ebp]
	push	2147483647				; 7fffffffH
	push	0
	push	OFFSET FLAT:$SG15314
	push	ecx
	mov	ecx, DWORD PTR [esi+152]
	push	edx
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+108]

; 376  : 	StatYL += YL;

	mov	edx, DWORD PTR _YL$15312[ebp]
	add	edx, edi
	mov	DWORD PTR [ebx], edx

; 378  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L18963:

; 377  : 	unguard;

	mov	eax, DWORD PTR _Err$15315[ebp]
	lea	ecx, DWORD PTR $T18961[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	ecx
	mov	DWORD PTR $T18961[ebp], eax
	call	__CxxThrowException@8
	mov	eax, $L15310
	ret	0
$L18964:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ@4PBDB$S15309
	push	OFFSET FLAT:$SG15317
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L15310
	ret	0
$L15310:

; 378  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
$L18967:
	mov	eax, OFFSET FLAT:$T18966
	jmp	___CxxFrameHandler
text$x	ENDS
?ShowStat@URender@@QAAXPAUFSceneNode@@AAHPBDZZ ENDP	; URender::ShowStat
_TEXT	SEGMENT
_$E111	PROC NEAR
	ret	0
_$E111	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EF@LODM@Check?5failed?3?5Actors?$CI0?$CJ?5?$FLFile?3?4?4@ ; `string'
PUBLIC	??_C@_0GD@NDIK@Check?5failed?3?5Actors?$CI0?$CJ?9?$DOIsA?$CIALe@ ; `string'
EXTRN	__imp_?GMem@@3VFMemStack@@A:BYTE
EXTRN	__imp_?appEnableFastMath@@YAXH@Z:NEAR
EXTRN	__imp_?StaticClass@ALevelInfo@@2PAVUClass@@A:DWORD
EXTRN	?GRandoms@@3PAVFGlobalRandomsBase@@A:DWORD	; GRandoms
_BSS	SEGMENT
_Mark$S15318 DB	010H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0EF@LODM@Check?5failed?3?5Actors?$CI0?$CJ?5?$FLFile?3?4?4@
; File ..\..\Core\Inc\UnMem.h
_DATA	SEGMENT
??_C@_0EF@LODM@Check?5failed?3?5Actors?$CI0?$CJ?5?$FLFile?3?4?4@ DB 'Chec'
	DB	'k failed: Actors(0) [File:..\..\Engine\Inc\UnLevel.h] [Line: '
	DB	'%i]', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0GD@NDIK@Check?5failed?3?5Actors?$CI0?$CJ?9?$DOIsA?$CIALe@
_DATA	SEGMENT
??_C@_0GD@NDIK@Check?5failed?3?5Actors?$CI0?$CJ?9?$DOIsA?$CIALe@ DB 'Chec'
	DB	'k failed: Actors(0)->IsA(ALevelInfo::StaticClass) [File:..\..'
	DB	'\Engine\Inc\UnLevel.h] [Line: %i]', 00H	; `string'
_DATA	ENDS
xdata$x	SEGMENT
$T19038	DD	019930520H
	DD	02H
	DD	FLAT:$T19043
	DD	01H
	DD	FLAT:$T19044
	DD	2 DUP(00H)
	ORG $+4
$T19043	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T19044	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T19045
	ORG $+4
$T19045	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffecH
	DD	FLAT:$L18977
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L18978
xdata$x	ENDS
_TEXT	SEGMENT
$T18975 = 8
$T19031 = 8
__$EHRec$ = -16
_Frame$ = 8
_Err$15330 = -20
?PreRender@URender@@UAEXPAUFSceneNode@@@Z PROC NEAR	; URender::PreRender

; 389  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L19042
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp

; 393  : 	appEnableFastMath(1);

	push	1
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	DWORD PTR __imp_?appEnableFastMath@@YAXH@Z

; 396  : 	GRandoms->Tick( Frame->Viewport->Actor->XLevel->GetLevelInfo()->TimeSeconds );

	mov	eax, DWORD PTR _Frame$[ebp]
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T19031[ebp], eax
	mov	edi, DWORD PTR [eax+88]
	cmp	DWORD PTR [edi], 0
	jne	SHORT $L19029
	push	223					; 000000dfH
	push	OFFSET FLAT:??_C@_0EF@LODM@Check?5failed?3?5Actors?$CI0?$CJ?5?$FLFile?3?4?4@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L19029:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR __imp_?StaticClass@ALevelInfo@@2PAVUClass@@A
	mov	eax, DWORD PTR [eax+12]
$L19024:
	test	eax, eax
	je	SHORT $L19021
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $L19030
	mov	eax, DWORD PTR [eax+96]
	jmp	SHORT $L19024
$L19021:
	push	224					; 000000e0H
	push	OFFSET FLAT:??_C@_0GD@NDIK@Check?5failed?3?5Actors?$CI0?$CJ?9?$DOIsA?$CIALe@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L19030:
	mov	eax, DWORD PTR $T19031[ebp]
	mov	ecx, DWORD PTR ?GRandoms@@3PAVFGlobalRandomsBase@@A ; GRandoms
	mov	eax, DWORD PTR [eax+88]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+640]
	push	eax
	call	DWORD PTR [edx+8]

; 397  : 
; 398  : 	// Init stats.
; 399  : 	STAT(appMemset(&GStat,0,sizeof(GStat)));

	push	320					; 00000140H
	push	0
	push	OFFSET FLAT:?GStat@@3UFRenderStats@@A	; GStat
	call	DWORD PTR __imp_?appMemset@@YAPAXPAXHH@Z

; 400  : 	LastEndTime   = ThisEndTime;

	mov	ecx, DWORD PTR [esi+136]
	mov	edx, DWORD PTR [esi+140]
	mov	DWORD PTR [esi+120], ecx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+124], edx

; 390  : 	guard(URender::PreRender);
; 391  : 
; 392  : 	// Set math to low precision.

	xor	eax, eax

; 393  : 	appEnableFastMath(1);

	DB	15					; 0000000fH

; 394  : 

	DB	49					; 00000031H

; 395  : 	// Tick stuff.

	xor	edx, edx

; 401  : 	ThisStartTime = appCycles();

	mov	DWORD PTR -24+[ebp], eax

; 402  : 
; 403  : 	// Init counts.
; 404  : 	NodesDraw		= 0;
; 405  : 	PolysDraw		= 0;
; 406  : 
; 407  : 	// Bump the iteration count.
; 408  : 	Mark.Push(GMem);

	mov	eax, DWORD PTR __imp_?GMem@@3VFMemStack@@A
	mov	DWORD PTR -24+[ebp+4], 0
	mov	DWORD PTR [esi+144], 0
	fild	QWORD PTR -24+[ebp]
	mov	DWORD PTR [esi+148], 0
	mov	DWORD PTR _Mark$S15318, eax
	fstp	QWORD PTR [esi+128]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _Mark$S15318+4, ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _Mark$S15318+8, edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _Mark$S15318+12, eax

; 411  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L18977:

; 409  : 
; 410  : 	unguard;

	mov	ecx, DWORD PTR _Err$15330[ebp]
	lea	edx, DWORD PTR $T18975[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	edx
	mov	DWORD PTR $T18975[ebp], ecx
	call	__CxxThrowException@8
	mov	eax, $L15329
	ret	0
$L18978:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??PreRender@URender@@UAEXPAUFSceneNode@@@Z@4PBDB$S15328
	push	OFFSET FLAT:$SG15332
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L15329
	ret	0
$L15329:

; 411  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
$L19042:
	mov	eax, OFFSET FLAT:$T19038
	jmp	___CxxFrameHandler
text$x	ENDS
?PreRender@URender@@UAEXPAUFSceneNode@@@Z ENDP		; URender::PreRender
EXTRN	__imp_??0FPlane@@QAE@ABVFVector@@@Z:NEAR
CONST	SEGMENT
$T19072	DD	03f800000r			; 1
CONST	ENDS
xdata$x	SEGMENT
$T19070	DD	019930520H
	DD	02H
	DD	FLAT:$T19077
	DD	01H
	DD	FLAT:$T19078
	DD	2 DUP(00H)
	ORG $+4
$T19077	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T19078	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T19079
	ORG $+4
$T19079	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffe0H
	DD	FLAT:$L19052
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L19053
xdata$x	ENDS
_TEXT	SEGMENT
$T19048 = -60
$T19049 = -28
$T19050 = 8
__$EHRec$ = -16
_Frame$ = 8
_this$ = -24
_FlashScale$15339 = -56
_FlashFog$15340 = -44
_Err$15351 = -32
?PostRender@URender@@UAEXPAUFSceneNode@@@Z PROC NEAR	; URender::PostRender

; 417  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L19076
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 44					; 0000002cH
	push	ebx

; 418  : 	guard(URender::PostRender);
; 419  : 
; 420  : 	// Hardware screenflash assist.
; 421  : 	FVector FlashScale = Frame->Viewport->Actor->FlashScale;

	mov	ebx, DWORD PTR _Frame$[ebp]
	push	esi
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, DWORD PTR [ebx]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR [esi+92]
	lea	ecx, DWORD PTR [eax+1056]

; 422  : 	FVector FlashFog   = Frame->Viewport->Actor->FlashFog;

	add	eax, 1068				; 0000042cH
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _FlashScale$15339[ebp], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _FlashScale$15339[ebp+4], edx
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _FlashFog$15340[ebp], edx
	mov	DWORD PTR _FlashScale$15339[ebp+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _FlashFog$15340[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _FlashFog$15340[ebp+8], edx

; 423  : 	check(Frame->Viewport->Actor->FlashTexture);

	mov	eax, DWORD PTR [esi+92]
	mov	edi, DWORD PTR [eax+1080]
	test	edi, edi
	jne	SHORT $L15341
	push	423					; 000001a7H
	push	OFFSET FLAT:$SG15342
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L15341:

; 424  : 	if
; 425  : 	(	Frame->Viewport->RenDev->ScreenFlashAssist
; 426  : 	&&	Frame->Viewport->Actor->FlashTexture
; 427  : 	&&	(FlashScale!=FVector(1,1,1) || FlashFog!=FVector(0,0,0)) )

	mov	ecx, DWORD PTR [esi+112]
	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	je	$L15345
	test	edi, edi
	je	$L15345
	fld	DWORD PTR _FlashScale$15339[ebp]
	fcomp	DWORD PTR $T19072
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L19064
	fld	DWORD PTR _FlashScale$15339[ebp+4]
	fcomp	DWORD PTR $T19072
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L19064
	fld	DWORD PTR _FlashScale$15339[ebp+8]
	fcomp	DWORD PTR $T19072
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L19064
	fld	DWORD PTR _FlashFog$15340[ebp]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L19064
	fld	DWORD PTR _FlashFog$15340[ebp+4]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L19064
	fld	DWORD PTR _FlashFog$15340[ebp+8]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L15345
$L19064:

; 428  : 	{
; 429  : 		Frame->FX = Frame->X;

	fild	DWORD PTR [ebx+176]

; 430  : 		Frame->FY = Frame->Y;
; 431  : 		Frame->Viewport->Canvas->DrawIcon( Frame->Viewport->Actor->FlashTexture, 0, 0, Frame->X, Frame->Y, NULL, 2.0, FlashFog, FPlane(0,0,0,0), PF_Translucent );

	push	4
	mov	DWORD PTR $T19048[ebp], 0
	mov	eax, DWORD PTR $T19048[ebp]
	sub	esp, 16					; 00000010H
	fst	DWORD PTR -20+[ebp]
	mov	edx, esp
	mov	DWORD PTR $T19048[ebp+4], 0
	mov	ecx, DWORD PTR $T19048[ebp+4]
	mov	DWORD PTR $T19048[ebp+8], 0
	fstp	DWORD PTR [ebx+192]
	fild	DWORD PTR [ebx+180]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR $T19048[ebp+8]
	mov	DWORD PTR $T19048[ebp+12], 0
	sub	esp, 16					; 00000010H
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR $T19048[ebp+12]
	fst	DWORD PTR 8+[ebp]
	fstp	DWORD PTR [ebx+196]
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR $T19049[ebp], esp
	mov	DWORD PTR [edx+12], ecx
	lea	edx, DWORD PTR _FlashFog$15340[ebp]
	mov	ecx, esp
	push	edx
	call	DWORD PTR __imp_??0FPlane@@QAE@ABVFVector@@@Z
	mov	edx, DWORD PTR 8+[ebp]
	mov	ecx, DWORD PTR [esi+104]
	push	1073741824				; 40000000H
	push	0
	mov	eax, DWORD PTR [ecx]
	push	edx
	mov	edx, DWORD PTR -20+[ebp]
	push	edx
	mov	edx, DWORD PTR [esi+92]
	push	0
	push	0
	mov	edx, DWORD PTR [edx+1080]
	push	edx
	call	DWORD PTR [eax+128]
$L15345:

; 432  : 	}
; 433  : 
; 434  : 	// Draw whatever stats were requested.
; 435  : 	if( Frame->Viewport->Actor->RendMap==REN_Polys || Frame->Viewport->Actor->RendMap==REN_PolyCuts || Frame->Viewport->Actor->RendMap==REN_DynLight || Frame->Viewport->Actor->RendMap==REN_PlainTex )

	mov	eax, DWORD PTR [esi+92]
	mov	eax, DWORD PTR [eax+1040]
	cmp	eax, 3
	je	SHORT $L15350
	cmp	eax, 4
	je	SHORT $L15350
	cmp	eax, 5
	je	SHORT $L15350
	cmp	eax, 6
	jne	SHORT $L15349
$L15350:

; 436  : 		DrawStats( Frame );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ebx
	call	?DrawStats@URender@@QAEXPAUFSceneNode@@@Z ; URender::DrawStats
$L15349:

; 437  : 
; 438  : 	// Restore default precision.
; 439  : 	appEnableFastMath(0);

	push	0
	call	DWORD PTR __imp_?appEnableFastMath@@YAXH@Z
	add	esp, 4

; 441  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L19052:

; 440  : 	unguard;

	mov	ecx, DWORD PTR _Err$15351[ebp]
	lea	edx, DWORD PTR $T19050[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	edx
	mov	DWORD PTR $T19050[ebp], ecx
	call	__CxxThrowException@8
	mov	eax, $L15338
	ret	0
$L19053:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??PostRender@URender@@UAEXPAUFSceneNode@@@Z@4PBDB$S15337
	push	OFFSET FLAT:$SG15353
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L15338
	ret	0
$L15338:

; 441  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
$L19076:
	mov	eax, OFFSET FLAT:$T19070
	jmp	___CxxFrameHandler
text$x	ENDS
?PostRender@URender@@UAEXPAUFSceneNode@@@Z ENDP		; URender::PostRender
EXTRN	__imp_?Log@FOutputDevice@@QAEXPBD@Z:NEAR
EXTRN	__imp_?ParseCommand@@YAHPAPBDPBD@Z:NEAR
xdata$x	SEGMENT
$T19085	DD	019930520H
	DD	02H
	DD	FLAT:$T19088
	DD	01H
	DD	FLAT:$T19089
	DD	2 DUP(00H)
	ORG $+4
$T19088	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T19089	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T19090
	ORG $+4
$T19090	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffecH
	DD	FLAT:$L19082
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L19083
xdata$x	ENDS
_TEXT	SEGMENT
_Str$15361 = 8
_Err$15409 = -20
$T19080 = 8
__$EHRec$ = -16
_Cmd$ = 8
_Out$ = 12
?Exec@URender@@UAEHPBDPAVFOutputDevice@@@Z PROC NEAR	; URender::Exec

; 451  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L19087
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ecx

; 452  : 	guard(URender::Exec);
; 453  : 	const char* Str = Cmd;

	mov	eax, DWORD PTR _Cmd$[ebp]
	push	ebx
	push	esi
	push	edi

; 454  : 
; 455  : 	if( ParseCommand(&Str,"STAT") )

	mov	edi, DWORD PTR __imp_?ParseCommand@@YAHPAPBDPBD@Z
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	lea	ecx, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15363
	push	ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR _Str$15361[ebp], eax
	call	edi
	add	esp, 8
	test	eax, eax
	je	$L15362

; 456  : 	{
; 457  : 		if( ParseCommand(&Str,"Fps"         ) ) FpsStats       ^= 1;

	lea	edx, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15365
	push	edx
	call	edi
	add	esp, 8
	mov	ebx, 1
	test	eax, eax
	je	SHORT $L19086
	xor	DWORD PTR [esi+64], ebx
$L19086:

; 458  : 		if( ParseCommand(&Str,"Global"      ) ) GlobalStats    ^= 1;

	lea	eax, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15367
	push	eax
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15366
	xor	DWORD PTR [esi+68], ebx
$L15366:

; 459  : 		if( ParseCommand(&Str,"Mesh"        ) ) MeshStats      ^= 1;

	lea	ecx, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15369
	push	ecx
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15368
	xor	DWORD PTR [esi+72], ebx
$L15368:

; 460  : 		if( ParseCommand(&Str,"Actor"       ) ) ActorStats     ^= 1;

	lea	edx, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15371
	push	edx
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15370
	xor	DWORD PTR [esi+76], ebx
$L15370:

; 461  : 		if( ParseCommand(&Str,"Filter"      ) ) FilterStats    ^= 1;

	lea	eax, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15373
	push	eax
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15372
	xor	DWORD PTR [esi+80], ebx
$L15372:

; 462  : 		if( ParseCommand(&Str,"Reject"      ) ) RejectStats    ^= 1;

	lea	ecx, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15375
	push	ecx
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15374
	xor	DWORD PTR [esi+84], ebx
$L15374:

; 463  : 		if( ParseCommand(&Str,"Span"        ) ) SpanStats      ^= 1;

	lea	edx, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15377
	push	edx
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15376
	xor	DWORD PTR [esi+88], ebx
$L15376:

; 464  : 		if( ParseCommand(&Str,"Zone"        ) ) ZoneStats      ^= 1;

	lea	eax, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15379
	push	eax
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15378
	xor	DWORD PTR [esi+92], ebx
$L15378:

; 465  : 		if( ParseCommand(&Str,"Light"       ) ) LightStats     ^= 1;

	lea	ecx, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15381
	push	ecx
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15380
	xor	DWORD PTR [esi+96], ebx
$L15380:

; 466  : 		if( ParseCommand(&Str,"Occlusion"   ) ) OcclusionStats ^= 1;

	lea	edx, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15383
	push	edx
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15382
	xor	DWORD PTR [esi+100], ebx
$L15382:

; 467  : 		if( ParseCommand(&Str,"Game"        ) ) GameStats      ^= 1;

	lea	eax, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15385
	push	eax
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15384
	xor	DWORD PTR [esi+104], ebx
$L15384:

; 468  : 		if( ParseCommand(&Str,"Soft"        ) ) SoftStats      ^= 1;

	lea	ecx, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15387
	push	ecx
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15386
	xor	DWORD PTR [esi+108], ebx
$L15386:

; 469  : 		if( ParseCommand(&Str,"Cache"       ) ) CacheStats     ^= 1;

	lea	edx, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15389
	push	edx
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15388
	xor	DWORD PTR [esi+112], ebx
$L15388:

; 470  : 		if( ParseCommand(&Str,"PolyV"       ) ) PolyVStats     ^= 1;

	lea	eax, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15391
	push	eax
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15390
	xor	DWORD PTR [esi+116], ebx
$L15390:

; 471  : 		if( ParseCommand(&Str,"PolyC"       ) ) PolyCStats     ^= 1;

	lea	ecx, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15393
	push	ecx
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15392
	xor	DWORD PTR [esi+120], ebx
$L15392:

; 472  : 		if( ParseCommand(&Str,"Illum"       ) ) IllumStats     ^= 1;

	lea	edx, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15395
	push	edx
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15394
	xor	DWORD PTR [esi+124], ebx
$L15394:

; 473  : 		if( ParseCommand(&Str,"Hardware"    ) ) HardwareStats  ^= 1;

	lea	eax, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15397
	push	eax
	call	edi
	add	esp, 8
	test	eax, eax
	je	$L15396
	mov	eax, DWORD PTR [esi+128]
	xor	eax, ebx
	mov	DWORD PTR [esi+128], eax

; 474  : 		return 1;

	mov	eax, ebx

; 486  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$L15362:

; 475  : 	}
; 476  : 	else if( ParseCommand(&Str,"REND") )

	lea	ecx, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15400
	push	ecx
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15399

; 477  : 	{
; 478  : 		if      (ParseCommand(&Str,"LEAK"))			LeakCheck		^= 1;

	lea	edx, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15402
	push	edx
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15401
	mov	eax, DWORD PTR [esi+28]
	mov	ebx, 1
	xor	eax, ebx
	mov	DWORD PTR [esi+28], eax

; 479  : 		else if (ParseCommand(&Str,"T"))			Toggle			^= 1;

	jmp	SHORT $L15406
$L15401:
	lea	eax, DWORD PTR _Str$15361[ebp]
	push	OFFSET FLAT:$SG15405
	push	eax
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $L15399
	mov	eax, DWORD PTR [esi+24]
	mov	ebx, 1
	xor	eax, ebx
	mov	DWORD PTR [esi+24], eax
$L15406:

; 480  : 		else return 0;
; 481  : 		Out->Log( "Rendering option recognized" );

	mov	ecx, DWORD PTR _Out$[ebp]
	push	OFFSET FLAT:$SG15407
	call	DWORD PTR __imp_?Log@FOutputDevice@@QAEXPBD@Z
$L15396:

; 482  : 		return 1;

	mov	eax, ebx

; 486  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$L15399:

; 483  : 	}
; 484  : 	else return 0; // Not executed

	xor	eax, eax

; 486  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$L19082:

; 485  : 	unguard;

	mov	ecx, DWORD PTR _Err$15409[ebp]
	lea	edx, DWORD PTR $T19080[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	edx
	mov	DWORD PTR $T19080[ebp], ecx
	call	__CxxThrowException@8
	mov	eax, $L15360
	ret	0
$L19083:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??Exec@URender@@UAEHPBDPAVFOutputDevice@@@Z@4PBDB$S15359
	push	OFFSET FLAT:$SG15411
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L15360
	ret	0
$L15360:

; 486  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
$L19087:
	mov	eax, OFFSET FLAT:$T19085
	jmp	___CxxFrameHandler
text$x	ENDS
?Exec@URender@@UAEHPBDPAVFOutputDevice@@@Z ENDP		; URender::Exec
PUBLIC	?Half@?1??appFloor@@YAHM@Z@4MA			; Half
PUBLIC	?ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z ; URender::ClipBspSurf
PUBLIC	?Project@FTransform@@QAEXPBUFSceneNode@@@Z	; FTransform::Project
PUBLIC	?OutXMinTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB ; OutXMinTab
PUBLIC	?OutXMaxTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB ; OutXMaxTab
PUBLIC	?OutYMinTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB ; OutYMinTab
PUBLIC	?OutYMaxTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB ; OutYMaxTab
EXTRN	__imp_??0FVector@@QAE@MMM@Z:NEAR
EXTRN	__imp_??UFVector@@QBEMABV0@@Z:NEAR
EXTRN	__imp_??HFVector@@QBE?AV0@ABV0@@Z:NEAR
EXTRN	__imp_??DFVector@@QBE?AV0@M@Z:NEAR
EXTRN	__imp_?PushBytes@FMemStack@@QAEPAEHH@Z:NEAR
EXTRN	__imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z:NEAR
EXTRN	__imp_?GDynMem@@3VFMemStack@@A:BYTE
_BSS	SEGMENT
_Dot$S15412 DD	018H DUP (?)
_?LocalPts@?3??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15445 DD 018H DUP (?)
_?LocalPts@?BD@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15468 DD 018H DUP (?)
_?LocalPts@?BJ@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15476 DD 018H DUP (?)
_?LocalPts@?BP@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15484 DD 018H DUP (?)
_?LocalPts@?CF@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15492 DD 018H DUP (?)
_?LocalPts@?DA@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15506 DD 018H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	?ClipXM@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4MA:DWORD							; ClipXM
COMM	?ClipXP@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4MA:DWORD							; ClipXP
COMM	?ClipYM@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4MA:DWORD							; ClipYM
COMM	?ClipYP@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4MA:DWORD							; ClipYP
_DATA	ENDS
;	COMDAT ?Half@?1??appFloor@@YAHM@Z@4MA
; File ..\..\Engine\Inc\UnMath.h
_DATA	SEGMENT
?Half@?1??appFloor@@YAHM@Z@4MA DD 03f000000r	; 0.5	; Half
_DATA	ENDS
;	COMDAT ?OutXMinTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB
CONST	SEGMENT
?OutXMinTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB DB 00H ; OutXMinTab
	DB	04H
CONST	ENDS
;	COMDAT ?OutXMaxTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB
CONST	SEGMENT
?OutXMaxTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB DB 00H ; OutXMaxTab
	DB	08H
CONST	ENDS
;	COMDAT ?OutYMinTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB
CONST	SEGMENT
?OutYMinTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB DB 00H ; OutYMinTab
	DB	010H
CONST	ENDS
;	COMDAT ?OutYMaxTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB
CONST	SEGMENT
?OutYMaxTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB DB 00H ; OutYMaxTab
	DB	020H
CONST	ENDS
CONST	SEGMENT
	ORG $+4
$T19299	DQ	03ff0000000000000r		; 1
$T19300	DQ	00000000000000000r		; 0
CONST	ENDS
xdata$x	SEGMENT
$T19289	DD	019930520H
	DD	02H
	DD	FLAT:$T19305
	DD	01H
	DD	FLAT:$T19306
	DD	2 DUP(00H)
	ORG $+4
$T19305	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T19306	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T19307
	ORG $+4
$T19307	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffd0H
	DD	FLAT:$L19099
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L19100
xdata$x	ENDS
_TEXT	SEGMENT
_Frame$ = 8
_Model$ = 12
_iNode$ = 16
_Result$ = 20
_NumPts$15447 = -24
_VertPool$15448 = -36
_Outcode$15449 = -17
_AllCodes$15450 = 19
_i$15451 = -32
_S$15456 = -28
_Err$15508 = -48
$T19094 = -72
$T19097 = 8
_Temp$19137 = -60
$T19141 = -40
$T19144 = -40
_I$19147 = -44
_i$19174 = 12
$T19187 = -72
$T19188 = -60
$T19189 = -84
_i$19220 = 12
$T19233 = -72
$T19234 = -60
$T19235 = -84
_i$19264 = 12
$T19277 = -72
$T19278 = -84
$T19279 = -60
__$EHRec$ = -16
?ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z PROC NEAR ; URender::ClipBspSurf

; 520  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L19304
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 68					; 00000044H

; 526  : 	FBspNode* Node		= &Model->Nodes->Element(iNode);

	mov	ecx, DWORD PTR _Model$[ebp]
	mov	eax, DWORD PTR _iNode$[ebp]
	push	ebx
	push	esi
	mov	edx, DWORD PTR [ecx+140]

; 527  : 	INT       NumPts    = Node->NumVertices;
; 528  : 	FVert*	  VertPool	= &Model->Verts->Element(Node->iVertPool);

	mov	ecx, DWORD PTR [ecx+148]
	mov	ebx, DWORD PTR ?GStat@@3UFRenderStats@@A+96
	push	edi
	mov	esi, DWORD PTR [edx+88]
	mov	ecx, DWORD PTR [ecx+88]
	shl	eax, 6
	add	eax, esi
	xor	edx, edx

; 529  : 	BYTE      Outcode   = FVF_OutReject;
; 530  : 	BYTE      AllCodes  = 0;
; 531  : 	for( INT i=0; i<NumPts; i++ )

	mov	esi, DWORD PTR ?Stamp@URender@@2KA	; URender::Stamp
	inc	ebx
	mov	dl, BYTE PTR [eax+54]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	lea	eax, DWORD PTR [ecx+eax*8]
	xor	ecx, ecx
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+96, ebx
	mov	DWORD PTR _NumPts$15447[ebp], edx
	mov	DWORD PTR _VertPool$15448[ebp], eax
	mov	BYTE PTR _Outcode$15449[ebp], 60	; 0000003cH
	mov	BYTE PTR _AllCodes$15450[ebp], 0
	mov	DWORD PTR _i$15451[ebp], ecx
$L15452:
	cmp	ecx, edx
	jge	$L15454

; 533  : 		INT pPoint = VertPool[i].pVertex;

	mov	eax, DWORD PTR _VertPool$15448[ebp]
	mov	ebx, DWORD PTR [eax+ecx*8]

; 534  : 		FStampedPoint& S = PointCache[pPoint];

	mov	eax, DWORD PTR ?PointCache@URender@@2PAUFStampedPoint@1@A ; URender::PointCache
	lea	edi, DWORD PTR [eax+ebx*8]
	mov	DWORD PTR _S$15456[ebp], edi

; 535  : 		if( S.Stamp != Stamp )

	cmp	DWORD PTR [edi+4], esi
	je	$L15457

; 538  : 			S.Point        = new(VectorMem)FTransform;

	mov	ecx, DWORD PTR ?VectorMem@URender@@2VFMemStack@@A+4
	mov	DWORD PTR [edi+4], esi
	lea	esi, DWORD PTR [ecx+7]
	mov	ecx, DWORD PTR ?VectorMem@URender@@2VFMemStack@@A+8
	and	esi, -8					; fffffff8H
	lea	eax, DWORD PTR [esi+32]
	cmp	eax, ecx
	mov	DWORD PTR ?VectorMem@URender@@2VFMemStack@@A+4, eax
	jbe	SHORT $L19115
	push	8
	push	32					; 00000020H
	mov	ecx, OFFSET FLAT:?VectorMem@URender@@2VFMemStack@@A ; URender::VectorMem
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	edx, DWORD PTR ?VectorMem@URender@@2VFMemStack@@A+4
	lea	esi, DWORD PTR [edx+7]
	and	esi, -8					; fffffff8H
	lea	eax, DWORD PTR [esi+32]
	mov	DWORD PTR ?VectorMem@URender@@2VFMemStack@@A+4, eax
$L19115:

; 539  : 			S.Point->Point = Model->Points->Element(pPoint).TransformPointBy( Frame->Coords );

	mov	edx, DWORD PTR _Model$[ebp]
	lea	ecx, DWORD PTR [ebx+ebx*2]
	mov	DWORD PTR [edi], esi
	mov	edi, DWORD PTR _Frame$[ebp]
	mov	eax, DWORD PTR [edx+136]
	push	ecx
	mov	edx, DWORD PTR [eax+88]
	fld	DWORD PTR [edx+ecx*4+8]
	fsub	DWORD PTR [edi+60]
	lea	eax, DWORD PTR [edx+ecx*4]
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [edi+56]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [edi+52]
	push	ecx
	lea	ecx, DWORD PTR _Temp$19137[ebp]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	lea	eax, DWORD PTR [edi+64]
	lea	ecx, DWORD PTR _Temp$19137[ebp]
	push	eax
	call	DWORD PTR __imp_??UFVector@@QBEMABV0@@Z
	fstp	DWORD PTR -40+[ebp]
	fld	DWORD PTR [edi+92]
	fmul	DWORD PTR _Temp$19137[ebp+4]
	fld	DWORD PTR [edi+96]
	fmul	DWORD PTR _Temp$19137[ebp+8]
	push	ecx
	faddp	ST(1), ST(0)
	fld	DWORD PTR [edi+88]
	fmul	DWORD PTR _Temp$19137[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [edi+80]
	fmul	DWORD PTR _Temp$19137[ebp+4]
	fld	DWORD PTR [edi+84]
	fmul	DWORD PTR _Temp$19137[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR -40+[ebp]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [edi+76]
	fmul	DWORD PTR _Temp$19137[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR [esp]
	push	ecx
	lea	ecx, DWORD PTR $T19094[ebp]
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	mov	eax, DWORD PTR $T19094[ebp]
	mov	edx, esi

; 540  : 			S.Point->ComputeOutcode( Frame );

	mov	DWORD PTR $T19141[ebp], esi
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T19094[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T19094[ebp+8]
	mov	DWORD PTR [edx+8], eax

; 529  : 	BYTE      Outcode   = FVF_OutReject;
; 530  : 	BYTE      AllCodes  = 0;
; 531  : 	for( INT i=0; i<NumPts; i++ )

	mov	ecx, DWORD PTR $T19141[ebp]

; 532  : 	{

	mov	esi, DWORD PTR _Frame$[ebp]

; 536  : 		{

	fld	DWORD PTR [ecx+8]

; 537  : 			S.Stamp        = Stamp;

	fld	DWORD PTR [ecx+8]

; 538  : 			S.Point        = new(VectorMem)FTransform;

	fxch	ST(1)

; 539  : 			S.Point->Point = Model->Points->Element(pPoint).TransformPointBy( Frame->Coords );

	fmul	DWORD PTR [esi+256]

; 540  : 			S.Point->ComputeOutcode( Frame );

	fxch	ST(1)

; 541  : 			if( !S.Point->Flags )

	fmul	DWORD PTR [esi+264]

; 542  : 				S.Point->Project( Frame );

	fld	DWORD PTR [ecx+8]

; 543  : 			STAT(GStat.NumPoints++);

	fld	DWORD PTR [ecx+8]

; 544  : 		}

	fxch	ST(1)

; 545  : 		LocalPts[i] = S.Point;

	fmul	DWORD PTR [esi+260]

; 546  : 		DWORD Flags = S.Point->Flags; 

	fxch	ST(1)

; 547  : 		Outcode    &= Flags;

	fmul	DWORD PTR [esi+268]

; 548  : 		AllCodes   |= Flags;

	fxch	ST(3)

; 549  : 	}

	fadd	DWORD PTR [ecx]

; 550  : 	if( Outcode )

	fxch	ST(2)

; 551  : 		return 0;

	fadd	DWORD PTR [ecx+4]

; 552  : 

	fxch	ST(1)

; 553  : 	// Clip.

	fsub	DWORD PTR [ecx]

; 554  : 	STAT(GStat.NumClip++);

	fxch	ST(3)

; 555  : 	FTransform** Pts = LocalPts;

	fsub	DWORD PTR [ecx+4]

; 556  : 	if( AllCodes )

	fxch	ST(2)

; 557  : 	{

	fstp	DWORD PTR ?ClipXM@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4MA ; ClipXM

; 558  : 		if( AllCodes & FVF_OutXMin )

	fstp	DWORD PTR ?ClipYM@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4MA ; ClipYM

; 559  : 		{

	fstp	DWORD PTR ?ClipYP@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4MA ; ClipYP

; 560  : 			static FTransform* LocalPts[FBspNode::MAX_FINAL_VERTICES];

	fstp	DWORD PTR ?ClipXP@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4MA ; ClipXP

; 564  : 			if( !NumPts )

	mov	ebx, DWORD PTR ?ClipXM@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4MA

; 565  : 				return 0;

	mov	edx, DWORD PTR ?ClipYM@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4MA

; 567  : 		}

	shr	ebx, 31					; 0000001fH

; 568  : 		if( AllCodes & FVF_OutXMax )

	mov	edi, DWORD PTR ?ClipXP@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4MA

; 569  : 		{
; 570  : 			static FTransform* LocalPts[FBspNode::MAX_FINAL_VERTICES];

	shr	edx, 31					; 0000001fH

; 571  : 			for( INT i=0; i<NumPts; i++ )

	mov	esi, DWORD PTR ?ClipYP@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4MA

; 573  : 			NumPts = Clip( Frame, LocalPts, Pts, NumPts );

	shr	edi, 31					; 0000001fH

; 574  : 			if( !NumPts )

	mov	al, BYTE PTR ?OutXMinTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB[ebx]

; 576  : 			Pts = LocalPts;

	shr	esi, 31					; 0000001fH

; 577  : 		}

	mov	bl, BYTE PTR ?OutYMinTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB[edx]

; 579  : 		{

	or	bl, al

; 580  : 			static FTransform* LocalPts[FBspNode::MAX_FINAL_VERTICES];

	mov	ah, BYTE PTR ?OutXMaxTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB[edi]

; 582  : 				Dot[i] = Frame->PrjYM * Pts[i]->Point.Z + Pts[i]->Point.Y;

	or	bl, ah

; 583  : 			NumPts = Clip( Frame, LocalPts, Pts, NumPts );

	mov	al, BYTE PTR ?OutYMaxTab@?1??ComputeOutcode@FTransform@@QAEXPBUFSceneNode@@@Z@4PBEB[esi]

; 585  : 				return 0;

	or	al, bl

; 587  : 		}

	mov	BYTE PTR [ecx+12], al

; 541  : 			if( !S.Point->Flags )

	mov	ecx, DWORD PTR _S$15456[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	cl, BYTE PTR [eax+12]
	test	cl, cl
	jne	SHORT $L19148

; 542  : 				S.Point->Project( Frame );

	fld	DWORD PTR [eax+8]
	fdivr	QWORD PTR $T19299
	mov	ecx, DWORD PTR _Frame$[ebp]
	fst	DWORD PTR [eax+28]
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(1)
	fmul	DWORD PTR [ecx+240]
	fadd	DWORD PTR [ecx+200]
	fstp	DWORD PTR [eax+16]
	fmul	DWORD PTR [eax+4]
	fmul	DWORD PTR [ecx+240]
	fadd	DWORD PTR [ecx+204]
	fst	DWORD PTR [eax+20]
	fstp	DWORD PTR $T19144[ebp]

; 521  : 	guard(URender::ClipBspSurf);
; 522  : 	static FTransform* LocalPts[FBspNode::MAX_FINAL_VERTICES];
; 523  : 

	fld	DWORD PTR $T19144[ebp]

; 524  : 	// Transform.

	fsub	DWORD PTR ?Half@?1??appFloor@@YAHM@Z@4MA ; Half

; 525  : 	STAT(GStat.NumTransform++);

	fistp	DWORD PTR _I$19147[ebp]

; 542  : 				S.Point->Project( Frame );

	mov	edx, DWORD PTR _I$19147[ebp]
	mov	DWORD PTR [eax+24], edx
$L19148:

; 543  : 			STAT(GStat.NumPoints++);

	mov	eax, DWORD PTR ?GStat@@3UFRenderStats@@A+128
	mov	esi, DWORD PTR ?Stamp@URender@@2KA	; URender::Stamp
	mov	ecx, DWORD PTR _i$15451[ebp]
	mov	edi, DWORD PTR _S$15456[ebp]
	mov	edx, DWORD PTR _NumPts$15447[ebp]
	inc	eax
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+128, eax
$L15457:

; 545  : 		LocalPts[i] = S.Point;

	mov	edi, DWORD PTR [edi]

; 547  : 		Outcode    &= Flags;

	mov	bl, BYTE PTR _Outcode$15449[ebp]
	xor	eax, eax
	mov	DWORD PTR _?LocalPts@?3??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15445[ecx*4], edi
	mov	al, BYTE PTR [edi+12]
	and	bl, al
	mov	BYTE PTR _Outcode$15449[ebp], bl

; 548  : 		AllCodes   |= Flags;

	mov	bl, BYTE PTR _AllCodes$15450[ebp]
	or	bl, al
	inc	ecx
	mov	BYTE PTR _AllCodes$15450[ebp], bl
	mov	DWORD PTR _i$15451[ebp], ecx
	jmp	$L15452
$L15454:

; 550  : 	if( Outcode )

	mov	al, BYTE PTR _Outcode$15449[ebp]
	test	al, al
	je	SHORT $L15463

; 551  : 		return 0;

	xor	eax, eax

; 619  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L15463:

; 554  : 	STAT(GStat.NumClip++);

	mov	esi, DWORD PTR ?GStat@@3UFRenderStats@@A+100

; 556  : 	if( AllCodes )

	mov	al, BYTE PTR _AllCodes$15450[ebp]
	inc	esi
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+100, esi
	mov	esi, OFFSET FLAT:_?LocalPts@?3??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15445
	test	al, al
	je	$L19303

; 558  : 		if( AllCodes & FVF_OutXMin )

	test	al, 4
	je	$L15466

; 561  : 			for( INT i=0; i<NumPts; i++ )

	xor	ecx, ecx
$L15470:
	cmp	ecx, edx
	jge	SHORT $L15472

; 562  : 				Dot[i] = Frame->PrjXM * Pts[i]->Point.Z + Pts[i]->Point.X;

	mov	edi, DWORD PTR _Frame$[ebp]
	mov	eax, DWORD PTR [esi+ecx*4]
	inc	ecx
	fld	DWORD PTR [edi+256]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR _Dot$S15412[ecx*4-4]
	jmp	SHORT $L15470
$L15472:

; 563  : 			NumPts = Clip( Frame, LocalPts, Pts, NumPts );

	xor	ebx, ebx
	xor	ecx, ecx
	mov	DWORD PTR _i$19174[ebp], ecx
	lea	eax, DWORD PTR [edx-1]
$L19176:
	cmp	ecx, edx
	jge	$L19178
	lea	edi, DWORD PTR [eax*4]
	fld	DWORD PTR _Dot$S15412[edi]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L19179
	mov	eax, DWORD PTR [esi+edi]
	mov	DWORD PTR _?LocalPts@?BD@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15468[ebx*4], eax
	inc	ebx
$L19179:
	fld	DWORD PTR _Dot$S15412[ecx*4]
	fmul	DWORD PTR _Dot$S15412[edi]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 1
	je	$L19177
	mov	ecx, DWORD PTR _Frame$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	mov	eax, DWORD PTR [edx+112]
	test	eax, eax
	jne	SHORT $L19184
	mov	ecx, DWORD PTR __imp_?GMem@@3VFMemStack@@A
$L19184:
	push	8
	push	32					; 00000020H
	call	DWORD PTR __imp_?PushBytes@FMemStack@@QAEPAEHH@Z
	mov	ecx, DWORD PTR [esi+edi]
	mov	DWORD PTR _?LocalPts@?BD@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15468[ebx*4], eax
	mov	eax, DWORD PTR _i$19174[ebp]
	push	ecx
	mov	eax, DWORD PTR [esi+eax*4]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	push	ecx
	lea	ecx, DWORD PTR $T19187[ebp]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	mov	ecx, DWORD PTR _i$19174[ebp]
	fld	DWORD PTR _Dot$S15412[edi]
	fsub	DWORD PTR _Dot$S15412[ecx*4]
	push	ecx
	fdivr	DWORD PTR _Dot$S15412[edi]
	fld	DWORD PTR $T19187[ebp+8]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR [esp]
	fld	DWORD PTR $T19187[ebp+4]
	fmul	ST(0), ST(1)
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR $T19187[ebp]
	fmul	ST(0), ST(1)
	push	ecx
	lea	ecx, DWORD PTR $T19188[ebp]
	fstp	DWORD PTR [esp]
	fstp	ST(0)
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	mov	ecx, DWORD PTR [esi+edi]
	lea	edx, DWORD PTR $T19188[ebp]
	lea	eax, DWORD PTR $T19189[ebp]
	push	edx
	push	eax
	call	DWORD PTR __imp_??HFVector@@QBE?AV0@ABV0@@Z
	mov	ecx, DWORD PTR _?LocalPts@?BD@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15468[ebx*4]
	mov	edi, DWORD PTR [eax]
	mov	edx, ecx
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+4], edi
	mov	DWORD PTR [edx+8], eax
	mov	edx, DWORD PTR _Frame$[ebp]
	push	edx
	call	?Project@FTransform@@QAEXPBUFSceneNode@@@Z ; FTransform::Project
	mov	edx, DWORD PTR _NumPts$15447[ebp]
	mov	ecx, DWORD PTR _i$19174[ebp]
	inc	ebx
$L19177:
	mov	eax, ecx
	inc	ecx
	mov	DWORD PTR _i$19174[ebp], ecx
	jmp	$L19176
$L19178:

; 564  : 			if( !NumPts )

	test	ebx, ebx
	mov	DWORD PTR _NumPts$15447[ebp], ebx
	jne	SHORT $L15473

; 565  : 				return 0;

	xor	eax, eax

; 619  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L15473:

; 566  : 			Pts = LocalPts;

	mov	edx, DWORD PTR _NumPts$15447[ebp]
	mov	esi, OFFSET FLAT:_?LocalPts@?BD@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15468
$L15466:

; 568  : 		if( AllCodes & FVF_OutXMax )

	test	BYTE PTR _AllCodes$15450[ebp], 8
	je	$L15474

; 571  : 			for( INT i=0; i<NumPts; i++ )

	xor	ecx, ecx
$L15478:
	cmp	ecx, edx
	jge	SHORT $L15480

; 572  : 				Dot[i] = Frame->PrjXP * Pts[i]->Point.Z - Pts[i]->Point.X;

	mov	edi, DWORD PTR _Frame$[ebp]
	mov	eax, DWORD PTR [esi+ecx*4]
	inc	ecx
	fld	DWORD PTR [edi+260]
	fmul	DWORD PTR [eax+8]
	fsub	DWORD PTR [eax]
	fstp	DWORD PTR _Dot$S15412[ecx*4-4]
	jmp	SHORT $L15478
$L15480:

; 573  : 			NumPts = Clip( Frame, LocalPts, Pts, NumPts );

	xor	ebx, ebx
	xor	ecx, ecx
	mov	DWORD PTR _i$19220[ebp], ecx
	lea	eax, DWORD PTR [edx-1]
$L19222:
	cmp	ecx, edx
	jge	$L19224
	lea	edi, DWORD PTR [eax*4]
	fld	DWORD PTR _Dot$S15412[edi]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L19225
	mov	eax, DWORD PTR [esi+edi]
	mov	DWORD PTR _?LocalPts@?BJ@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15476[ebx*4], eax
	inc	ebx
$L19225:
	fld	DWORD PTR _Dot$S15412[ecx*4]
	fmul	DWORD PTR _Dot$S15412[edi]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 1
	je	$L19223
	mov	ecx, DWORD PTR _Frame$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	mov	eax, DWORD PTR [edx+112]
	test	eax, eax
	jne	SHORT $L19230
	mov	ecx, DWORD PTR __imp_?GMem@@3VFMemStack@@A
$L19230:
	push	8
	push	32					; 00000020H
	call	DWORD PTR __imp_?PushBytes@FMemStack@@QAEPAEHH@Z
	mov	ecx, DWORD PTR [esi+edi]
	mov	DWORD PTR _?LocalPts@?BJ@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15476[ebx*4], eax
	mov	eax, DWORD PTR _i$19220[ebp]
	push	ecx
	mov	eax, DWORD PTR [esi+eax*4]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	push	ecx
	lea	ecx, DWORD PTR $T19233[ebp]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	mov	ecx, DWORD PTR _i$19220[ebp]
	fld	DWORD PTR _Dot$S15412[edi]
	fsub	DWORD PTR _Dot$S15412[ecx*4]
	push	ecx
	fdivr	DWORD PTR _Dot$S15412[edi]
	fld	DWORD PTR $T19233[ebp+8]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR [esp]
	fld	DWORD PTR $T19233[ebp+4]
	fmul	ST(0), ST(1)
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR $T19233[ebp]
	fmul	ST(0), ST(1)
	push	ecx
	lea	ecx, DWORD PTR $T19234[ebp]
	fstp	DWORD PTR [esp]
	fstp	ST(0)
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	mov	ecx, DWORD PTR [esi+edi]
	lea	edx, DWORD PTR $T19234[ebp]
	lea	eax, DWORD PTR $T19235[ebp]
	push	edx
	push	eax
	call	DWORD PTR __imp_??HFVector@@QBE?AV0@ABV0@@Z
	mov	ecx, DWORD PTR _?LocalPts@?BJ@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15476[ebx*4]
	mov	edi, DWORD PTR [eax]
	mov	edx, ecx
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+4], edi
	mov	DWORD PTR [edx+8], eax
	mov	edx, DWORD PTR _Frame$[ebp]
	push	edx
	call	?Project@FTransform@@QAEXPBUFSceneNode@@@Z ; FTransform::Project
	mov	edx, DWORD PTR _NumPts$15447[ebp]
	mov	ecx, DWORD PTR _i$19220[ebp]
	inc	ebx
$L19223:
	mov	eax, ecx
	inc	ecx
	mov	DWORD PTR _i$19220[ebp], ecx
	jmp	$L19222
$L19224:

; 574  : 			if( !NumPts )

	test	ebx, ebx
	mov	DWORD PTR _NumPts$15447[ebp], ebx
	jne	SHORT $L15481

; 575  : 				return 0;

	xor	eax, eax

; 619  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L15481:

; 576  : 			Pts = LocalPts;

	mov	edx, DWORD PTR _NumPts$15447[ebp]
	mov	esi, OFFSET FLAT:_?LocalPts@?BJ@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15476
$L15474:

; 578  : 		if( AllCodes & FVF_OutYMin )

	test	BYTE PTR _AllCodes$15450[ebp], 16	; 00000010H
	je	$L15482

; 581  : 			for( INT i=0; i<NumPts; i++ )

	xor	ecx, ecx
$L15486:
	cmp	ecx, edx
	jge	SHORT $L15488

; 582  : 				Dot[i] = Frame->PrjYM * Pts[i]->Point.Z + Pts[i]->Point.Y;

	mov	edi, DWORD PTR _Frame$[ebp]
	mov	eax, DWORD PTR [esi+ecx*4]
	inc	ecx
	fld	DWORD PTR [edi+264]
	fmul	DWORD PTR [eax+8]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _Dot$S15412[ecx*4-4]
	jmp	SHORT $L15486
$L15488:

; 583  : 			NumPts = Clip( Frame, LocalPts, Pts, NumPts );

	xor	ebx, ebx
	xor	ecx, ecx
	mov	DWORD PTR _i$19264[ebp], ecx
	lea	eax, DWORD PTR [edx-1]
$L19266:
	cmp	ecx, edx
	jge	$L19268
	lea	edi, DWORD PTR [eax*4]
	fld	DWORD PTR _Dot$S15412[edi]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L19269
	mov	eax, DWORD PTR [esi+edi]
	mov	DWORD PTR _?LocalPts@?BP@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15484[ebx*4], eax
	inc	ebx
$L19269:
	fld	DWORD PTR _Dot$S15412[edi]
	fmul	DWORD PTR _Dot$S15412[ecx*4]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 1
	je	$L19267
	mov	ecx, DWORD PTR _Frame$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	mov	eax, DWORD PTR [edx+112]
	test	eax, eax
	jne	SHORT $L19274
	mov	ecx, DWORD PTR __imp_?GMem@@3VFMemStack@@A
$L19274:
	push	8
	push	32					; 00000020H
	call	DWORD PTR __imp_?PushBytes@FMemStack@@QAEPAEHH@Z
	mov	ecx, DWORD PTR [esi+edi]
	mov	DWORD PTR _?LocalPts@?BP@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15484[ebx*4], eax
	mov	eax, DWORD PTR _i$19264[ebp]
	push	ecx
	mov	eax, DWORD PTR [esi+eax*4]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	push	ecx
	lea	ecx, DWORD PTR $T19277[ebp]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	mov	ecx, DWORD PTR _i$19264[ebp]
	lea	edx, DWORD PTR $T19278[ebp]
	fld	DWORD PTR _Dot$S15412[edi]
	fsub	DWORD PTR _Dot$S15412[ecx*4]
	push	ecx
	lea	ecx, DWORD PTR $T19277[ebp]
	fdivr	DWORD PTR _Dot$S15412[edi]
	fstp	DWORD PTR [esp]
	push	edx
	call	DWORD PTR __imp_??DFVector@@QBE?AV0@M@Z
	mov	ecx, DWORD PTR [esi+edi]
	push	eax
	lea	eax, DWORD PTR $T19279[ebp]
	push	eax
	call	DWORD PTR __imp_??HFVector@@QBE?AV0@ABV0@@Z
	mov	ecx, DWORD PTR _?LocalPts@?BP@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15484[ebx*4]
	mov	edi, DWORD PTR [eax]
	mov	edx, ecx
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+4], edi
	mov	DWORD PTR [edx+8], eax
	mov	edx, DWORD PTR _Frame$[ebp]
	push	edx
	call	?Project@FTransform@@QAEXPBUFSceneNode@@@Z ; FTransform::Project
	mov	edx, DWORD PTR _NumPts$15447[ebp]
	mov	ecx, DWORD PTR _i$19264[ebp]
	inc	ebx
$L19267:
	mov	eax, ecx
	inc	ecx
	mov	DWORD PTR _i$19264[ebp], ecx
	jmp	$L19266
$L19268:

; 584  : 			if( !NumPts )

	test	ebx, ebx
	mov	DWORD PTR _NumPts$15447[ebp], ebx
	jne	SHORT $L15489

; 585  : 				return 0;

	xor	eax, eax

; 619  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L15489:

; 586  : 			Pts = LocalPts;

	mov	edx, DWORD PTR _NumPts$15447[ebp]
	mov	esi, OFFSET FLAT:_?LocalPts@?BP@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15484
$L15482:

; 588  : 		if( AllCodes & FVF_OutYMax )

	test	BYTE PTR _AllCodes$15450[ebp], 32	; 00000020H
	je	SHORT $L19303

; 589  : 		{
; 590  : 			static FTransform* LocalPts[FBspNode::MAX_FINAL_VERTICES];
; 591  : 			for( INT i=0; i<NumPts; i++ )

	xor	ecx, ecx
$L15494:
	cmp	ecx, edx
	jge	SHORT $L15496

; 592  : 				Dot[i] = Frame->PrjYP * Pts[i]->Point.Z - Pts[i]->Point.Y;

	mov	edi, DWORD PTR _Frame$[ebp]
	mov	eax, DWORD PTR [esi+ecx*4]
	inc	ecx
	fld	DWORD PTR [edi+268]
	fmul	DWORD PTR [eax+8]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR _Dot$S15412[ecx*4-4]
	jmp	SHORT $L15494
$L15496:

; 593  : 			NumPts = Clip( Frame, LocalPts, Pts, NumPts );

	mov	eax, DWORD PTR _NumPts$15447[ebp]
	mov	edi, DWORD PTR _Frame$[ebp]
	push	eax
	push	esi
	push	OFFSET FLAT:_?LocalPts@?CF@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15492
	push	edi
	call	?Clip@@YAHPAUFSceneNode@@PAPAUFTransform@@1H@Z ; Clip
	add	esp, 16					; 00000010H
	mov	DWORD PTR _NumPts$15447[ebp], eax

; 594  : 			if( !NumPts )

	test	eax, eax
	jne	SHORT $L15497

; 619  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L15497:

; 595  : 				return 0;
; 596  : 			Pts = LocalPts;

	mov	edx, DWORD PTR _NumPts$15447[ebp]
	mov	esi, OFFSET FLAT:_?LocalPts@?CF@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15492
	jmp	SHORT $L15490
$L19303:
	mov	edi, DWORD PTR _Frame$[ebp]
$L15490:

; 597  : 		}
; 598  : 	}
; 599  : 	if( Frame->NearClip.W != 0.0 )

	fld	DWORD PTR [edi+48]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L15504

; 600  : 	{
; 601  : 		UBOOL Clipped=0;

	xor	ebx, ebx

; 602  : 		for( INT i=0; i<NumPts; i++ )

	xor	ecx, ecx
$L15501:
	cmp	ecx, edx
	jge	SHORT $L15503

; 603  : 		{
; 604  : 			Dot[i] = Frame->NearClip.PlaneDot(Pts[i]->Point);

	mov	eax, DWORD PTR [esi+ecx*4]
	fld	DWORD PTR [edi+40]
	fmul	DWORD PTR [eax+4]
	fld	DWORD PTR [edi+44]
	fmul	DWORD PTR [eax+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [edi+36]
	faddp	ST(1), ST(0)
	fsub	DWORD PTR [edi+48]
	fst	DWORD PTR _Dot$S15412[ecx*4]

; 605  : 			Clipped |= (Dot[i]<0.0);

	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 1
	je	SHORT $L19095
	mov	eax, 1
	or	ebx, eax
	inc	ecx
	jmp	SHORT $L15501
$L19095:
	xor	eax, eax
	or	ebx, eax
	inc	ecx
	jmp	SHORT $L15501
$L15503:

; 606  : 		}
; 607  : 		if( Clipped )

	test	ebx, ebx
	je	SHORT $L15504

; 608  : 		{
; 609  : 			static FTransform* LocalPts[FBspNode::MAX_FINAL_VERTICES];
; 610  : 			NumPts = Clip( Frame, LocalPts, Pts, NumPts );

	mov	ecx, DWORD PTR _NumPts$15447[ebp]
	push	ecx
	push	esi
	push	OFFSET FLAT:_?LocalPts@?DA@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15506
	push	edi
	call	?Clip@@YAHPAUFSceneNode@@PAPAUFTransform@@1H@Z ; Clip
	add	esp, 16					; 00000010H
	mov	DWORD PTR _NumPts$15447[ebp], eax

; 611  : 			if( !NumPts )

	test	eax, eax
	jne	SHORT $L15507

; 619  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L15507:

; 612  : 				return 0;
; 613  : 			Pts = LocalPts;

	mov	edx, DWORD PTR _NumPts$15447[ebp]
	mov	esi, OFFSET FLAT:_?LocalPts@?DA@??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PAPAU5@A$S15506
$L15504:

; 614  : 		}
; 615  : 	}
; 616  : 	Result = Pts;

	mov	ecx, DWORD PTR _Result$[ebp]

; 617  : 	return NumPts;

	mov	eax, edx
	mov	DWORD PTR [ecx], esi
$L15440:

; 619  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L19099:

; 618  : 	unguard;

	mov	edx, DWORD PTR _Err$15508[ebp]
	lea	eax, DWORD PTR $T19097[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	eax
	mov	DWORD PTR $T19097[ebp], edx
	call	__CxxThrowException@8
	mov	eax, $L15440
	ret	0
$L19100:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z@4PBDB$S15442
	push	OFFSET FLAT:$SG15510
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L15440
	ret	0
_TEXT	ENDS
text$x	SEGMENT
$L19304:
	mov	eax, OFFSET FLAT:$T19289
	jmp	___CxxFrameHandler
text$x	ENDS
?ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z ENDP ; URender::ClipBspSurf
_TEXT	SEGMENT
_Frame$ = 8
_Dest$ = 12
_Src$ = 16
_SrcNum$ = 20
_DestNum$ = -4
_i$ = -12
$T19314 = -44
$T19315 = -56
$T19316 = -32
$T19346 = 8
$T19356 = 8
_I$19360 = -20
?Clip@@YAHPAUFSceneNode@@PAPAUFTransform@@1H@Z PROC NEAR ; Clip

; 497  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	edi

; 498  : 	INT DestNum=0;
; 499  : 	for( INT i=0,j=SrcNum-1; i<SrcNum; j=i++ )

	mov	edi, DWORD PTR _SrcNum$[ebp]
	xor	edx, edx
	cmp	edi, edx
	mov	DWORD PTR _DestNum$[ebp], edx
	mov	DWORD PTR _i$[ebp], edx
	jle	$L15424
	mov	eax, DWORD PTR _Dest$[ebp]
	push	esi
	mov	DWORD PTR 12+[ebp], eax

; 503  : 			Dest[DestNum++] = Src[j];

	mov	eax, DWORD PTR _Src$[ebp]
	sub	eax, OFFSET FLAT:_Dot$S15412
	push	ebx
	mov	ebx, DWORD PTR _Frame$[ebp]
	lea	esi, DWORD PTR [edi*4-4]
	mov	DWORD PTR -16+[ebp], eax
$L15422:
	fld	DWORD PTR _Dot$S15412[esi]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L15425
	mov	ecx, DWORD PTR _Src$[ebp]
	mov	eax, DWORD PTR 12+[ebp]
	mov	ecx, DWORD PTR [ecx+esi]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _DestNum$[ebp]
	inc	ecx
	add	eax, 4
	mov	DWORD PTR _DestNum$[ebp], ecx
	mov	DWORD PTR 12+[ebp], eax
$L15425:

; 504  : 		}
; 505  : 		if( Dot[j]*Dot[i]<0.0 )

	fld	DWORD PTR _Dot$S15412[esi]
	lea	ecx, DWORD PTR [edx*4]
	mov	DWORD PTR -8+[ebp], ecx
	fmul	DWORD PTR _Dot$S15412[ecx]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 1
	je	$L15423

; 506  : 		{
; 507  : 			Dest[DestNum] = new(Frame->Viewport->RenDev ? GDynMem : GMem)FTransform;

	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	mov	eax, DWORD PTR [edx+112]
	test	eax, eax
	jne	SHORT $L19311
	mov	edi, DWORD PTR __imp_?GMem@@3VFMemStack@@A
$L19311:
	mov	eax, DWORD PTR [edi+4]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	edx, DWORD PTR [eax+32]
	cmp	edx, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+4], edx
	jbe	SHORT $L19324
	push	8
	push	32					; 00000020H
	mov	ecx, edi
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	eax, DWORD PTR [edi+4]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edi+4], ecx
	mov	ecx, DWORD PTR -8+[ebp]
$L19324:
	mov	edx, DWORD PTR 12+[ebp]
	mov	DWORD PTR [edx], eax

; 508  : 			Dest[DestNum]->Point = Src[j]->Point + (Src[i]->Point-Src[j]->Point) * (Dot[j]/(Dot[j]-Dot[i]));

	mov	edx, DWORD PTR -16+[ebp]
	mov	edx, DWORD PTR _Dot$S15412[edx+ecx]
	mov	ecx, DWORD PTR _Src$[ebp]
	mov	ecx, DWORD PTR [ecx+esi]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR [ecx]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR $T19314[ebp+4]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR -8+[ebp]
	fstp	DWORD PTR $T19314[ebp+8]
	fld	DWORD PTR _Dot$S15412[esi]
	fsub	DWORD PTR _Dot$S15412[edx]
	fdivr	DWORD PTR _Dot$S15412[esi]
	fst	DWORD PTR $T19346[ebp]
	fmulp	ST(1), ST(0)
	fld	DWORD PTR $T19346[ebp]
	fmul	DWORD PTR $T19314[ebp+4]
	fstp	DWORD PTR $T19315[ebp+4]
	fld	DWORD PTR $T19346[ebp]
	fmul	DWORD PTR $T19314[ebp+8]
	fstp	DWORD PTR $T19315[ebp+8]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR $T19316[ebp]
	fld	DWORD PTR [ecx+4]
	fadd	DWORD PTR $T19315[ebp+4]
	mov	edx, DWORD PTR $T19316[ebp]
	fstp	DWORD PTR $T19316[ebp+4]
	fld	DWORD PTR [ecx+8]
	fadd	DWORD PTR $T19315[ebp+8]
	mov	ecx, eax
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR $T19316[ebp+4]
	fstp	DWORD PTR $T19316[ebp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR $T19316[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 509  : 			Dest[DestNum]->Project( Frame );

	fld	DWORD PTR [eax+8]
	fdivr	QWORD PTR $T19299
	fst	DWORD PTR [eax+28]
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(1)
	fmul	DWORD PTR [ebx+240]
	fadd	DWORD PTR [ebx+200]
	fstp	DWORD PTR [eax+16]
	fmul	DWORD PTR [eax+4]
	fmul	DWORD PTR [ebx+240]
	fadd	DWORD PTR [ebx+204]
	fst	DWORD PTR [eax+20]
	fstp	DWORD PTR $T19356[ebp]

; 500  : 	{

	fld	DWORD PTR $T19356[ebp]

; 501  : 		if( Dot[j]>=0.0 )

	fsub	DWORD PTR ?Half@?1??appFloor@@YAHM@Z@4MA ; Half

; 502  : 		{

	fistp	DWORD PTR _I$19360[ebp]

; 509  : 			Dest[DestNum]->Project( Frame );

	mov	ecx, DWORD PTR _I$19360[ebp]

; 510  : 			DestNum++;

	mov	edi, DWORD PTR _SrcNum$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	ecx, DWORD PTR _DestNum$[ebp]
	mov	eax, DWORD PTR 12+[ebp]
	inc	ecx
	add	eax, 4
	mov	DWORD PTR _DestNum$[ebp], ecx
	mov	ecx, DWORD PTR -8+[ebp]
	mov	DWORD PTR 12+[ebp], eax
$L15423:
	inc	edx
	mov	esi, ecx
	cmp	edx, edi
	mov	DWORD PTR _i$[ebp], edx
	jl	$L15422
	pop	ebx
	pop	esi
$L15424:

; 511  : 		}
; 512  : 	}
; 513  : 	return DestNum;

	mov	eax, DWORD PTR _DestNum$[ebp]

; 514  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?Clip@@YAHPAUFSceneNode@@PAPAUFTransform@@1H@Z ENDP	; Clip
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
EXTRN	__imp_??0FVector@@QAE@XZ:NEAR
EXTRN	__imp_?PointRegion@UModel@@QBE?AUFRegion@@PAVAZoneInfo@@VFVector@@@Z:NEAR
EXTRN	?AllocIndexForScreen@FSpanBuffer@@QAEXHHPAVFMemStack@@@Z:NEAR ; FSpanBuffer::AllocIndexForScreen
EXTRN	__imp_??0FPlane@@QAE@XZ:NEAR
EXTRN	__imp_?ComputeRenderCoords@FSceneNode@@QAEXAAVFVector@@AAVFRotation@@@Z:NEAR
EXTRN	__imp_?GSceneMem@@3VFMemStack@@A:BYTE
xdata$x	SEGMENT
$T19497	DD	019930520H
	DD	02H
	DD	FLAT:$T19503
	DD	01H
	DD	FLAT:$T19504
	DD	2 DUP(00H)
	ORG $+4
$T19503	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T19504	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T19505
	ORG $+4
$T19505	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffecH
	DD	FLAT:$L19376
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L19377
xdata$x	ENDS
_TEXT	SEGMENT
$T19494 = 8
__$EHRec$ = -16
_Viewport$ = 8
_Location$ = 12
_Rotation$ = 24
_Err$15527 = -20
$T19369 = -36
$T19373 = -32
$T19374 = 8
?CreateMasterFrame@URender@@UAEPAUFSceneNode@@PAVUViewport@@VFVector@@VFRotation@@PAUFScreenBounds@@@Z PROC NEAR ; URender::CreateMasterFrame

; 629  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L19502
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 20					; 00000014H

; 630  : 	guard(URender::CreateMasterFrame);
; 631  : 
; 632  : 	// Set base info.
; 633  : 	FSceneNode* Frame	= new(GSceneMem)FSceneNode;

	mov	ecx, DWORD PTR __imp_?GSceneMem@@3VFMemStack@@A
	push	ebx
	push	esi
	push	edi
	mov	esi, DWORD PTR [ecx+4]
	lea	edi, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+8]
	add	esi, 7
	and	esi, -8					; fffffff8H
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	lea	eax, DWORD PTR [esi+384]
	cmp	eax, edx
	mov	DWORD PTR [edi], eax
	jbe	SHORT $L19385
	push	8
	push	384					; 00000180H
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	esi, DWORD PTR [edi]
	mov	ecx, DWORD PTR __imp_?GSceneMem@@3VFMemStack@@A
	add	esi, 7
	and	esi, -8					; fffffff8H
	lea	eax, DWORD PTR [esi+384]
	mov	DWORD PTR [edi], eax
$L19385:
	cmp	esi, ebx
	je	SHORT $L19367
	mov	ecx, DWORD PTR __imp_??0FVector@@QAE@XZ
	lea	edx, DWORD PTR [esi+272]
	push	ecx
	push	4
	push	12					; 0000000cH
	push	edx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	eax, DWORD PTR __imp_??0FPlane@@QAE@XZ
	lea	ecx, DWORD PTR [esi+320]
	push	eax
	push	4
	push	16					; 00000010H
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	ecx, DWORD PTR __imp_?GSceneMem@@3VFMemStack@@A
	jmp	SHORT $L19368
$L19367:
	xor	esi, esi
$L19368:

; 634  : 	Frame->Viewport		= Viewport;

	mov	edi, DWORD PTR _Viewport$[ebp]

; 635  : 	Frame->X			= Viewport->SizeX;
; 636  : 	Frame->Y			= Viewport->SizeY;
; 637  : 	Frame->XB			= 0;
; 638  : 	Frame->YB			= 0;
; 639  : 	Frame->Level		= Viewport->Actor->XLevel;
; 640  : 	Frame->Parent		= NULL;
; 641  : 	Frame->Sibling		= NULL;
; 642  : 	Frame->Child		= NULL;
; 643  : 	Frame->iSurf		= INDEX_NONE;
; 644  : 	Frame->Recursion	= 0;
; 645  : 	Frame->Mirror		= 1.0;
; 646  : 	Frame->ZFactor		= 1.0;
; 647  : 	Frame->RZFactor		= 1.0;
; 648  : 	Frame->Recursion	= 0;
; 649  : 	Frame->NearClip		= FPlane(0,0,0,0);

	mov	DWORD PTR $T19369[ebp], 0
	mov	DWORD PTR $T19369[ebp+4], 0
	mov	DWORD PTR $T19369[ebp+8], 0
	mov	edx, DWORD PTR [edi+128]
	mov	eax, DWORD PTR [edi+132]
	mov	DWORD PTR [esi+176], edx
	mov	edx, DWORD PTR [edi+92]
	mov	DWORD PTR [esi+180], eax
	mov	DWORD PTR [esi+184], ebx
	mov	eax, DWORD PTR [edx+96]
	lea	edx, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+4], eax
	mov	eax, 1065353216				; 3f800000H
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+168], eax
	mov	DWORD PTR [esi+172], eax
	mov	eax, DWORD PTR $T19369[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR $T19369[ebp+4]
	mov	DWORD PTR [esi+188], ebx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR $T19369[ebp+8]
	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+28], ebx
	mov	DWORD PTR $T19369[ebp+12], 0
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR $T19369[ebp+12]

; 650  : 	Frame->Draw[0]		= NULL;

	mov	DWORD PTR [esi+152], ebx

; 651  : 	Frame->Draw[1]		= NULL;

	mov	DWORD PTR [esi+156], ebx

; 652  : 	Frame->Draw[2]		= NULL;

	mov	DWORD PTR [esi+160], ebx

; 653  : 	Frame->Sprite		= NULL;

	mov	DWORD PTR [esi+164], ebx

; 654  : 	Frame->Span			= new(GSceneMem)FSpanBuffer;

	lea	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+12], eax
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+20], -1
	mov	eax, DWORD PTR [ebx]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	edx, DWORD PTR [eax+36]
	cmp	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [ebx], edx
	jbe	SHORT $L19436
	push	8
	push	36					; 00000024H
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	eax, DWORD PTR [ebx]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [ebx], ecx
	mov	ecx, DWORD PTR __imp_?GSceneMem@@3VFMemStack@@A
$L19436:

; 655  : 	Frame->Span->AllocIndexForScreen( Viewport->SizeX, Viewport->SizeY, &GSceneMem );

	mov	edx, DWORD PTR [edi+132]
	push	ecx
	mov	ecx, DWORD PTR [edi+128]
	push	edx
	push	ecx
	mov	ecx, eax
	mov	DWORD PTR [esi+148], eax
	call	?AllocIndexForScreen@FSpanBuffer@@QAEXHHPAVFMemStack@@@Z ; FSpanBuffer::AllocIndexForScreen

; 656  : 
; 657  : 	// Compute coords.
; 658  : 	Frame->ComputeRenderCoords( Location, Rotation );

	lea	edx, DWORD PTR _Rotation$[ebp]
	lea	eax, DWORD PTR _Location$[ebp]
	push	edx
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?ComputeRenderCoords@FSceneNode@@QAEXAAVFVector@@AAVFRotation@@@Z

; 659  : 
; 660  : 	// Compute zone.
; 661  : 	Frame->ZoneNumber = Viewport->Actor->XLevel->Model->PointRegion( Viewport->Actor->XLevel->GetLevelInfo(), Frame->Coords.Origin ).ZoneNumber;

	mov	ecx, DWORD PTR [edi+92]
	mov	eax, DWORD PTR [ecx+96]
	mov	DWORD PTR $T19494[ebp], eax
	mov	ebx, DWORD PTR [eax+88]
	cmp	DWORD PTR [ebx], 0
	jne	SHORT $L19486
	push	223					; 000000dfH
	push	OFFSET FLAT:??_C@_0EF@LODM@Check?5failed?3?5Actors?$CI0?$CJ?5?$FLFile?3?4?4@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L19486:
	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR __imp_?StaticClass@ALevelInfo@@2PAVUClass@@A
	mov	eax, DWORD PTR [edx+12]
$L19475:
	test	eax, eax
	je	SHORT $L19480
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $L19487
	mov	eax, DWORD PTR [eax+96]
	jmp	SHORT $L19475
$L19480:
	push	224					; 000000e0H
	push	OFFSET FLAT:??_C@_0GD@NDIK@Check?5failed?3?5Actors?$CI0?$CJ?9?$DOIsA?$CIALe@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L19487:
	lea	eax, DWORD PTR [esi+52]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T19494[ebp]
	mov	edx, DWORD PTR [ecx+88]
	lea	ecx, DWORD PTR $T19373[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [edi+92]
	push	eax
	push	ecx
	mov	eax, DWORD PTR [edx+96]
	mov	ecx, DWORD PTR [eax+192]
	call	DWORD PTR __imp_?PointRegion@UModel@@QBE?AUFRegion@@PAVAZoneInfo@@VFVector@@@Z
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+8]

; 662  : 
; 663  : 	return Frame;

	mov	eax, esi
	mov	DWORD PTR [esi+24], ecx

; 665  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$L19376:

; 664  : 	unguard;

	mov	edx, DWORD PTR _Err$15527[ebp]
	lea	eax, DWORD PTR $T19374[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	eax
	mov	DWORD PTR $T19374[ebp], edx
	call	__CxxThrowException@8
	mov	eax, $L15519
	ret	0
$L19377:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??CreateMasterFrame@URender@@UAEPAUFSceneNode@@PAVUViewport@@VFVector@@VFRotation@@PAUFScreenBounds@@@Z@4PBDB$S15518
	push	OFFSET FLAT:$SG15529
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L15519
	ret	0
$L15519:

; 665  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
text$x	SEGMENT
$L19502:
	mov	eax, OFFSET FLAT:$T19497
	jmp	___CxxFrameHandler
text$x	ENDS
?CreateMasterFrame@URender@@UAEPAUFSceneNode@@PAVUViewport@@VFVector@@VFRotation@@PAUFScreenBounds@@@Z ENDP ; URender::CreateMasterFrame
EXTRN	?AllocIndex@FSpanBuffer@@QAEXHHPAVFMemStack@@@Z:NEAR ; FSpanBuffer::AllocIndex
EXTRN	?MergeWith@FSpanBuffer@@QAEXABV1@@Z:NEAR	; FSpanBuffer::MergeWith
EXTRN	__imp_?ComputeRenderSize@FSceneNode@@QAEXXZ:NEAR
xdata$x	SEGMENT
$T19631	DD	019930520H
	DD	02H
	DD	FLAT:$T19639
	DD	01H
	DD	FLAT:$T19640
	DD	2 DUP(00H)
	ORG $+4
$T19639	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T19640	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T19641
	ORG $+4
$T19641	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffe0H
	DD	FLAT:$L19515
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L19516
xdata$x	ENDS
_TEXT	SEGMENT
$T19512 = -140
$T19513 = 32
$T19529 = -20
$T19535 = -20
$T19536 = -24
$T19543 = -24
$T19549 = -24
$T19550 = -20
$T19613 = -80
$T19614 = -68
$T19615 = -56
$T19616 = -92
$T19617 = -44
__$EHRec$ = -16
_Parent$ = 8
_Span$ = 12
_Level$ = 16
_iSurf$ = 20
_iZone$ = 24
_Mirror$ = 28
_NearClip$ = 32
_Coords$ = 36
_ZFactor$ = 40
_Bounds$ = 44
_Err$15574 = -32
?CreateChildFrame@URender@@UAEPAUFSceneNode@@PAU2@PAVFSpanBuffer@@PAVULevel@@HHMABVFPlane@@ABVFCoords@@MPAUFScreenBounds@@@Z PROC NEAR ; URender::CreateChildFrame

; 683  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L19638
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 124				; 0000007cH

; 684  : 	guard(URender::CreateChildFrame);
; 685  : 
; 686  : 	// See if the scene frame already exists.
; 687  : 	for( FSceneNode* Frame=Parent->Child; Frame; Frame=Frame->Sibling )

	mov	ecx, DWORD PTR _Parent$[ebp]
	mov	edx, DWORD PTR _iZone$[ebp]
	push	ebx
	push	esi
	mov	ebx, DWORD PTR [ecx+16]
	push	edi
	mov	edi, DWORD PTR _iSurf$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$L15550:
	test	ebx, ebx
	je	$L19634

; 688  : 	{
; 689  : 		if
; 690  : 		(	Frame->Level==Level
; 691  : 		&&	Frame->iSurf==iSurf
; 692  : 		&&	Frame->Parent==Parent
; 693  : 		&&	Frame->NearClip==NearClip
; 694  : 		&&	Frame->ZoneNumber==iZone )

	mov	eax, DWORD PTR _Level$[ebp]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, eax
	jne	$L15551
	cmp	DWORD PTR [ebx+20], edi
	jne	$L15551
	cmp	DWORD PTR [ebx+8], ecx
	jne	$L15551
	mov	esi, DWORD PTR _NearClip$[ebp]
	fld	DWORD PTR [ebx+36]
	fcomp	DWORD PTR [esi]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	$L15551
	fld	DWORD PTR [ebx+40]
	fcomp	DWORD PTR [esi+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	$L15551
	fld	DWORD PTR [ebx+44]
	fcomp	DWORD PTR [esi+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	$L15551
	fld	DWORD PTR [ebx+48]
	fcomp	DWORD PTR [esi+12]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	$L15551
	cmp	DWORD PTR [ebx+24], edx
	jne	$L15551

; 695  : 		{
; 696  : 			// Merge with existing scene frame.
; 697  : 			Frame->Span->MergeWith( *Span );

	mov	ecx, DWORD PTR _Span$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [ebx+148]
	call	?MergeWith@FSpanBuffer@@QAEXABV1@@Z	; FSpanBuffer::MergeWith

; 698  : 			if( Bounds )

	mov	ecx, DWORD PTR _Bounds$[ebp]
	test	ecx, ecx
	je	$L15552

; 699  : 			{
; 700  : 				Frame->PrjXM = Max( Frame->PrjXM, (Bounds->MinX - Frame->FX2)*(-Frame->RProj.Z) );

	fld	DWORD PTR [ebx+252]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [ebx+216]
	fxch	ST(1)
	fchs
	fxch	ST(1)
	fld	DWORD PTR [ebx+256]
	fxch	ST(1)
	fmul	ST(0), ST(2)
	fld	ST(1)
	fxch	ST(1)
	fstp	DWORD PTR $T19529[ebp]
	fcomp	DWORD PTR $T19529[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L19526
	fstp	ST(0)
	fld	DWORD PTR $T19529[ebp]
$L19526:

; 701  : 				Frame->PrjXP = Max( Frame->PrjXP, (Bounds->MaxX - Frame->FX2)*(+Frame->RProj.Z) );

	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR [ebx+216]
	mov	edx, DWORD PTR [ebx+260]
	mov	DWORD PTR $T19535[ebp], edx
	fmul	DWORD PTR [ebx+252]
	fld	DWORD PTR $T19535[ebp]
	fxch	ST(1)
	fstp	DWORD PTR $T19536[ebp]
	fcomp	DWORD PTR $T19536[ebp]
	fstp	DWORD PTR [ebx+256]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L19532
	fld	DWORD PTR $T19535[ebp]
	jmp	SHORT $L19533
$L19532:
	fld	DWORD PTR $T19536[ebp]
$L19533:

; 702  : 				Frame->PrjYM = Max( Frame->PrjYM, (Bounds->MinY - Frame->FY2)*(-Frame->RProj.Z) );

	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR [ebx+220]
	fld	DWORD PTR [ebx+264]
	fxch	ST(1)
	fmul	ST(0), ST(3)
	fxch	ST(1)
	fstp	ST(3)
	fld	ST(2)
	fxch	ST(2)
	fstp	DWORD PTR [ebx+260]
	fstp	DWORD PTR $T19543[ebp]
	fcomp	DWORD PTR $T19543[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L19540
	fstp	ST(0)
	fld	DWORD PTR $T19543[ebp]
$L19540:

; 703  : 				Frame->PrjYP = Max( Frame->PrjYP, (Bounds->MaxY - Frame->FY2)*(+Frame->RProj.Z) );

	fld	DWORD PTR [ecx+12]
	fsub	DWORD PTR [ebx+220]
	mov	eax, DWORD PTR [ebx+268]
	mov	DWORD PTR $T19549[ebp], eax
	fmul	DWORD PTR [ebx+252]
	fld	DWORD PTR $T19549[ebp]
	fxch	ST(1)
	fstp	DWORD PTR $T19550[ebp]
	fcomp	DWORD PTR $T19550[ebp]
	fstp	DWORD PTR [ebx+264]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L19546
	fld	DWORD PTR $T19549[ebp]
	fstp	DWORD PTR [ebx+268]

; 704  : 			}
; 705  : 			break;

	jmp	SHORT $L15552

; 703  : 				Frame->PrjYP = Max( Frame->PrjYP, (Bounds->MaxY - Frame->FY2)*(+Frame->RProj.Z) );

$L19546:
	fld	DWORD PTR $T19550[ebp]
	fstp	DWORD PTR [ebx+268]

; 704  : 			}
; 705  : 			break;

	jmp	SHORT $L15552
$L15551:

; 684  : 	guard(URender::CreateChildFrame);
; 685  : 
; 686  : 	// See if the scene frame already exists.
; 687  : 	for( FSceneNode* Frame=Parent->Child; Frame; Frame=Frame->Sibling )

	mov	ebx, DWORD PTR [ebx+12]
	jmp	$L15550
$L19634:
	mov	esi, DWORD PTR _NearClip$[ebp]
$L15552:

; 706  : 		}
; 707  : 	}
; 708  : 	if( Frame == NULL )

	test	ebx, ebx
	jne	$L15567

; 709  : 	{
; 710  : 		// Make a new scene frame.
; 711  : 		Frame				= new(GSceneMem)FSceneNode(*Parent);

	mov	edx, DWORD PTR __imp_?GSceneMem@@3VFMemStack@@A
	mov	ebx, DWORD PTR [edx+4]
	lea	edi, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+8]
	add	ebx, 7
	and	ebx, -8					; fffffff8H
	lea	eax, DWORD PTR [ebx+384]
	cmp	eax, ecx
	mov	DWORD PTR [edi], eax
	jbe	SHORT $L19557
	push	8
	push	384					; 00000180H
	mov	ecx, edx
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	ebx, DWORD PTR [edi]
	mov	edx, DWORD PTR __imp_?GSceneMem@@3VFMemStack@@A
	add	ebx, 7
	and	ebx, -8					; fffffff8H
	lea	ecx, DWORD PTR [ebx+384]
	mov	DWORD PTR [edi], ecx
$L19557:
	test	ebx, ebx
	je	SHORT $L19507
	mov	esi, DWORD PTR _Parent$[ebp]
	mov	ecx, 96					; 00000060H
	mov	edi, ebx
	rep movsd
	mov	esi, DWORD PTR _NearClip$[ebp]
	jmp	SHORT $L19508
$L19507:
	xor	ebx, ebx
$L19508:

; 712  : 		Frame->Span        	= new(GSceneMem)FSpanBuffer;

	mov	eax, DWORD PTR [edx+4]
	lea	edi, DWORD PTR [edx+4]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	ecx, DWORD PTR [eax+36]
	cmp	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [edi], ecx
	jbe	SHORT $L19567
	push	8
	push	36					; 00000024H
	mov	ecx, edx
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	eax, DWORD PTR [edi]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	edx, DWORD PTR [eax+36]
	mov	DWORD PTR [edi], edx
$L19567:

; 713  : 		Frame->Viewport     = Parent->Viewport;
; 714  : 		Frame->Level		= Level;
; 715  : 		Frame->iSurf		= iSurf;
; 716  : 		Frame->ZoneNumber	= iZone;
; 717  : 		Frame->Recursion	= Parent->Recursion+1;
; 718  : 		Frame->Mirror		= Mirror;
; 719  : 		Frame->ZFactor		= ZFactor;
; 720  : 		Frame->RZFactor		= 1.0/ZFactor;

	fld	DWORD PTR _ZFactor$[ebp]

; 721  : 		Frame->NearClip		= NearClip;
; 722  : 		Frame->Coords		= Coords;
; 723  : 		Frame->Uncoords		= Coords.Transpose(); //!!inverse() - assumes orthogonal.

	lea	ecx, DWORD PTR [ebx+36]
	mov	esi, DWORD PTR [esi]
	fdivr	QWORD PTR $T19299
	mov	edx, ecx
	mov	ecx, DWORD PTR _Parent$[ebp]
	mov	DWORD PTR -24+[ebp], edx
	mov	DWORD PTR [ebx+148], eax
	mov	edx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR -20+[ebp], ecx
	mov	ecx, DWORD PTR -24+[ebp]
	mov	eax, DWORD PTR -20+[ebp]
	inc	edx
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR _NearClip$[ebp]
	mov	DWORD PTR [ebx], eax
	mov	eax, DWORD PTR _Level$[ebp]
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [ebx+4], eax
	mov	eax, DWORD PTR _iSurf$[ebp]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR _NearClip$[ebp]
	mov	DWORD PTR [ebx+20], eax
	mov	eax, DWORD PTR _iZone$[ebp]
	mov	DWORD PTR -24+[ebp], edx
	mov	esi, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _NearClip$[ebp]
	mov	DWORD PTR [ecx+8], esi
	mov	DWORD PTR [ebx+24], eax
	mov	eax, DWORD PTR -24+[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR -28+[ebp], ecx
	mov	DWORD PTR [ebx+28], eax
	mov	eax, DWORD PTR -28+[ebp]
	mov	esi, DWORD PTR _Coords$[ebp]
	lea	edi, DWORD PTR [ebx+52]
	mov	ecx, 12					; 0000000cH
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _Coords$[ebp]
	mov	edx, DWORD PTR _ZFactor$[ebp]
	rep movsd
	mov	ecx, DWORD PTR _Mirror$[ebp]
	mov	DWORD PTR [ebx+168], edx
	mov	DWORD PTR [ebx+32], ecx
	fld	DWORD PTR [eax+12]
	fld	DWORD PTR [eax+20]
	fld	DWORD PTR [eax+24]
	fld	DWORD PTR [eax+32]

; 724  : 		Frame->Draw[0]		= NULL;
; 725  : 		Frame->Draw[1]		= NULL;
; 726  : 		Frame->Draw[2]		= NULL;
; 727  : 		Frame->Sprite		= NULL;
; 728  : 
; 729  : 		// Insert into linked list of scene frames.
; 730  : 		Frame->Parent		= Parent;
; 731  : 		Frame->Child		= NULL;
; 732  : 		Frame->Sibling		= Parent->Child;
; 733  : 		Parent->Child		= Frame;
; 734  : 
; 735  : 		// Compute rendering information.
; 736  : 		//!!clip to parent
; 737  : 		Frame->ComputeRenderSize();
; 738  : 		if( Bounds )
; 739  : 		{
; 740  : 			Frame->PrjXM = (Bounds->MinX - Frame->FX2)*(-Frame->RProj.Z);
; 741  : 			Frame->PrjXP = (Bounds->MaxX - Frame->FX2)*(+Frame->RProj.Z);
; 742  : 			Frame->PrjYM = (Bounds->MinY - Frame->FY2)*(-Frame->RProj.Z);
; 743  : 			Frame->PrjYP = (Bounds->MaxY - Frame->FY2)*(+Frame->RProj.Z);
; 744  : 		}
; 745  : 
; 746  : 		// Make span buffer.
; 747  : 		Frame->Span->AllocIndex( 0, 0, &GSceneMem );
; 748  : 		Frame->Span->MergeWith( *Span );
; 749  : 	}
; 750  : 	return Frame;

	fxch	ST(3)
	fmul	DWORD PTR [eax]
	fld	DWORD PTR [eax+16]
	fxch	ST(5)
	fstp	DWORD PTR [ebx+172]
	fxch	ST(2)
	fmul	DWORD PTR [eax+8]
	fld	DWORD PTR [eax+28]
	fld	DWORD PTR [eax+20]
	fstp	DWORD PTR $T19613[ebp]
	fld	DWORD PTR [eax+32]
	fstp	DWORD PTR $T19613[ebp+4]
	fld	DWORD PTR [eax+44]
	fstp	DWORD PTR $T19613[ebp+8]
	fld	DWORD PTR [eax+16]
	fstp	DWORD PTR $T19614[ebp]
	fld	DWORD PTR [eax+28]
	fstp	DWORD PTR $T19614[ebp+4]
	fld	DWORD PTR [eax+40]
	fstp	DWORD PTR $T19614[ebp+8]
	fld	DWORD PTR [eax+12]
	fstp	DWORD PTR $T19615[ebp]
	fld	DWORD PTR [eax+24]
	fstp	DWORD PTR $T19615[ebp+4]
	fld	DWORD PTR [eax+36]
	fstp	DWORD PTR $T19615[ebp+8]
	fxch	ST(1)
	faddp	ST(3), ST(0)
	fxch	ST(1)
	fmul	DWORD PTR [eax]
	fxch	ST(3)
	fmul	DWORD PTR [eax+8]
	fxch	ST(4)
	fmul	DWORD PTR [eax+4]
	fxch	ST(4)
	faddp	ST(3), ST(0)
	lea	edi, DWORD PTR [ebx+100]
	lea	esi, DWORD PTR $T19512[ebp]
	fmul	DWORD PTR [eax+4]
	fxch	ST(3)
	faddp	ST(1), ST(0)
	fxch	ST(2)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T19616[ebp+4]
	fld	DWORD PTR [eax+36]
	fmul	DWORD PTR [eax]
	fld	DWORD PTR [eax+44]
	fmul	DWORD PTR [eax+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+40]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T19616[ebp+8]
	fchs
	fstp	DWORD PTR $T19617[ebp]
	fld	DWORD PTR $T19616[ebp+4]
	fchs
	fstp	DWORD PTR $T19617[ebp+4]
	fld	DWORD PTR $T19616[ebp+8]
	mov	ecx, DWORD PTR $T19617[ebp+4]
	mov	eax, DWORD PTR $T19617[ebp]
	fchs
	fstp	DWORD PTR $T19617[ebp+8]
	mov	edx, DWORD PTR $T19617[ebp+8]
	mov	DWORD PTR $T19512[ebp+4], ecx
	mov	ecx, DWORD PTR $T19615[ebp+4]
	mov	DWORD PTR $T19512[ebp], eax
	mov	eax, DWORD PTR $T19615[ebp]
	mov	DWORD PTR $T19512[ebp+8], edx
	mov	edx, DWORD PTR $T19615[ebp+8]
	mov	DWORD PTR $T19512[ebp+16], ecx
	mov	ecx, DWORD PTR $T19614[ebp+4]
	mov	DWORD PTR $T19512[ebp+12], eax
	mov	eax, DWORD PTR $T19614[ebp]
	mov	DWORD PTR $T19512[ebp+20], edx
	mov	edx, DWORD PTR $T19614[ebp+8]
	mov	DWORD PTR $T19512[ebp+28], ecx
	mov	ecx, DWORD PTR $T19613[ebp+4]
	mov	DWORD PTR $T19512[ebp+24], eax
	mov	eax, DWORD PTR $T19613[ebp]
	mov	DWORD PTR $T19512[ebp+32], edx
	mov	edx, DWORD PTR $T19613[ebp+8]
	mov	DWORD PTR $T19512[ebp+40], ecx
	mov	DWORD PTR $T19512[ebp+36], eax
	mov	eax, DWORD PTR _Parent$[ebp]
	mov	ecx, 12					; 0000000cH
	mov	DWORD PTR $T19512[ebp+44], edx
	rep movsd
	mov	ecx, DWORD PTR [eax+16]
	xor	esi, esi
	mov	DWORD PTR [ebx+152], esi
	mov	DWORD PTR [ebx+156], esi
	mov	DWORD PTR [ebx+160], esi
	mov	DWORD PTR [ebx+164], esi
	mov	DWORD PTR [ebx+8], eax
	mov	DWORD PTR [ebx+16], esi
	mov	DWORD PTR [ebx+12], ecx
	mov	DWORD PTR [eax+16], ebx
	mov	ecx, ebx
	call	DWORD PTR __imp_?ComputeRenderSize@FSceneNode@@QAEXXZ
	mov	eax, DWORD PTR _Bounds$[ebp]
	cmp	eax, esi
	je	SHORT $L15573
	fld	DWORD PTR [eax]
	fld	DWORD PTR [eax+4]
	fld	DWORD PTR [eax+8]
	fld	DWORD PTR [eax+12]
	fld	DWORD PTR [ebx+252]
	fxch	ST(4)
	fsub	DWORD PTR [ebx+216]
	fxch	ST(2)
	fsub	DWORD PTR [ebx+216]
	fxch	ST(3)
	fsub	DWORD PTR [ebx+220]
	fxch	ST(1)
	fsub	DWORD PTR [ebx+220]
	fld	DWORD PTR [ebx+252]
	fxch	ST(5)
	fchs
	fld	DWORD PTR [ebx+252]
	fxch	ST(4)
	fmul	ST(0), ST(1)
	fstp	DWORD PTR [ebx+256]
	fxch	ST(2)
	fmul	ST(0), ST(2)
	fxch	ST(5)
	fmulp	ST(4), ST(0)
	fxch	ST(2)
	fmulp	ST(2), ST(0)
	fxch	ST(3)
	fstp	DWORD PTR [ebx+264]
	fxch	ST(1)
	fstp	DWORD PTR [ebx+260]
	fstp	DWORD PTR [ebx+268]
	fstp	ST(0)
$L15573:
	mov	edx, DWORD PTR __imp_?GSceneMem@@3VFMemStack@@A
	mov	ecx, DWORD PTR [ebx+148]
	push	edx
	push	esi
	push	esi
	call	?AllocIndex@FSpanBuffer@@QAEXHHPAVFMemStack@@@Z ; FSpanBuffer::AllocIndex
	mov	eax, DWORD PTR _Span$[ebp]
	mov	ecx, DWORD PTR [ebx+148]
	push	eax
	call	?MergeWith@FSpanBuffer@@QAEXABV1@@Z	; FSpanBuffer::MergeWith
$L15567:
	mov	eax, ebx
$L15545:

; 752  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
$L19515:

; 751  : 	unguard;

	mov	ecx, DWORD PTR _Err$15574[ebp]
	lea	edx, DWORD PTR $T19513[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	edx
	mov	DWORD PTR $T19513[ebp], ecx
	call	__CxxThrowException@8
	mov	eax, $L15545
	ret	0
$L19516:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??CreateChildFrame@URender@@UAEPAUFSceneNode@@PAU3@PAVFSpanBuffer@@PAVULevel@@HHMABVFPlane@@ABVFCoords@@MPAUFScreenBounds@@@Z@4PBDB$S15547
	push	OFFSET FLAT:$SG15576
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L15545
	ret	0
_TEXT	ENDS
text$x	SEGMENT
$L19638:
	mov	eax, OFFSET FLAT:$T19631
	jmp	___CxxFrameHandler
text$x	ENDS
?CreateChildFrame@URender@@UAEPAUFSceneNode@@PAU2@PAVFSpanBuffer@@PAVULevel@@HHMABVFPlane@@ABVFCoords@@MPAUFScreenBounds@@@Z ENDP ; URender::CreateChildFrame
PUBLIC	?Add@?$TArray@H@@QAEHH@Z			; TArray<int>::Add
PUBLIC	?OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z	; URender::OccludeBsp
PUBLIC	??_C@_0FH@FKFD@Check?5failed?3?5ActiveChunks?$DM?$DNMem?9@ ; `string'
EXTRN	__imp_?appMemcmp@@YAHPBX0H@Z:NEAR
EXTRN	__imp_?Pop@FMemMark@@QAEXXZ:NEAR
;	COMDAT ??_C@_0FH@FKFD@Check?5failed?3?5ActiveChunks?$DM?$DNMem?9@
; File ..\..\Core\Inc\UnCache.h
_DATA	SEGMENT
??_C@_0FH@FKFD@Check?5failed?3?5ActiveChunks?$DM?$DNMem?9@ DB 'Check fail'
	DB	'ed: ActiveChunks<=Mem->ActiveChunks [File:..\..\Core\Inc\UnMe'
	DB	'm.h] [Line: %i]', 00H			; `string'
_DATA	ENDS
xdata$x	SEGMENT
$T19711	DD	019930520H
	DD	02H
	DD	FLAT:$T19722
	DD	01H
	DD	FLAT:$T19723
	DD	2 DUP(00H)
	ORG $+4
$T19722	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T19723	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T19724
	ORG $+4
$T19724	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffff4cH
	DD	FLAT:$L19665
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L19666
xdata$x	ENDS
_TEXT	SEGMENT
$T19643 = -108
$T19645 = -84
$T19647 = -144
$T19649 = -120
$T19651 = -132
$T19652 = -96
$T19663 = 8
$T19668 = -36
$T19672 = -40
__$EHRec$ = -16
_Viewport$ = 8
_iSurfs$ = 12
_this$ = -24
_i$15657 = -20
_MemMark$15661 = -56
_DynMemMark$15662 = -176
_SceneMark$15663 = -72
_VectorMark$15664 = -160
_i$15677 = -28
_Draw$15681 = 12
_Err$15685 = -180
?GetVisibleSurfs@URender@@UAEXPAVUViewport@@AAV?$TArray@H@@@Z PROC NEAR ; URender::GetVisibleSurfs

; 841  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L19721
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 164				; 000000a4H
	mov	DWORD PTR _this$[ebp], ecx
	push	ebx

; 842  : 	guard(URender::GetVisibleSurfs);
; 843  : 
; 844  : 	// Try six views.
; 845  : 	for( INT i=0; i<6; i++ )

	mov	ebx, DWORD PTR _iSurfs$[ebp]
	push	esi
	xor	ecx, ecx
	push	edi
	xor	edx, edx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __$EHRec$[ebp+12], ecx
	mov	DWORD PTR _i$15657[ebp], edx
$L15658:
	cmp	edx, 6
	jge	$L15660

; 846  : 	{
; 847  : 		// Set up rendering.
; 848  : 		FMemMark MemMark(GMem);

	mov	eax, DWORD PTR __imp_?GMem@@3VFMemStack@@A

; 849  : 		FMemMark DynMemMark(GDynMem);
; 850  : 		FMemMark SceneMark(GSceneMem);
; 851  : 		FMemMark VectorMark(VectorMem);
; 852  : 		Viewport->Actor->ViewRotation
; 853  : 		=	i==0 ? FRotation(0x4000,0     ,0)
; 854  : 		:	i==1 ? FRotation(0xC000,0     ,0)
; 855  : 		:	i==2 ? FRotation(0     ,0     ,0)
; 856  : 		:	i==3 ? FRotation(0     ,0x8000,0)
; 857  : 		:	i==4 ? FRotation(0     ,0xC000,0)
; 858  : 		:          FRotation(0     ,0x4000,0);

	cmp	edx, ecx
	mov	DWORD PTR $T19668[ebp], eax
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR _MemMark$15661[ebp+4], esi
	mov	esi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _MemMark$15661[ebp+8], esi
	mov	DWORD PTR _MemMark$15661[ebp+12], eax
	mov	eax, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	mov	DWORD PTR _DynMemMark$15662[ebp], eax
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR _DynMemMark$15662[ebp+4], esi
	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR _DynMemMark$15662[ebp+8], esi
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _DynMemMark$15662[ebp+12], eax
	mov	eax, DWORD PTR __imp_?GSceneMem@@3VFMemStack@@A
	mov	DWORD PTR $T19672[ebp], eax
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR _SceneMark$15663[ebp+4], esi
	mov	esi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR _SceneMark$15663[ebp+8], esi
	mov	DWORD PTR _SceneMark$15663[ebp+12], eax
	mov	eax, DWORD PTR ?VectorMem@URender@@2VFMemStack@@A+4
	mov	DWORD PTR _VectorMark$15664[ebp+4], eax
	mov	eax, DWORD PTR ?VectorMem@URender@@2VFMemStack@@A+8
	mov	DWORD PTR _VectorMark$15664[ebp+8], eax
	mov	eax, DWORD PTR ?VectorMem@URender@@2VFMemStack@@A+20
	mov	DWORD PTR _VectorMark$15664[ebp], OFFSET FLAT:?VectorMem@URender@@2VFMemStack@@A ; URender::VectorMem
	mov	DWORD PTR _VectorMark$15664[ebp+12], eax
	jne	SHORT $L19661
	mov	DWORD PTR $T19643[ebp+4], ecx
	mov	DWORD PTR $T19643[ebp+8], ecx
	mov	DWORD PTR $T19643[ebp], 16384		; 00004000H
	lea	ecx, DWORD PTR $T19643[ebp]
	jmp	SHORT $L19660
$L19661:
	cmp	edx, 1
	jne	SHORT $L19659
	mov	DWORD PTR $T19645[ebp+4], ecx
	mov	DWORD PTR $T19645[ebp+8], ecx
	mov	DWORD PTR $T19645[ebp], 49152		; 0000c000H
	lea	ecx, DWORD PTR $T19645[ebp]
	jmp	SHORT $L19660
$L19659:
	cmp	edx, 2
	jne	SHORT $L19657
	mov	DWORD PTR $T19647[ebp], ecx
	mov	DWORD PTR $T19647[ebp+4], ecx
	mov	DWORD PTR $T19647[ebp+8], ecx
	lea	eax, DWORD PTR $T19647[ebp]
	jmp	SHORT $L19654
$L19657:
	cmp	edx, 3
	jne	SHORT $L19655
	mov	DWORD PTR $T19649[ebp], ecx
	mov	DWORD PTR $T19649[ebp+4], 32768		; 00008000H
	mov	DWORD PTR $T19649[ebp+8], ecx
	lea	eax, DWORD PTR $T19649[ebp]
	jmp	SHORT $L19654
$L19655:
	cmp	edx, 4
	jne	SHORT $L19653
	mov	DWORD PTR $T19651[ebp], ecx
	mov	DWORD PTR $T19651[ebp+4], 49152		; 0000c000H
	mov	DWORD PTR $T19651[ebp+8], ecx
	lea	eax, DWORD PTR $T19651[ebp]
	jmp	SHORT $L19654
$L19653:
	mov	DWORD PTR $T19652[ebp], ecx
	mov	DWORD PTR $T19652[ebp+4], 16384		; 00004000H
	mov	DWORD PTR $T19652[ebp+8], ecx
	lea	eax, DWORD PTR $T19652[ebp]
$L19654:
	mov	ecx, eax
$L19660:
	mov	edx, DWORD PTR _Viewport$[ebp]
	mov	edi, DWORD PTR [ecx]

; 859  : 		FSceneNode* Frame = CreateMasterFrame( Viewport, Viewport->Actor->Location, Viewport->Actor->ViewRotation, NULL );

	push	0
	mov	edx, DWORD PTR [edx+92]
	sub	esp, 12					; 0000000cH
	lea	eax, DWORD PTR [edx+556]
	add	edx, 204				; 000000ccH
	mov	esi, eax
	mov	DWORD PTR [esi], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR [ecx]
	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx]
	mov	ecx, esp
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _Viewport$[ebp]
	mov	DWORD PTR [ecx+8], edx
	push	eax
	mov	ecx, esi
	call	DWORD PTR [edi+116]
	mov	edi, eax

; 860  : 
; 861  : 		// Add all visible nodes.
; 862  : 		OccludeBsp( Frame );

	mov	ecx, esi
	push	edi
	mov	DWORD PTR -32+[ebp], edi
	call	?OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z ; URender::OccludeBsp

; 863  : 		for( INT i=0; i<3; i++ )

	xor	eax, eax
	mov	DWORD PTR _i$15677[ebp], eax
$L15678:
	cmp	eax, 3
	jge	SHORT $L15680

; 864  : 			for( FBspDrawList* Draw=Frame->Draw[i]; Draw; Draw=Draw->Next )

	mov	edi, DWORD PTR [edi+eax*4+152]
	mov	DWORD PTR _Draw$15681[ebp], edi
$L15682:
	test	edi, edi
	je	SHORT $L15679

; 865  : 				iSurfs.AddUniqueItem( Draw->iSurf );

	add	edi, 4
	xor	esi, esi
$L19690:
	cmp	esi, DWORD PTR [ebx+4]
	jge	SHORT $L19693
	mov	ecx, DWORD PTR [ebx]
	push	4
	push	edi
	lea	edx, DWORD PTR [ecx+esi*4]
	push	edx
	call	DWORD PTR __imp_?appMemcmp@@YAHPBX0H@Z
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L15683
	inc	esi
	jmp	SHORT $L19690
$L19693:
	push	1
	mov	ecx, ebx
	call	?Add@?$TArray@H@@QAEHH@Z		; TArray<int>::Add
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [ecx+eax*4], edx
$L15683:
	mov	eax, DWORD PTR _Draw$15681[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _Draw$15681[ebp], ecx
	mov	edi, ecx
	jmp	SHORT $L15682
$L15679:

; 863  : 		for( INT i=0; i<3; i++ )

	mov	eax, DWORD PTR _i$15677[ebp]
	mov	edi, DWORD PTR -32+[ebp]
	inc	eax
	mov	DWORD PTR _i$15677[ebp], eax
	jmp	SHORT $L15678
$L15680:

; 866  : 		SceneMark.Pop();

	mov	esi, DWORD PTR $T19672[ebp]
	mov	edi, DWORD PTR _SceneMark$15663[ebp+12]
	cmp	edi, DWORD PTR [esi+20]
	jle	SHORT $L19718
	push	155					; 0000009bH
	push	OFFSET FLAT:??_C@_0FH@FKFD@Check?5failed?3?5ActiveChunks?$DM?$DNMem?9@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L19718:
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jle	SHORT $L19702
	dec	eax
	mov	DWORD PTR [esi+20], eax
	mov	eax, DWORD PTR [esi+eax*4+28]
	add	DWORD PTR [eax+16], -16777216		; ff000000H
	jmp	SHORT $L19718
$L19702:
	mov	edx, DWORD PTR _SceneMark$15663[ebp+4]
	mov	eax, DWORD PTR _SceneMark$15663[ebp+8]

; 867  : 		MemMark.Pop();

	mov	edi, DWORD PTR _MemMark$15661[ebp+12]
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR $T19668[ebp]
	cmp	edi, DWORD PTR [esi+20]
	jle	SHORT $L19719
	push	155					; 0000009bH
	push	OFFSET FLAT:??_C@_0FH@FKFD@Check?5failed?3?5ActiveChunks?$DM?$DNMem?9@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L19719:
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jle	SHORT $L19709
	dec	eax
	mov	DWORD PTR [esi+20], eax
	mov	eax, DWORD PTR [esi+eax*4+28]
	add	DWORD PTR [eax+16], -16777216		; ff000000H
	jmp	SHORT $L19719
$L19709:
	mov	ecx, DWORD PTR _MemMark$15661[ebp+4]
	mov	edx, DWORD PTR _MemMark$15661[ebp+8]
	mov	DWORD PTR [esi+4], ecx

; 868  : 		DynMemMark.Pop();

	lea	ecx, DWORD PTR _DynMemMark$15662[ebp]
	mov	DWORD PTR [esi+8], edx
	call	DWORD PTR __imp_?Pop@FMemMark@@QAEXXZ

; 869  : 		VectorMark.Pop();

	lea	ecx, DWORD PTR _VectorMark$15664[ebp]
	call	DWORD PTR __imp_?Pop@FMemMark@@QAEXXZ
	mov	eax, DWORD PTR _i$15657[ebp]
	inc	eax
	xor	ecx, ecx
	mov	DWORD PTR _i$15657[ebp], eax
	mov	edx, eax
	jmp	$L15658
$L19665:

; 870  : 	}
; 871  : 	unguard;

	mov	eax, DWORD PTR _Err$15685[ebp]
	lea	ecx, DWORD PTR $T19663[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	ecx
	mov	DWORD PTR $T19663[ebp], eax
	call	__CxxThrowException@8
	mov	eax, $L15660
	ret	0
$L19666:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??GetVisibleSurfs@URender@@UAEXPAVUViewport@@AAV?$TArray@H@@@Z@4PBDB$S15655
	push	OFFSET FLAT:$SG15687
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L15660
	ret	0
$L15660:

; 872  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
$L19721:
	mov	eax, OFFSET FLAT:$T19711
	jmp	___CxxFrameHandler
text$x	ENDS
?GetVisibleSurfs@URender@@UAEXPAVUViewport@@AAV?$TArray@H@@@Z ENDP ; URender::GetVisibleSurfs
EXTRN	?BoxIsVisible@FSpanBuffer@@QAEHHHHH@Z:NEAR	; FSpanBuffer::BoxIsVisible
EXTRN	__imp_??0FCoords@@QAE@XZ:NEAR
xdata$x	SEGMENT
$T19884	DD	019930520H
	DD	02H
	DD	FLAT:$T19916
	DD	01H
	DD	FLAT:$T19917
	DD	2 DUP(00H)
	ORG $+4
$T19916	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T19917	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T19918
	ORG $+4
$T19918	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0fffffe0cH
	DD	FLAT:$L19735
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L19736
xdata$x	ENDS
_TEXT	SEGMENT
$T19727 = -56
$T19728 = -68
$T19729 = -112
$T19730 = -100
$T19731 = -124
$T19732 = -40
$T19733 = 12
$T19744 = -28
_Frame$ = 8
_Bound$ = 12
_SpanBuffer$ = 16
_Result$ = 20
_this$ = -24
_BoxDot$15697 = -496
_Pts$15699 = -400
_BoxMinZ$15703 = 12
_BoxMaxZ$15704 = 8
_BoxMaxX$15708 = 8
_BoxMaxY$15710 = -24
_NewMin$15722 = -40
_NewMax$15724 = -84
_I$19841 = -44
$T19842 = 8
_I$19844 = -44
$T19845 = -20
_I$19847 = -72
$T19848 = -44
_I$19850 = -88
$T19851 = -20
__$EHRec$ = -16
_RZ$15799 = -20
_i$15804 = -28
_RZ$15808 = -20
_Err$15835 = -500
?BoundVisible@URender@@UAEHPAUFSceneNode@@PAVFBox@@PAVFSpanBuffer@@AAUFScreenBounds@@@Z PROC NEAR ; URender::BoundVisible

; 889  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L19913
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 484				; 000001e4H

; 890  : 	guard(URender::BoundVisible);
; 891  : 	STAT(GStat.BoxChecks++);

	mov	edx, DWORD PTR ?GStat@@3UFRenderStats@@A+108
	push	ebx
	push	esi
	push	edi
	inc	edx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+108, edx

; 892  : 	clock(GStat.BoxTime);

	xor	eax, eax

; 893  : 

	DB	15					; 0000000fH

; 894  : 	FCoords		BoxDot[2];

	DB	49					; 00000031H

; 895  : 	FTransform	Pts[8], *Pt;

	xor	edx, edx

; 892  : 	clock(GStat.BoxTime);

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+104

; 894  : 	FCoords		BoxDot[2];

	mov	edi, DWORD PTR __imp_??0FCoords@@QAE@XZ
	sub	ecx, eax
	mov	DWORD PTR $T19744[ebp], 2
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+104, ecx
	mov	ebx, 48					; 00000030H
	lea	esi, DWORD PTR _BoxDot$15697[ebp]
$L19740:
	mov	eax, DWORD PTR $T19744[ebp]
	dec	eax
	mov	DWORD PTR $T19744[ebp], eax
	js	SHORT $L19741
	mov	ecx, esi
	call	edi
	add	esi, ebx
	jmp	SHORT $L19740
$L19741:

; 895  : 	FTransform	Pts[8], *Pt;

	mov	edx, 8
	mov	ecx, 32					; 00000020H
	lea	eax, DWORD PTR _Pts$15699[ebp]
$L19756:
	dec	edx
	js	SHORT $L19757
	add	eax, ecx
	jmp	SHORT $L19756
$L19757:

; 896  : 	FVector 	ViewportLoc;
; 897  : 	FLOAT       BoxMinZ, BoxMaxZ;
; 898  : 	INT         BoxX, BoxY;
; 899  : 	INT 		BoxMinX, BoxMaxX, BoxMinY, BoxMaxY;
; 900  : 	INT			OutCode;
; 901  : 
; 902  : 	// Handle rejection in orthogonal views.
; 903  : 	if( Frame->Viewport->IsOrtho() )

	mov	esi, DWORD PTR _Frame$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+92]
	mov	eax, DWORD PTR [eax+1040]
	cmp	eax, 13					; 0000000dH
	je	SHORT $L19764
	cmp	eax, 14					; 0000000eH
	je	SHORT $L19764
	cmp	eax, 15					; 0000000fH
	jne	$L15712
$L19764:

; 904  : 	{
; 905  : 		Project( Frame, Bound->Min, Result.MinX, Result.MinY, NULL );

	mov	edi, DWORD PTR _Result$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	0
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	eax, DWORD PTR _Bound$[ebp]
	push	edi
	push	eax
	push	esi
	call	DWORD PTR [edx+132]

; 906  : 		Project( Frame, Bound->Max, Result.MaxX, Result.MaxY, NULL );

	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edi+12]
	push	0
	push	eax
	mov	eax, DWORD PTR _Bound$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	ebx, DWORD PTR [edi+8]
	add	eax, 12					; 0000000cH
	push	ebx
	push	eax
	push	esi
	call	DWORD PTR [edx+132]

; 907  : 		if( Result.MinX > Result.MaxX ) Exchange( Result.MinX, Result.MaxX );

	fld	DWORD PTR [edi]
	fcomp	DWORD PTR [ebx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L19768
	fld	DWORD PTR [edi]
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [edi], ecx
	fstp	DWORD PTR [ebx]
$L19768:

; 908  : 		if( Result.MinY > Result.MaxY ) Exchange( Result.MinY, Result.MaxY );

	fld	DWORD PTR [edi+4]
	fcomp	DWORD PTR [edi+12]
	lea	ecx, DWORD PTR [edi+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L19771
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [ecx], edx
	fstp	DWORD PTR [edi+12]
$L19771:

; 892  : 	clock(GStat.BoxTime);

	xor	eax, eax

; 893  : 

	DB	15					; 0000000fH

; 894  : 	FCoords		BoxDot[2];

	DB	49					; 00000031H

; 895  : 	FTransform	Pts[8], *Pt;

	xor	edx, edx

; 909  : 		unclock(GStat.BoxTime);
; 910  : 		return Result.MaxX>0.0 && Result.MaxY>0.0 && Result.MinX<Frame->FX && Result.MinY<Frame->FY;

	fld	DWORD PTR [ebx]
	mov	edx, DWORD PTR ?GStat@@3UFRenderStats@@A+104
	fcomp	QWORD PTR $T19300
	lea	eax, DWORD PTR [edx+eax-34]
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+104, eax
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L19725
	fld	DWORD PTR [edi+12]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L19725
	fld	DWORD PTR [edi]
	fcomp	DWORD PTR [esi+192]
	fnstsw	ax
	test	ah, 1
	je	$L19725
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR [esi+196]
	fnstsw	ax
	test	ah, 1
	je	$L19725
	jmp	$L19914
$L15712:

; 911  : 	}
; 912  : 
; 913  : 	// Trivial in-bound accept.
; 914  : 	FVector NewMin = Bound->Min - Frame->Coords.Origin;

	mov	eax, DWORD PTR _Bound$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [esi+52]
	fstp	DWORD PTR _NewMin$15722[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [esi+56]
	fstp	DWORD PTR _NewMin$15722[ebp+4]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [esi+60]
	fstp	DWORD PTR _NewMin$15722[ebp+8]

; 915  : 	FVector NewMax = Bound->Max - Frame->Coords.Origin;

	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR [esi+52]
	fstp	DWORD PTR _NewMax$15724[ebp]
	fld	DWORD PTR [eax+16]
	fsub	DWORD PTR [esi+56]
	fstp	DWORD PTR _NewMax$15724[ebp+4]
	fld	DWORD PTR [eax+20]
	fsub	DWORD PTR [esi+60]
	fstp	DWORD PTR _NewMax$15724[ebp+8]

; 916  : 	if
; 917  : 	(	NewMin.X < 0.0 && NewMax.X > 0.0
; 918  : 	&&	NewMin.Y < 0.0 && NewMax.Y > 0.0
; 919  : 	&&	NewMin.Z < 0.0 && NewMax.Z > 0.0 )

	fld	DWORD PTR _NewMin$15722[ebp]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 1
	je	$L15726
	fld	DWORD PTR _NewMax$15724[ebp]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L15726
	fld	DWORD PTR _NewMin$15722[ebp+4]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15726
	fld	DWORD PTR _NewMax$15724[ebp+4]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L15726
	fld	DWORD PTR _NewMin$15722[ebp+8]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15726
	fld	DWORD PTR _NewMax$15724[ebp+8]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L15726

; 920  : 	{
; 921  : 		Result.MinX = 0;

	mov	eax, DWORD PTR _Result$[ebp]

; 922  : 		Result.MinY = 0;
; 923  : 		Result.MaxX = Frame->FX;

	mov	edx, DWORD PTR [esi+192]
	xor	ecx, ecx
	mov	DWORD PTR [eax+8], edx

; 924  : 		Result.MaxY = Frame->FY;

	mov	edx, DWORD PTR [esi+196]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+12], edx

; 925  : 		Result.MinZ = 0;

	mov	DWORD PTR [eax+16], ecx

; 926  : 		STAT(GStat.BoxIn++);

	inc	DWORD PTR ?GStat@@3UFRenderStats@@A+116

; 892  : 	clock(GStat.BoxTime);

	xor	eax, eax

; 893  : 

	DB	15					; 0000000fH

; 894  : 	FCoords		BoxDot[2];

	DB	49					; 00000031H

; 895  : 	FTransform	Pts[8], *Pt;

	xor	edx, edx

; 927  : 		unclock(GStat.BoxTime);

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+104
	lea	edx, DWORD PTR [ecx+eax-34]
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+104, edx

; 928  : 		return 1;

	jmp	$L19914
$L15726:

; 929  : 	}
; 930  : 
; 931  : 	/* Bounding sphere reject: Not worth it (slower).
; 932  : 	if( Toggle )
; 933  : 	{
; 934  : 		FVector Center   = 0.5*(Bound->Min + Bound->Max);
; 935  : 		FLOAT   RadiusSq = FDistSquared(Center,Bound->Min);
; 936  : 		for( INT i=0; i<4; i++ )
; 937  : 		{
; 938  : 			FLOAT Dot = Frame->ViewPlanes[i].PlaneDot(Center);
; 939  : 			if( Dot<0.0 && Square(Dot)>RadiusSq )
; 940  : 			{
; 941  : 				unclock(GStat.BoxTime);
; 942  : 				return 0;
; 943  : 			}
; 944  : 		}
; 945  : 	}*/
; 946  : 
; 947  : 	// Test bounding-box side-of-viewport rejection.  Since box is axis-aligned,
; 948  : 	// this can be optimized: Box can only be rejected if all 8 dot products of the
; 949  : 	// 8 box sides are less than zero. This is the case iff each dot product
; 950  : 	// component is less than zero.
; 951  : 	BoxDot[0].ZAxis = NewMin * Frame->Coords.ZAxis; BoxDot[1].ZAxis = NewMax * Frame->Coords.ZAxis;

	fld	DWORD PTR [esi+88]
	fmul	DWORD PTR _NewMin$15722[ebp]
	fstp	DWORD PTR $T19727[ebp]
	fld	DWORD PTR [esi+92]
	fmul	DWORD PTR _NewMin$15722[ebp+4]
	mov	eax, DWORD PTR $T19727[ebp]
	mov	DWORD PTR _BoxDot$15697[ebp+36], eax
	fstp	DWORD PTR $T19727[ebp+4]
	fld	DWORD PTR [esi+96]
	fmul	DWORD PTR _NewMin$15722[ebp+8]
	mov	ecx, DWORD PTR $T19727[ebp+4]
	mov	DWORD PTR _BoxDot$15697[ebp+40], ecx
	fstp	DWORD PTR $T19727[ebp+8]
	fld	DWORD PTR [esi+88]
	fmul	DWORD PTR _NewMax$15724[ebp]
	mov	edx, DWORD PTR $T19727[ebp+8]
	mov	DWORD PTR _BoxDot$15697[ebp+44], edx
	fstp	DWORD PTR $T19728[ebp]
	fld	DWORD PTR [esi+92]
	fmul	DWORD PTR _NewMax$15724[ebp+4]
	mov	eax, DWORD PTR $T19728[ebp]
	mov	DWORD PTR _BoxDot$15697[ebp+84], eax
	fstp	DWORD PTR $T19728[ebp+4]
	fld	DWORD PTR [esi+96]
	fmul	DWORD PTR _NewMax$15724[ebp+8]
	mov	ecx, DWORD PTR $T19728[ebp+4]
	mov	DWORD PTR _BoxDot$15697[ebp+88], ecx
	fstp	DWORD PTR $T19728[ebp+8]

; 952  : 	if
; 953  : 	(	BoxDot[0].ZAxis.X<=0.0 && BoxDot[0].ZAxis.Y<=0.0 && BoxDot[0].ZAxis.Z<=0.0
; 954  : 	&&	BoxDot[1].ZAxis.X<=0.0 && BoxDot[1].ZAxis.Y<=0.0 && BoxDot[1].ZAxis.Z<=0.0 )

	fld	DWORD PTR $T19727[ebp]
	fcomp	QWORD PTR $T19300
	mov	edx, DWORD PTR $T19728[ebp+8]
	mov	DWORD PTR _BoxDot$15697[ebp+92], edx
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L15729
	fld	DWORD PTR $T19727[ebp+4]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L15729
	fld	DWORD PTR $T19727[ebp+8]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L15729
	fld	DWORD PTR $T19728[ebp]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L15729
	fld	DWORD PTR $T19728[ebp+4]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L15729
	fld	DWORD PTR $T19728[ebp+8]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L15729

; 955  : 	{
; 956  : 		STAT(GStat.BoxBacks++);

	inc	DWORD PTR ?GStat@@3UFRenderStats@@A+112

; 892  : 	clock(GStat.BoxTime);

	xor	eax, eax

; 893  : 

	DB	15					; 0000000fH

; 894  : 	FCoords		BoxDot[2];

	DB	49					; 00000031H

; 895  : 	FTransform	Pts[8], *Pt;

	xor	edx, edx

; 957  : 		unclock(GStat.BoxTime);
; 958  : 		return 0;

	jmp	$L19915
$L15729:

; 959  : 	}
; 960  : 
; 961  : 	// Transform bounding box min and max coords into screenspace.
; 962  : 	BoxDot[0].XAxis = NewMin * Frame->Coords.XAxis; BoxDot[1].XAxis = NewMax * Frame->Coords.XAxis;

	fld	DWORD PTR [esi+64]
	fmul	DWORD PTR _NewMin$15722[ebp]
	fstp	DWORD PTR $T19729[ebp]
	fld	DWORD PTR [esi+68]
	fmul	DWORD PTR _NewMin$15722[ebp+4]
	mov	eax, DWORD PTR $T19729[ebp]
	mov	DWORD PTR _BoxDot$15697[ebp+12], eax
	fstp	DWORD PTR $T19729[ebp+4]
	fld	DWORD PTR [esi+72]
	fmul	DWORD PTR _NewMin$15722[ebp+8]
	mov	ecx, DWORD PTR $T19729[ebp+4]
	mov	DWORD PTR _BoxDot$15697[ebp+16], ecx
	fstp	DWORD PTR $T19729[ebp+8]
	fld	DWORD PTR [esi+64]
	fmul	DWORD PTR _NewMax$15724[ebp]
	mov	edx, DWORD PTR $T19729[ebp+8]
	mov	DWORD PTR _BoxDot$15697[ebp+20], edx
	fstp	DWORD PTR $T19730[ebp]
	fld	DWORD PTR [esi+68]
	fmul	DWORD PTR _NewMax$15724[ebp+4]
	mov	eax, DWORD PTR $T19730[ebp]
	mov	DWORD PTR _BoxDot$15697[ebp+60], eax
	fstp	DWORD PTR $T19730[ebp+4]
	fld	DWORD PTR [esi+72]
	fmul	DWORD PTR _NewMax$15724[ebp+8]
	mov	ecx, DWORD PTR $T19730[ebp+4]
	mov	DWORD PTR _BoxDot$15697[ebp+64], ecx
	fstp	DWORD PTR $T19730[ebp+8]

; 963  : 	BoxDot[0].YAxis = NewMin * Frame->Coords.YAxis; BoxDot[1].YAxis = NewMax * Frame->Coords.YAxis;

	fld	DWORD PTR [esi+76]
	fmul	DWORD PTR _NewMin$15722[ebp]
	mov	edx, DWORD PTR $T19730[ebp+8]
	mov	DWORD PTR _BoxDot$15697[ebp+68], edx
	fstp	DWORD PTR $T19731[ebp]
	fld	DWORD PTR [esi+80]
	fmul	DWORD PTR _NewMin$15722[ebp+4]
	mov	eax, DWORD PTR $T19731[ebp]
	mov	DWORD PTR _BoxDot$15697[ebp+24], eax
	fstp	DWORD PTR $T19731[ebp+4]
	fld	DWORD PTR [esi+84]
	fmul	DWORD PTR _NewMin$15722[ebp+8]
	mov	ecx, DWORD PTR $T19731[ebp+4]
	mov	DWORD PTR _BoxDot$15697[ebp+28], ecx
	fstp	DWORD PTR $T19731[ebp+8]
	fld	DWORD PTR [esi+76]
	fmul	DWORD PTR _NewMax$15724[ebp]
	mov	edx, DWORD PTR $T19731[ebp+8]
	mov	DWORD PTR _BoxDot$15697[ebp+32], edx
	fstp	DWORD PTR $T19732[ebp]
	fld	DWORD PTR [esi+80]
	fmul	DWORD PTR _NewMax$15724[ebp+4]
	mov	eax, DWORD PTR $T19732[ebp]
	mov	DWORD PTR _BoxDot$15697[ebp+72], eax
	fstp	DWORD PTR $T19732[ebp+4]
	fld	DWORD PTR [esi+84]
	fmul	DWORD PTR _NewMax$15724[ebp+8]
	mov	ecx, DWORD PTR $T19732[ebp+4]
	mov	DWORD PTR _BoxDot$15697[ebp+76], ecx

; 964  : 
; 965  : 	// View-pyramid reject with an outcode test.
; 966  : 	INT ThisCode, AllCodes;
; 967  : 	BoxMinZ = Pts[0].Point.Z;
; 968  : 	BoxMaxZ = Pts[0].Point.Z;
; 969  : 	OutCode  = 1|2|4|8;
; 970  : 	AllCodes = 0;
; 971  : 	#define CMD(i,j,k,First,P)\
; 972  : 		ThisCode = 0;\
; 973  : 		\
; 974  : 		P.Point.Z = BoxDot[i].ZAxis.X + BoxDot[j].ZAxis.Y + BoxDot[k].ZAxis.Z;\
; 975  : 		if( First || P.Point.Z < BoxMinZ ) BoxMinZ = P.Point.Z;\
; 976  : 		if( First || P.Point.Z > BoxMaxZ ) BoxMaxZ = P.Point.Z;\
; 977  : 		\
; 978  : 		P.Point.X = BoxDot[i].XAxis.X + BoxDot[j].XAxis.Y + BoxDot[k].XAxis.Z;\
; 979  : 		if( Frame->PrjXM * P.Point.Z + P.Point.X < 0 ) ThisCode |= 1;\
; 980  : 		if( Frame->PrjXP * P.Point.Z - P.Point.X < 0 ) ThisCode |= 2;\
; 981  : 		\
; 982  : 		P.Point.Y = BoxDot[i].YAxis.X + BoxDot[j].YAxis.Y + BoxDot[k].YAxis.Z;\
; 983  : 		if( Frame->PrjYM * P.Point.Z + P.Point.Y < 0 ) ThisCode |= 4;\
; 984  : 		if( Frame->PrjYP * P.Point.Z - P.Point.Y < 0 ) ThisCode |= 8;\
; 985  : 		\
; 986  : 		OutCode  &= ThisCode;\
; 987  : 		AllCodes |= ThisCode;
; 988  : 	CMD(0,0,0,1,Pts[0]); CMD(1,0,0,0,Pts[1]); CMD(0,1,0,0,Pts[2]); CMD(1,1,0,0,Pts[3]);

	xor	ecx, ecx
	fstp	DWORD PTR $T19732[ebp+8]
	fld	DWORD PTR $T19727[ebp]
	fadd	DWORD PTR $T19727[ebp+4]
	mov	edx, DWORD PTR $T19732[ebp+8]
	mov	DWORD PTR _BoxDot$15697[ebp+80], edx
	fstp	DWORD PTR 8+[ebp]
	fld	DWORD PTR $T19727[ebp+8]
	fadd	DWORD PTR 8+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+8]
	mov	eax, DWORD PTR _Pts$15699[ebp+8]
	mov	DWORD PTR _BoxMinZ$15703[ebp], eax
	fld	DWORD PTR _Pts$15699[ebp+8]
	fld	DWORD PTR $T19729[ebp]
	fadd	DWORD PTR $T19729[ebp+4]
	fstp	DWORD PTR -28+[ebp]
	fld	DWORD PTR $T19729[ebp+8]
	fadd	DWORD PTR -28+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp]
	fld	DWORD PTR _Pts$15699[ebp+8]
	fmul	DWORD PTR [esi+256]
	fadd	DWORD PTR _Pts$15699[ebp]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15738
	mov	ecx, 1
$L15738:
	fld	DWORD PTR _Pts$15699[ebp+8]
	fmul	DWORD PTR [esi+260]
	fsub	DWORD PTR _Pts$15699[ebp]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15739
	or	ecx, 2
$L15739:
	fld	DWORD PTR $T19731[ebp]
	fadd	DWORD PTR $T19731[ebp+4]
	fstp	DWORD PTR -24+[ebp]
	fld	DWORD PTR $T19731[ebp+8]
	fadd	DWORD PTR -24+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+4]
	fld	DWORD PTR _Pts$15699[ebp+8]
	fmul	DWORD PTR [esi+264]
	fadd	DWORD PTR _Pts$15699[ebp+4]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15740
	or	ecx, 4
$L15740:
	fld	DWORD PTR _Pts$15699[ebp+8]
	fmul	DWORD PTR [esi+268]
	fsub	DWORD PTR _Pts$15699[ebp+4]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15741
	or	ecx, 8
$L15741:
	fld	DWORD PTR $T19728[ebp]
	fadd	DWORD PTR $T19727[ebp+4]
	mov	edx, ecx
	mov	ebx, ecx
	and	edx, 15					; 0000000fH
	xor	ecx, ecx
	fstp	DWORD PTR -128+[ebp]
	fld	DWORD PTR $T19727[ebp+8]
	fadd	DWORD PTR -128+[ebp]
	fst	DWORD PTR _Pts$15699[ebp+40]
	fcomp	DWORD PTR _Pts$15699[ebp+8]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15742
	mov	eax, DWORD PTR _Pts$15699[ebp+40]
	mov	DWORD PTR _BoxMinZ$15703[ebp], eax
$L15742:
	fld	DWORD PTR _Pts$15699[ebp+40]
	fcomp	DWORD PTR _Pts$15699[ebp+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L15744
	fstp	ST(0)
	fld	DWORD PTR _Pts$15699[ebp+40]
$L15744:
	fld	DWORD PTR $T19730[ebp]
	fadd	DWORD PTR $T19729[ebp+4]
	fstp	DWORD PTR -132+[ebp]
	fld	DWORD PTR $T19729[ebp+8]
	fadd	DWORD PTR -132+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+32]
	fld	DWORD PTR _Pts$15699[ebp+40]
	fmul	DWORD PTR [esi+256]
	fadd	DWORD PTR _Pts$15699[ebp+32]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15746
	mov	ecx, 1
$L15746:
	fld	DWORD PTR _Pts$15699[ebp+40]
	fmul	DWORD PTR [esi+260]
	fsub	DWORD PTR _Pts$15699[ebp+32]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15747
	or	ecx, 2
$L15747:
	fld	DWORD PTR $T19732[ebp]
	fadd	DWORD PTR $T19731[ebp+4]
	fstp	DWORD PTR -136+[ebp]
	fld	DWORD PTR $T19731[ebp+8]
	fadd	DWORD PTR -136+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+36]
	fld	DWORD PTR _Pts$15699[ebp+40]
	fmul	DWORD PTR [esi+264]
	fadd	DWORD PTR _Pts$15699[ebp+36]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15748
	or	ecx, 4
$L15748:
	fld	DWORD PTR _Pts$15699[ebp+40]
	fmul	DWORD PTR [esi+268]
	fsub	DWORD PTR _Pts$15699[ebp+36]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15749
	or	ecx, 8
$L15749:
	fld	DWORD PTR $T19728[ebp+4]
	fadd	DWORD PTR $T19727[ebp]
	and	edx, ecx
	or	ebx, ecx
	xor	ecx, ecx
	fstp	DWORD PTR -140+[ebp]
	fld	DWORD PTR $T19727[ebp+8]
	fadd	DWORD PTR -140+[ebp]
	fst	DWORD PTR _Pts$15699[ebp+72]
	fcomp	DWORD PTR _BoxMinZ$15703[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15750
	mov	eax, DWORD PTR _Pts$15699[ebp+72]
	mov	DWORD PTR _BoxMinZ$15703[ebp], eax
$L15750:
	fld	DWORD PTR _Pts$15699[ebp+72]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L15752
	fstp	ST(0)
	fld	DWORD PTR _Pts$15699[ebp+72]
$L15752:
	fld	DWORD PTR $T19730[ebp+4]
	fadd	DWORD PTR $T19729[ebp]
	fstp	DWORD PTR -144+[ebp]
	fld	DWORD PTR $T19729[ebp+8]
	fadd	DWORD PTR -144+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+64]
	fld	DWORD PTR _Pts$15699[ebp+72]
	fmul	DWORD PTR [esi+256]
	fadd	DWORD PTR _Pts$15699[ebp+64]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15754
	mov	ecx, 1
$L15754:
	fld	DWORD PTR _Pts$15699[ebp+72]
	fmul	DWORD PTR [esi+260]
	fsub	DWORD PTR _Pts$15699[ebp+64]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15755
	or	ecx, 2
$L15755:
	fld	DWORD PTR $T19732[ebp+4]
	fadd	DWORD PTR $T19731[ebp]
	fstp	DWORD PTR -88+[ebp]
	fld	DWORD PTR $T19731[ebp+8]
	fadd	DWORD PTR -88+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+68]
	fld	DWORD PTR _Pts$15699[ebp+72]
	fmul	DWORD PTR [esi+264]
	fadd	DWORD PTR _Pts$15699[ebp+68]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15756
	or	ecx, 4
$L15756:
	fld	DWORD PTR _Pts$15699[ebp+72]
	fmul	DWORD PTR [esi+268]
	fsub	DWORD PTR _Pts$15699[ebp+68]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15757
	or	ecx, 8
$L15757:
	fld	DWORD PTR $T19728[ebp]
	fadd	DWORD PTR $T19728[ebp+4]
	and	edx, ecx
	or	ebx, ecx
	xor	ecx, ecx
	fstp	DWORD PTR -72+[ebp]
	fld	DWORD PTR $T19727[ebp+8]
	fadd	DWORD PTR -72+[ebp]
	fst	DWORD PTR _Pts$15699[ebp+104]
	fcomp	DWORD PTR _BoxMinZ$15703[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15758
	mov	eax, DWORD PTR _Pts$15699[ebp+104]
	mov	DWORD PTR _BoxMinZ$15703[ebp], eax
$L15758:
	fld	DWORD PTR _Pts$15699[ebp+104]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L15760
	fstp	ST(0)
	fld	DWORD PTR _Pts$15699[ebp+104]
$L15760:
	fld	DWORD PTR $T19730[ebp]
	fadd	DWORD PTR $T19730[ebp+4]
	fstp	DWORD PTR -44+[ebp]
	fld	DWORD PTR $T19729[ebp+8]
	fadd	DWORD PTR -44+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+96]
	fld	DWORD PTR _Pts$15699[ebp+104]
	fmul	DWORD PTR [esi+256]
	fadd	DWORD PTR _Pts$15699[ebp+96]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15762
	mov	ecx, 1
$L15762:
	fld	DWORD PTR _Pts$15699[ebp+104]
	fmul	DWORD PTR [esi+260]
	fsub	DWORD PTR _Pts$15699[ebp+96]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15763
	or	ecx, 2
$L15763:
	fld	DWORD PTR $T19732[ebp]
	fadd	DWORD PTR $T19732[ebp+4]
	fstp	DWORD PTR -20+[ebp]
	fld	DWORD PTR $T19731[ebp+8]
	fadd	DWORD PTR -20+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+100]
	fld	DWORD PTR _Pts$15699[ebp+104]
	fmul	DWORD PTR [esi+264]
	fadd	DWORD PTR _Pts$15699[ebp+100]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15764
	or	ecx, 4
$L15764:
	fld	DWORD PTR _Pts$15699[ebp+104]
	fmul	DWORD PTR [esi+268]
	fsub	DWORD PTR _Pts$15699[ebp+100]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15765
	or	ecx, 8
$L15765:

; 989  : 	CMD(0,0,1,0,Pts[4]); CMD(1,0,1,0,Pts[5]); CMD(0,1,1,0,Pts[6]); CMD(1,1,1,0,Pts[7]);

	fld	DWORD PTR $T19728[ebp+8]
	fadd	DWORD PTR 8+[ebp]
	and	edx, ecx
	or	ebx, ecx
	xor	ecx, ecx
	fst	DWORD PTR _Pts$15699[ebp+136]
	fcomp	DWORD PTR _BoxMinZ$15703[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15766
	mov	eax, DWORD PTR _Pts$15699[ebp+136]
	mov	DWORD PTR _BoxMinZ$15703[ebp], eax
$L15766:
	fld	DWORD PTR _Pts$15699[ebp+136]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L15768
	fstp	ST(0)
	fld	DWORD PTR _Pts$15699[ebp+136]
$L15768:
	fld	DWORD PTR $T19730[ebp+8]
	fadd	DWORD PTR -28+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+128]
	fld	DWORD PTR _Pts$15699[ebp+136]
	fmul	DWORD PTR [esi+256]
	fadd	DWORD PTR _Pts$15699[ebp+128]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15770
	mov	ecx, 1
$L15770:
	fld	DWORD PTR _Pts$15699[ebp+136]
	fmul	DWORD PTR [esi+260]
	fsub	DWORD PTR _Pts$15699[ebp+128]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15771
	or	ecx, 2
$L15771:
	fld	DWORD PTR $T19732[ebp+8]
	fadd	DWORD PTR -24+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+132]
	fld	DWORD PTR _Pts$15699[ebp+136]
	fmul	DWORD PTR [esi+264]
	fadd	DWORD PTR _Pts$15699[ebp+132]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15772
	or	ecx, 4
$L15772:
	fld	DWORD PTR _Pts$15699[ebp+136]
	fmul	DWORD PTR [esi+268]
	fsub	DWORD PTR _Pts$15699[ebp+132]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15773
	or	ecx, 8
$L15773:
	fld	DWORD PTR $T19728[ebp+8]
	fadd	DWORD PTR -128+[ebp]
	and	edx, ecx
	or	ebx, ecx
	xor	ecx, ecx
	fst	DWORD PTR _Pts$15699[ebp+168]
	fcomp	DWORD PTR _BoxMinZ$15703[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15774
	mov	eax, DWORD PTR _Pts$15699[ebp+168]
	mov	DWORD PTR _BoxMinZ$15703[ebp], eax
$L15774:
	fld	DWORD PTR _Pts$15699[ebp+168]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	fstp	ST(0)
	jne	SHORT $L15776
	mov	eax, DWORD PTR _Pts$15699[ebp+168]
	mov	DWORD PTR _BoxMaxZ$15704[ebp], eax
$L15776:
	fld	DWORD PTR $T19730[ebp+8]
	fadd	DWORD PTR -132+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+160]
	fld	DWORD PTR _Pts$15699[ebp+168]
	fmul	DWORD PTR [esi+256]
	fadd	DWORD PTR _Pts$15699[ebp+160]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15778
	mov	ecx, 1
$L15778:
	fld	DWORD PTR _Pts$15699[ebp+168]
	fmul	DWORD PTR [esi+260]
	fsub	DWORD PTR _Pts$15699[ebp+160]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15779
	or	ecx, 2
$L15779:
	fld	DWORD PTR $T19732[ebp+8]
	fadd	DWORD PTR -136+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+164]
	fld	DWORD PTR _Pts$15699[ebp+168]
	fmul	DWORD PTR [esi+264]
	fadd	DWORD PTR _Pts$15699[ebp+164]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15780
	or	ecx, 4
$L15780:
	fld	DWORD PTR _Pts$15699[ebp+168]
	fmul	DWORD PTR [esi+268]
	fsub	DWORD PTR _Pts$15699[ebp+164]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15781
	or	ecx, 8
$L15781:
	fld	DWORD PTR $T19728[ebp+8]
	fadd	DWORD PTR -140+[ebp]
	and	edx, ecx
	or	ebx, ecx
	xor	ecx, ecx
	fst	DWORD PTR _Pts$15699[ebp+200]
	fcomp	DWORD PTR _BoxMinZ$15703[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15782
	mov	eax, DWORD PTR _Pts$15699[ebp+200]
	mov	DWORD PTR _BoxMinZ$15703[ebp], eax
$L15782:
	fld	DWORD PTR $T19730[ebp+8]
	fadd	DWORD PTR -144+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+192]
	fld	DWORD PTR _Pts$15699[ebp+200]
	fmul	DWORD PTR [esi+256]
	fadd	DWORD PTR _Pts$15699[ebp+192]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15786
	mov	ecx, 1
$L15786:
	fld	DWORD PTR _Pts$15699[ebp+200]
	fmul	DWORD PTR [esi+260]
	fsub	DWORD PTR _Pts$15699[ebp+192]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15787
	or	ecx, 2
$L15787:
	fld	DWORD PTR $T19732[ebp+8]
	fadd	DWORD PTR -88+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+196]
	fld	DWORD PTR _Pts$15699[ebp+200]
	fmul	DWORD PTR [esi+264]
	fadd	DWORD PTR _Pts$15699[ebp+196]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15788
	or	ecx, 4
$L15788:
	fld	DWORD PTR _Pts$15699[ebp+200]
	fmul	DWORD PTR [esi+268]
	fsub	DWORD PTR _Pts$15699[ebp+196]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15789
	or	ecx, 8
$L15789:
	fld	DWORD PTR $T19728[ebp+8]
	fadd	DWORD PTR -72+[ebp]
	and	edx, ecx
	or	ebx, ecx
	xor	ecx, ecx
	fst	DWORD PTR _Pts$15699[ebp+232]
	fcomp	DWORD PTR _BoxMinZ$15703[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15790
	mov	eax, DWORD PTR _Pts$15699[ebp+232]
	mov	DWORD PTR _BoxMinZ$15703[ebp], eax
$L15790:
	fld	DWORD PTR $T19730[ebp+8]
	fadd	DWORD PTR -44+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+224]
	fld	DWORD PTR _Pts$15699[ebp+232]
	fmul	DWORD PTR [esi+256]
	fadd	DWORD PTR _Pts$15699[ebp+224]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15794
	mov	ecx, 1
$L15794:
	fld	DWORD PTR _Pts$15699[ebp+232]
	fmul	DWORD PTR [esi+260]
	fsub	DWORD PTR _Pts$15699[ebp+224]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15795
	or	ecx, 2
$L15795:
	fld	DWORD PTR $T19732[ebp+8]
	fadd	DWORD PTR -20+[ebp]
	fstp	DWORD PTR _Pts$15699[ebp+228]
	fld	DWORD PTR _Pts$15699[ebp+232]
	fmul	DWORD PTR [esi+264]
	fadd	DWORD PTR _Pts$15699[ebp+228]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15796
	or	ecx, 4
$L15796:
	fld	DWORD PTR _Pts$15699[ebp+232]
	fmul	DWORD PTR [esi+268]
	fsub	DWORD PTR _Pts$15699[ebp+228]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L15797
	or	ecx, 8
$L15797:
	and	edx, ecx
	or	ebx, ecx

; 990  : 	#undef CMD
; 991  : 
; 992  : 	if( OutCode )

	test	edx, edx
	je	SHORT $L15798

; 993  : 	{
; 994  : 		// Invisible - pyramid reject.
; 995  : 		STAT(GStat.BoxOutOfPyramid++;);

	inc	DWORD PTR ?GStat@@3UFRenderStats@@A+120

; 892  : 	clock(GStat.BoxTime);

	xor	eax, eax

; 893  : 

	DB	15					; 0000000fH

; 894  : 	FCoords		BoxDot[2];

	DB	49					; 00000031H

; 895  : 	FTransform	Pts[8], *Pt;

	xor	edx, edx

; 996  : 		unclock(GStat.BoxTime);
; 997  : 		return 0;

	jmp	$L19915
$L15798:

; 998  : 	}
; 999  : 
; 1000 : 	// Calculate projections of 8 points and take X,Y min/max bounded to Span X,Y window.
; 1001 : 	Pt       = &Pts[0];
; 1002 : 	FLOAT RZ = Frame->Proj.Z / Pt->Point.Z;

	fld	DWORD PTR [esi+240]
	fdiv	DWORD PTR _Pts$15699[ebp+8]
	lea	ecx, DWORD PTR _Pts$15699[ebp]
	fst	DWORD PTR _RZ$15799[ebp]

; 1003 : 	BoxMinX  = BoxMaxX = appFloor( Frame->FX2 + Pt->Point.X * RZ );

	fmul	DWORD PTR _Pts$15699[ebp]
	fadd	DWORD PTR [esi+216]
	fstp	DWORD PTR $T19842[ebp]

; 892  : 	clock(GStat.BoxTime);

	fld	DWORD PTR $T19842[ebp]

; 893  : 

	fsub	DWORD PTR ?Half@?1??appFloor@@YAHM@Z@4MA ; Half

; 894  : 	FCoords		BoxDot[2];

	fistp	DWORD PTR _I$19841[ebp]

; 1004 : 	BoxMinY  = BoxMaxY = appFloor( Frame->FY2 + Pt->Point.Y * RZ );

	fld	DWORD PTR _RZ$15799[ebp]
	fmul	DWORD PTR _Pts$15699[ebp+4]
	mov	eax, DWORD PTR _I$19841[ebp]
	mov	DWORD PTR _BoxMaxX$15708[ebp], eax
	mov	edx, eax
	fadd	DWORD PTR [esi+220]
	fstp	DWORD PTR $T19845[ebp]

; 892  : 	clock(GStat.BoxTime);

	fld	DWORD PTR $T19845[ebp]

; 893  : 

	fsub	DWORD PTR ?Half@?1??appFloor@@YAHM@Z@4MA ; Half

; 894  : 	FCoords		BoxDot[2];

	fistp	DWORD PTR _I$19844[ebp]

; 1004 : 	BoxMinY  = BoxMaxY = appFloor( Frame->FY2 + Pt->Point.Y * RZ );

	mov	eax, DWORD PTR _I$19844[ebp]

; 1005 : 	if( AllCodes & 1 ) BoxMinX = 0;

	test	bl, 1
	mov	DWORD PTR _BoxMaxY$15710[ebp], eax
	mov	edi, eax
	je	SHORT $L15800
	xor	edx, edx
$L15800:

; 1006 : 	if( AllCodes & 2 ) BoxMaxX = Frame->X;

	test	bl, 2
	je	SHORT $L15801
	mov	eax, DWORD PTR [esi+176]
	mov	DWORD PTR _BoxMaxX$15708[ebp], eax
$L15801:

; 1007 : 	if( AllCodes & 4 ) BoxMinY = 0;

	test	bl, 4
	je	SHORT $L15802
	xor	edi, edi
$L15802:

; 1008 : 	if( AllCodes & 8 ) BoxMaxY = Frame->Y;

	test	bl, 8
	je	SHORT $L15803
	mov	eax, DWORD PTR [esi+180]
	mov	DWORD PTR _BoxMaxY$15710[ebp], eax
$L15803:

; 1009 : 	for( INT i=1; i<8; i++,Pt++ )

	mov	DWORD PTR _i$15804[ebp], 1
$L15805:
	cmp	DWORD PTR _i$15804[ebp], 8
	jge	SHORT $L15807

; 1010 : 	{
; 1011 : 		FLOAT RZ = Frame->Proj.Z / Pt->Point.Z;

	fld	DWORD PTR [esi+240]
	fdiv	DWORD PTR [ecx+8]
	fst	DWORD PTR _RZ$15808[ebp]

; 1012 : 		BoxX     = appFloor( Frame->FX2 + Pt->Point.X * RZ );

	fmul	DWORD PTR [ecx]
	fadd	DWORD PTR [esi+216]
	fstp	DWORD PTR $T19848[ebp]

; 892  : 	clock(GStat.BoxTime);

	fld	DWORD PTR $T19848[ebp]

; 893  : 

	fsub	DWORD PTR ?Half@?1??appFloor@@YAHM@Z@4MA ; Half

; 894  : 	FCoords		BoxDot[2];

	fistp	DWORD PTR _I$19847[ebp]

; 1013 : 		BoxY     = appFloor( Frame->FY2 + Pt->Point.Y * RZ );

	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR _RZ$15808[ebp]
	fadd	DWORD PTR [esi+220]
	fstp	DWORD PTR $T19851[ebp]

; 892  : 	clock(GStat.BoxTime);

	fld	DWORD PTR $T19851[ebp]

; 893  : 

	fsub	DWORD PTR ?Half@?1??appFloor@@YAHM@Z@4MA ; Half

; 894  : 	FCoords		BoxDot[2];

	fistp	DWORD PTR _I$19850[ebp]

; 1014 : 		if      ( BoxX < BoxMinX ) BoxMinX = BoxX;

	mov	eax, DWORD PTR _I$19847[ebp]
	cmp	eax, edx
	jge	SHORT $L15809
	mov	edx, eax

; 1015 : 		else if ( BoxX > BoxMaxX ) BoxMaxX = BoxX;

	jmp	SHORT $L15811
$L15809:
	cmp	eax, DWORD PTR _BoxMaxX$15708[ebp]
	jle	SHORT $L15811
	mov	DWORD PTR _BoxMaxX$15708[ebp], eax
$L15811:

; 1016 : 		if      ( BoxY < BoxMinY ) BoxMinY = BoxY;

	mov	eax, DWORD PTR _I$19850[ebp]
	cmp	eax, edi
	jge	SHORT $L15812
	mov	ebx, DWORD PTR _i$15804[ebp]
	mov	edi, eax
	inc	ebx
	add	ecx, 32					; 00000020H
	mov	DWORD PTR _i$15804[ebp], ebx
	jmp	SHORT $L15805
$L15812:

; 1017 : 		else if ( BoxY > BoxMaxY ) BoxMaxY = BoxY;

	cmp	eax, DWORD PTR _BoxMaxY$15710[ebp]
	jle	SHORT $L15806
	mov	DWORD PTR _BoxMaxY$15710[ebp], eax
$L15806:

; 1009 : 	for( INT i=1; i<8; i++,Pt++ )

	mov	ebx, DWORD PTR _i$15804[ebp]
	inc	ebx
	add	ecx, 32					; 00000020H
	mov	DWORD PTR _i$15804[ebp], ebx
	jmp	SHORT $L15805
$L15807:

; 1018 : 	}
; 1019 : 	Result.MinX  = ::Max(BoxMinX,0);

	xor	ecx, ecx

; 1020 : 	Result.MinY  = ::Max(BoxMinY,0);
; 1021 : 	Result.MaxX  = ::Min(BoxMaxX,Frame->X);

	mov	ebx, DWORD PTR _BoxMaxX$15708[ebp]
	test	edx, edx
	setl	cl
	dec	ecx
	xor	eax, eax
	and	ecx, edx
	test	edi, edi
	setl	al
	mov	DWORD PTR -20+[ebp], ecx
	mov	ecx, DWORD PTR _Result$[ebp]
	fild	DWORD PTR -20+[ebp]
	dec	eax
	and	eax, edi
	fstp	DWORD PTR [ecx]
	mov	DWORD PTR 20+[ebp], eax
	mov	eax, DWORD PTR [esi+176]
	fild	DWORD PTR 20+[ebp]
	cmp	ebx, eax
	mov	DWORD PTR 20+[ebp], ebx
	fstp	DWORD PTR [ecx+4]
	jle	SHORT $L19865
	mov	DWORD PTR 20+[ebp], eax
$L19865:
	fild	DWORD PTR 20+[ebp]

; 1022 : 	Result.MaxY  = ::Min(BoxMaxY,Frame->Y);

	mov	esi, DWORD PTR [esi+180]
	mov	ebx, DWORD PTR _BoxMaxY$15710[ebp]
	cmp	ebx, esi
	mov	DWORD PTR 20+[ebp], ebx
	fstp	DWORD PTR [ecx+8]
	jle	SHORT $L19871
	mov	DWORD PTR 20+[ebp], esi
$L19871:
	fild	DWORD PTR 20+[ebp]
	fstp	DWORD PTR [ecx+12]

; 1023 : 	Result.MinZ  = ::Max( BoxMinZ, 0.f );

	fld	DWORD PTR _BoxMinZ$15703[ebp]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L19876
	fld	DWORD PTR _BoxMinZ$15703[ebp]
	jmp	SHORT $L19877
$L19876:
	fld	DWORD PTR $T18924
$L19877:
	fstp	DWORD PTR [ecx+16]

; 1024 : 	if( !SpanBuffer || SpanBuffer->BoxIsVisible( BoxMinX, BoxMinY, BoxMaxX, BoxMaxY ) )

	mov	ecx, DWORD PTR _SpanBuffer$[ebp]
	test	ecx, ecx
	je	$L15833
	mov	eax, DWORD PTR _BoxMaxX$15708[ebp]
	push	ebx
	push	eax
	push	edi
	push	edx
	call	?BoxIsVisible@FSpanBuffer@@QAEHHHHH@Z	; FSpanBuffer::BoxIsVisible
	test	eax, eax
	jne	SHORT $L15833

; 1028 : 	}
; 1029 : 	else
; 1030 : 	{
; 1031 : 		STAT(GStat.BoxSpanOccluded++);

	inc	DWORD PTR ?GStat@@3UFRenderStats@@A+124

; 892  : 	clock(GStat.BoxTime);

	xor	eax, eax

; 893  : 

	DB	15					; 0000000fH

; 894  : 	FCoords		BoxDot[2];

	DB	49					; 00000031H

; 895  : 	FTransform	Pts[8], *Pt;

	xor	edx, edx

; 1032 : 		unclock(GStat.BoxTime);

$L19915:
	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+104
	lea	edx, DWORD PTR [ecx+eax-34]
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+104, edx
$L19725:

; 1033 : 		return 0;

	xor	eax, eax

; 1036 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L19735:

; 1034 : 	}
; 1035 : 	unguard;

	mov	eax, DWORD PTR _Err$15835[ebp]
	lea	ecx, DWORD PTR $T19733[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	ecx
	mov	DWORD PTR $T19733[ebp], eax
	call	__CxxThrowException@8
	mov	eax, $L15693
	ret	0
$L19736:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??BoundVisible@URender@@UAEHPAUFSceneNode@@PAVFBox@@PAVFSpanBuffer@@AAUFScreenBounds@@@Z@4PBDB$S15695
	push	OFFSET FLAT:$SG15837
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L15693
	ret	0
$L15833:

; 892  : 	clock(GStat.BoxTime);

	xor	eax, eax

; 893  : 

	DB	15					; 0000000fH

; 894  : 	FCoords		BoxDot[2];

	DB	49					; 00000031H

; 895  : 	FTransform	Pts[8], *Pt;

	xor	edx, edx

; 1034 : 	}
; 1035 : 	unguard;

	mov	edx, DWORD PTR ?GStat@@3UFRenderStats@@A+104
	lea	eax, DWORD PTR [edx+eax-34]
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+104, eax
$L19914:

; 1025 : 	{
; 1026 : 		unclock(GStat.BoxTime);
; 1027 : 		return 1;

	mov	eax, 1
$L15693:

; 1036 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
text$x	SEGMENT
$L19913:
	mov	eax, OFFSET FLAT:$T19884
	jmp	___CxxFrameHandler
text$x	ENDS
?BoundVisible@URender@@UAEHPAUFSceneNode@@PAVFBox@@PAVFSpanBuffer@@AAUFScreenBounds@@@Z ENDP ; URender::BoundVisible
PUBLIC	?LeafVolumetricLighting@URender@@QAEXPAUFSceneNode@@PAVUModel@@H@Z ; URender::LeafVolumetricLighting
CONST	SEGMENT
$T19990	DQ	04039000000000000r		; 25
$T19991	DQ	0c039000000000000r		; -25
CONST	ENDS
_TEXT	SEGMENT
$T19928 = 12
$T19930 = 8
$T19932 = 12
$T19941 = 12
_Frame$ = 8
_Model$ = 12
_iLeaf$ = 16
_this$ = -20
_Temp$19968 = -12
?LeafVolumetricLighting@URender@@QAEXPAUFSceneNode@@PAVUModel@@H@Z PROC NEAR ; URender::LeafVolumetricLighting

; 1063 : {

	sub	esp, 20					; 00000014H

; 1064 : 	guardSlow(URender::LeafVolumetricLighting);
; 1065 : 
; 1066 : 	// Static volumetrics.
; 1067 : 	FLeaf& Leaf = Model->Leaves(iLeaf);

	mov	edx, DWORD PTR _iLeaf$[esp+16]
	mov	DWORD PTR _this$[esp+20], ecx
	mov	ecx, DWORD PTR _Model$[esp+16]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR [ecx+204]
	lea	eax, DWORD PTR [edx+edx*4]
	push	edi
	lea	eax, DWORD PTR [esi+eax*4]

; 1068 : 	if( Leaf.iVolumetric != INDEX_NONE )

	mov	eax, DWORD PTR [eax+8]
	cmp	eax, -1
	je	$L19992

; 1069 : 	{
; 1070 : 		AActor* Actor;
; 1071 : 		for( INT i=Leaf.iVolumetric; (Actor=Model->Lights(i))!=NULL; i++ )

	mov	ecx, DWORD PTR [ecx+216]
	mov	ebx, DWORD PTR [ecx+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	ebx, ebx
	je	$L19992
	mov	edi, DWORD PTR _Frame$[esp+32]
	mov	ecx, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	mov	DWORD PTR -16+[esp+36], eax
$L15869:

; 1072 : 		{
; 1073 : 			if( Actor->LightingTag!=(INT)Stamp )

	mov	esi, DWORD PTR ?Stamp@URender@@2KA	; URender::Stamp
	mov	eax, DWORD PTR [ebx+180]
	cmp	eax, esi
	je	$Skip$15882

; 1074 : 			{
; 1075 : 				Actor->LightingTag = Stamp;
; 1076 : 				if( FDistSquared( Frame->Coords.Origin, Actor->Location ) > Square(Actor->WorldVolumetricRadius()) )

	fld	DWORD PTR [ebx+208]
	fld	DWORD PTR [ebx+204]
	fsub	DWORD PTR [edi+52]

; 1081 : 				Skip:;
; 1082 : 			}
; 1083 : 		}
; 1084 : 	}
; 1085 : 
; 1086 : 	// Dynamic volumetrics.
; 1087 : 	for( FVolActorLink* Link=LeafLights[iLeaf]; Link; Link=Link->Next )

	fxch	ST(1)
	fsub	DWORD PTR [edi+56]
	xor	edx, edx
	mov	DWORD PTR [ebx+180], esi
	mov	dl, BYTE PTR [ebx+370]
	inc	edx
	mov	DWORD PTR 12+[esp+32], edx
	fild	DWORD PTR 12+[esp+32]
	fld	DWORD PTR [ebx+212]
	fsub	DWORD PTR [edi+60]
	fld	ST(1)
	fmul	QWORD PTR $T19990
	fxch	ST(4)
	fst	DWORD PTR $T19928[esp+32]
	fxch	ST(3)
	fst	DWORD PTR $T19930[esp+32]
	fxch	ST(3)
	fmul	DWORD PTR $T19928[esp+32]
	fxch	ST(1)
	fstp	DWORD PTR $T19932[esp+32]
	fxch	ST(2)
	fmul	DWORD PTR $T19930[esp+32]
	fld	DWORD PTR $T19932[esp+32]
	fmul	DWORD PTR $T19932[esp+32]
	fxch	ST(4)
	fst	DWORD PTR $T19941[esp+32]
	fxch	ST(1)
	faddp	ST(3), ST(0)
	fmul	DWORD PTR $T19941[esp+32]
	fxch	ST(3)
	faddp	ST(2), ST(0)
	fxch	ST(2)
	fcompp
	fnstsw	ax
	test	ah, 1
	je	SHORT $L19993
	fmul	QWORD PTR $T19991
	xor	esi, esi
	lea	edx, DWORD PTR [edi+328]
	fstp	DWORD PTR 12+[esp+32]
$L15878:
	fld	DWORD PTR [edx-4]
	fld	DWORD PTR [edx-8]
	fmul	DWORD PTR [ebx+204]
	fld	DWORD PTR [edx]
	fxch	ST(2)
	fmul	DWORD PTR [ebx+208]
	fxch	ST(2)
	fmul	DWORD PTR [ebx+212]
	fxch	ST(2)
	faddp	ST(1), ST(0)
	fxch	ST(1)
	faddp	ST(1), ST(0)
	fsub	DWORD PTR [edx+4]
	fcomp	DWORD PTR 12+[esp+32]
	fnstsw	ax
	test	ah, 1
	jne	$Skip$15882
	inc	esi
	add	edx, 16					; 00000010H
	cmp	esi, 4
	jl	SHORT $L15878

; 1074 : 			{
; 1075 : 				Actor->LightingTag = Stamp;
; 1076 : 				if( FDistSquared( Frame->Coords.Origin, Actor->Location ) > Square(Actor->WorldVolumetricRadius()) )

	jmp	SHORT $L15880
$L19993:
	fstp	ST(0)
$L15880:

; 1077 : 					for( int i=0; i<4; i++ )
; 1078 : 						if( Frame->ViewPlanes[i].PlaneDot(Actor->Location) < -Actor->WorldVolumetricRadius() )
; 1079 : 							goto Skip;
; 1080 : 				FirstVolumetric = new(GDynMem)FVolActorLink( Frame->Coords, Actor, FirstVolumetric, 1 );

	mov	esi, DWORD PTR [ecx+4]
	lea	ebp, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx+8]
	add	esi, 7
	and	esi, -8					; fffffff8H
	lea	eax, DWORD PTR [esi+24]
	cmp	eax, edx
	mov	DWORD PTR [ebp], eax
	jbe	SHORT $L19952
	push	8
	push	24					; 00000018H
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	esi, DWORD PTR [ebp]
	mov	ecx, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	add	esi, 7
	and	esi, -8					; fffffff8H
	lea	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [ebp], eax
$L19952:
	test	esi, esi
	je	$L19920
	fld	DWORD PTR [ebx+212]
	fsub	DWORD PTR [edi+60]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [ebx+208]
	fsub	DWORD PTR [edi+56]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [ebx+204]
	fsub	DWORD PTR [edi+52]
	push	ecx
	lea	ecx, DWORD PTR _Temp$19968[esp+48]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	fld	DWORD PTR [edi+96]
	fmul	DWORD PTR _Temp$19968[esp+44]
	fld	DWORD PTR [edi+92]
	fmul	DWORD PTR _Temp$19968[esp+40]
	push	ecx
	lea	ecx, DWORD PTR [edi+76]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _Temp$19968[esp+40]
	fmul	DWORD PTR [edi+88]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR [esp]
	push	ecx
	lea	ecx, DWORD PTR _Temp$19968[esp+44]
	call	DWORD PTR __imp_??UFVector@@QBEMABV0@@Z
	push	ecx
	lea	edx, DWORD PTR [edi+64]
	lea	ecx, DWORD PTR _Temp$19968[esp+44]
	fstp	DWORD PTR [esp]
	push	edx
	call	DWORD PTR __imp_??UFVector@@QBEMABV0@@Z
	push	ecx
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	mov	eax, DWORD PTR _this$[esp+36]
	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+20], 1
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR [esi+16], ecx
	mov	ecx, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	jmp	SHORT $L19921
$L19920:
	xor	esi, esi
$L19921:
	mov	edx, DWORD PTR _this$[esp+36]
	mov	DWORD PTR [edx+108], esi
$Skip$15882:
	mov	eax, DWORD PTR -16+[esp+36]
	add	eax, 4
	mov	DWORD PTR -16+[esp+36], eax
	mov	ebx, DWORD PTR [eax]
	test	ebx, ebx
	jne	$L15869

; 1069 : 	{
; 1070 : 		AActor* Actor;
; 1071 : 		for( INT i=Leaf.iVolumetric; (Actor=Model->Lights(i))!=NULL; i++ )

	mov	edx, DWORD PTR _iLeaf$[esp+32]
$L15871:

; 1081 : 				Skip:;
; 1082 : 			}
; 1083 : 		}
; 1084 : 	}
; 1085 : 
; 1086 : 	// Dynamic volumetrics.
; 1087 : 	for( FVolActorLink* Link=LeafLights[iLeaf]; Link; Link=Link->Next )

	mov	eax, DWORD PTR ?LeafLights@URender@@2PAPAUFVolActorLink@@A ; URender::LeafLights
	mov	ebx, DWORD PTR [eax+edx*4]
	test	ebx, ebx
	je	$L15889
	mov	eax, DWORD PTR ?Stamp@URender@@2KA	; URender::Stamp
$L15887:

; 1088 : 	{
; 1089 : 		if( Link->Volumetric && Link->Actor->LightingTag!=(INT)Stamp )

	mov	edx, DWORD PTR [ebx+20]
	test	edx, edx
	je	SHORT $L15888
	mov	edi, DWORD PTR [ebx+12]
	cmp	DWORD PTR [edi+180], eax
	je	SHORT $L15888

; 1090 : 		{
; 1091 : 			Link->Actor->LightingTag = Stamp;
; 1092 : 			FirstVolumetric = new(GDynMem)FVolActorLink( *Link, FirstVolumetric );

	lea	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+180], eax
	mov	ebp, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [esi]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	edx, DWORD PTR [eax+24]
	cmp	edx, ebp
	mov	DWORD PTR [esi], edx
	jbe	SHORT $L19977
	push	8
	push	24					; 00000018H
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	eax, DWORD PTR [esi]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
$L19977:
	test	eax, eax
	je	SHORT $L19923
	mov	edx, ebx
	mov	esi, eax
	mov	DWORD PTR [eax+12], edi
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], ebp
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], edx
	mov	edx, DWORD PTR _this$[esp+36]
	mov	edx, DWORD PTR [edx+108]
	mov	DWORD PTR [eax+16], edx
	mov	edx, DWORD PTR [ebx+20]
	mov	DWORD PTR [eax+20], edx
	jmp	SHORT $L19924
$L19923:
	xor	eax, eax
$L19924:
	mov	edx, DWORD PTR _this$[esp+36]
	mov	DWORD PTR [edx+108], eax
	mov	eax, DWORD PTR ?Stamp@URender@@2KA	; URender::Stamp
$L15888:
	mov	ebx, DWORD PTR [ebx+16]
	test	ebx, ebx
	jne	$L15887
$L15889:

; 1093 : 		}
; 1094 : 	}
; 1095 : 	unguardSlow;
; 1096 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	12					; 0000000cH
$L19992:

; 1069 : 	{
; 1070 : 		AActor* Actor;
; 1071 : 		for( INT i=Leaf.iVolumetric; (Actor=Model->Lights(i))!=NULL; i++ )

	mov	ecx, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	jmp	$L15871
?LeafVolumetricLighting@URender@@QAEXPAUFSceneNode@@PAVUModel@@H@Z ENDP ; URender::LeafVolumetricLighting
_TEXT	ENDS
EXTRN	__imp_??GFVector@@QBE?AV0@ABV0@@Z:NEAR
EXTRN	__imp_??GFVector@@QBE?AV0@XZ:NEAR
EXTRN	__imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z:NEAR
EXTRN	__imp_?TransformPointBy@FVector@@QBE?AV1@ABVFCoords@@@Z:NEAR
EXTRN	__imp_?MirrorByVector@FVector@@QBE?AV1@ABV1@@Z:NEAR
EXTRN	__imp_?MirrorByPlane@FVector@@QBE?AV1@ABVFPlane@@@Z:NEAR
EXTRN	__imp_?StaticClass@AWarpZoneInfo@@2PAVUClass@@A:DWORD
EXTRN	?Release@FSpanBuffer@@QAEXXZ:NEAR		; FSpanBuffer::Release
EXTRN	__imp_?IsA@UObject@@QBEHPAVUClass@@@Z:NEAR
EXTRN	?CopyFromRaster@FSpanBuffer@@QAEHAAV1@HHPAUFRasterSpan@@@Z:NEAR ; FSpanBuffer::CopyFromRaster
EXTRN	?CopyFromRasterUpdate@FSpanBuffer@@QAEHAAV1@HHPAUFRasterSpan@@@Z:NEAR ; FSpanBuffer::CopyFromRasterUpdate
EXTRN	__imp_?ENGINE_Generate@@3VFName@@A:DWORD
EXTRN	__imp_??0FCoords@@QAE@ABVFVector@@000@Z:NEAR
EXTRN	__imp_??XFCoords@@QAEAAV0@ABV0@@Z:NEAR
EXTRN	?DivSqrtManTbl@@3PAMA:BYTE			; DivSqrtManTbl
EXTRN	?DivSqrtExpTbl@@3PAMA:BYTE			; DivSqrtExpTbl
EXTRN	__allshl:NEAR
EXTRN	__imp_?GMath@@3VFGlobalMath@@A:BYTE
_BSS	SEGMENT
_?Model@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUModel@@A$S15898 DD 01H DUP (?)
_?ZoneSpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15900 DB 0900H DUP (?)
_?$S113@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15902 DB 01H DUP (?)
	ALIGN	4

_?SpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15907 DD 01H DUP (?)
_?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909 DD 01H DUP (?)
_?AllPolyDrawLists@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAPAUFBspDrawList@@A$S15911 DD 01H DUP (?)
_?Merge@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15913 DD 01H DUP (?)
_?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915 DD 01H DUP (?)
_?Nodes@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUBspNodes@@A$S15917 DD 01H DUP (?)
_?Surfs@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUBspSurfs@@A$S15919 DD 01H DUP (?)
_?Poly@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspSurf@@A$S15921 DD 01H DUP (?)
_?Stack@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFNodeStack@@A$S15923 DD 01H DUP (?)
_?Pts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAPAUFTransform@@A$S15925 DD 01H DUP (?)
_?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927 DB 0cH DUP (?)
_?PolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15931 DD 01H DUP (?)
_?PolyFlagMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15933 DD 01H DUP (?)
_?ExtraPolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15935 DD 01H DUP (?)
	ALIGN	8

_?ActiveZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4_KA$S15941 DQ 01H DUP (?)
_?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943 DD 01H DUP (?)
_?iOriginalNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15945 DD 01H DUP (?)
_?iThingZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15947 DD 01H DUP (?)
_?iViewZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15949 DB 01H DUP (?)
	ALIGN	4

_?iZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15951 DB 01H DUP (?)
	ALIGN	4

_?ViewZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15953 DB 01H DUP (?)
	ALIGN	4

_?Visible@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15955 DD 01H DUP (?)
_?Mergeable@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15957 DD 01H DUP (?)
_?Outside@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15959 DD 01H DUP (?)
_?Pass@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15961 DD 01H DUP (?)
_?NumPts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15963 DD 01H DUP (?)
_?IsVolumetric@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15965 DD 01H DUP (?)
_?DrawBin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15969 DD 01H DUP (?)
_?NumActiveZones@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15971 DD 01H DUP (?)
_?ActiveZones@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAEA$S15973 DB 040H DUP (?)
_?VolCross@?KB@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFVector@@A$S16159 DB 0180H DUP (?)
_BSS	ENDS
CONST	SEGMENT
$T21145	DQ	0bff0000000000000r		; -1
$T21146	DQ	04000000000000000r		; 2
CONST	ENDS
xdata$x	SEGMENT
$T21069	DD	019930520H
	DD	0aH
	DD	FLAT:$T21242
	DD	05H
	DD	FLAT:$T21243
	DD	2 DUP(00H)
	ORG $+4
$T21242	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
$T21243	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	FLAT:$T21244
	DD	03H
	DD	03H
	DD	04H
	DD	02H
	DD	FLAT:$T21245
	DD	05H
	DD	05H
	DD	06H
	DD	02H
	DD	FLAT:$T21246
	DD	07H
	DD	07H
	DD	08H
	DD	02H
	DD	FLAT:$T21247
	DD	00H
	DD	08H
	DD	09H
	DD	02H
	DD	FLAT:$T21248
	ORG $+4
$T21244	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffd8H
	DD	FLAT:$L20052
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L20053
$T21245	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0fffffdd8H
	DD	FLAT:$L20055
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L20056
$T21246	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0fffffe00H
	DD	FLAT:$L20058
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L20059
$T21247	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0fffffdfcH
	DD	FLAT:$L20061
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L20062
$T21248	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0fffffe38H
	DD	FLAT:$L20063
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L20064
xdata$x	ENDS
_TEXT	SEGMENT
$T20580 = -208
$T20582 = -192
$T20584 = -196
$T20586 = -204
$T20588 = -188
$T20590 = -224
$T20592 = -220
$T20594 = -212
$T20595 = -1044
$T20596 = -320
$T20597 = -356
$T20598 = -344
$T20599 = -564
$T20600 = -1092
$T20601 = -888
$T20602 = -624
$T20603 = -636
$T20604 = -648
$T20605 = -1140
$T20606 = -672
$T20607 = -696
$T20608 = -720
$T20609 = -744
$T20645 = -548
$T20646 = -508
$T20647 = -816
$T20648 = -840
$T20649 = -768
$T20651 = -792
$T20663 = -24
$T20664 = -32
$T20668 = -804
_Normal$20674 = -136
_i$20721 = -20
$T20758 = -200
$T20762 = -216
$T20763 = -296
$T20764 = -308
$T20765 = -332
$T20766 = -660
$T20767 = -864
$T20783 = -112
$T20784 = -684
$T20785 = -828
$T20786 = -708
$T20787 = -876
$T20790 = -40
$T20801 = -404
$T20802 = -732
$T20803 = -852
$T20804 = -756
$T20805 = -900
$T20818 = -780
_Normal$20824 = -124
$T20831 = -20
$T20844 = -32
_Frame$ = 8
_this$ = -28
$T20002 = -272
$T20003 = -612
$T20004 = 8
$T20017 = -20
$T20018 = -948
$T20020 = -420
$T20021 = -20
$T20022 = -172
$T20024 = -612
$T20025 = -996
$T20026 = -24
$T20027 = -436
$T20030 = -452
$T20031 = -40
$T20032 = -64
__$EHRec$ = -16
$T20049 = 8
_Viewport$15982 = -44
_RenDev$15983 = -48
_Warp$15988 = -24
_Err$15997 = -40
_Results$16014 = -536
_IsFront$16031 = -24
_Dot$16038 = -24
_IsFront$16039 = -36
$T20137 = 8
$T20138 = -124
$T20139 = -64
$T20140 = -508
$T20141 = -548
$T20142 = -332
_Sign$16047 = -32
$T20157 = -184
$T20158 = -308
$T20159 = -296
$T20160 = -344
$T20161 = -356
$T20164 = 8
$T20175 = -112
$T20176 = -320
$T20177 = -136
$T20178 = -284
$T20179 = -564
_Coords$16091 = -272
_Bounds$16092 = -476
_Err$16093 = -552
_Bounds$16104 = -496
_Err$16112 = -512
_RenderPortal$16118 = -32
_iOppositeZone$16119 = -52
_Warp$16121 = -20
_OldMask$16126 = -280
_Err$16151 = -516
_NumVolCross$16163 = -20
_Err$16243 = -456
?OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z PROC NEAR	; URender::OccludeBsp

; 1099 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L21228
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 1124				; 00000464H

; 1100 : 	static UModel*				Model;
; 1101 : 	static FSpanBuffer			ZoneSpanBuffer[UBspNodes::MAX_ZONES];

	mov	al, BYTE PTR _?$S113@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15902
	push	ebx
	push	esi
	push	edi
	test	al, 1
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	jne	SHORT $L15903
	mov	dl, al
	push	OFFSET FLAT:_$E114
	or	dl, 1
	mov	BYTE PTR _?$S113@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15902, dl
	call	_atexit
	add	esp, 4
$L15903:

; 1106 : 	static FBspNode*			Node;
; 1107 : 	static UBspNodes*			Nodes;
; 1108 : 	static UBspSurfs*			Surfs;
; 1109 : 	static FBspSurf*			Poly;
; 1110 : 	static FNodeStack*			Stack;
; 1111 : 	static FTransform 			**Pts;
; 1112 : 	static FVector				Origin;

	mov	al, BYTE PTR _?$S113@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15902
	test	al, 2
	jne	SHORT $L15928
	mov	dl, al
	push	OFFSET FLAT:_$E115
	or	dl, 2
	mov	BYTE PTR _?$S113@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15902, dl
	call	_atexit
	add	esp, 4
$L15928:

; 1113 : 	static DWORD				PolyFlags, PolyFlagMask, ExtraPolyFlags;
; 1114 : 	static FLOAT				MaxZ,MinZ;
; 1115 : 	static QWORD				ActiveZoneMask;
; 1116 : 	static INT          		iNode,iOriginalNode,iThingZone;
; 1117 : 	static BYTE					iViewZone;
; 1118 : 	static BYTE					iZone;
; 1119 : 	static BYTE					ViewZoneMask;
; 1120 : 	static INT           		Visible;
; 1121 : 	static INT					Mergeable;
; 1122 : 	static INT					Outside;
; 1123 : 	static INT					Pass;
; 1124 : 	static INT					NumPts;
; 1125 : 	static INT					IsVolumetric;
; 1126 : 	static INT					iLeaf;
; 1127 : 	static INT					DrawBin;
; 1128 : 	static INT                  NumActiveZones;
; 1129 : 	static BYTE                 ActiveZones[64];
; 1130 : 	guard(URender::OccludeBsp);
; 1131 : 	check(Frame->Level->Model->Nodes->Max()<MAX_NODES);

	mov	esi, DWORD PTR _Frame$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [eax+192]
	mov	ecx, DWORD PTR [edi+140]
	cmp	DWORD PTR [ecx+96], 65536		; 00010000H
	jl	SHORT $L15977
	push	1131					; 0000046bH
	push	OFFSET FLAT:$SG15978
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L15977:

; 1132 : 	check(Frame->Level->Model->Points->Max()<MAX_POINTS);

	mov	edx, DWORD PTR [edi+136]
	cmp	DWORD PTR [edx+96], 128000		; 0001f400H
	jl	SHORT $L15979
	push	1132					; 0000046cH
	push	OFFSET FLAT:$SG15980
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L15979:

; 1133 : 
; 1134 : 	// If unrenderable.
; 1135 : 	Model = Frame->Level->Model;
; 1136 : 	if( !Model->Nodes->Num() )

	mov	eax, DWORD PTR [edi+140]
	mov	DWORD PTR _?Model@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUModel@@A$S15898, edi
	mov	ecx, DWORD PTR [eax+92]
	test	ecx, ecx
	je	$L15976

; 1102 : 	static FSpanBuffer*			SpanBuffer;

	xor	eax, eax

; 1103 : 	static FBspDrawList*		TempDrawList;

	DB	15					; 0000000fH

; 1104 : 	static FBspDrawList**		AllPolyDrawLists;

	DB	49					; 00000031H

; 1105 : 	static FBspDrawList*		Merge;

	xor	edx, edx

; 1137 : 		return;
; 1138 : 
; 1139 : 	// Start clocking stats.
; 1140 : 	STAT(clock(GStat.OcclusionTime));

	mov	ebx, DWORD PTR ?GStat@@3UFRenderStats@@A+64

; 1141 : 
; 1142 : 	// Init temporary caches.
; 1143 : 	Stamp++;

	mov	edi, DWORD PTR ?Stamp@URender@@2KA	; URender::Stamp
	sub	ebx, eax

; 1144 : 
; 1145 : 	// Init.
; 1146 : 	UViewport* Viewport = Frame->Viewport;

	mov	eax, DWORD PTR [esi]
	inc	edi

; 1147 : 	URenderDevice* RenDev = Viewport->RenDev;
; 1148 : 	TempDrawList		= new(GMem)FBspDrawList;

	push	8
	mov	ecx, DWORD PTR [eax+112]
	push	80					; 00000050H
	mov	DWORD PTR _RenDev$15983[ebp], ecx
	mov	ecx, DWORD PTR __imp_?GMem@@3VFMemStack@@A
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+64, ebx
	mov	DWORD PTR ?Stamp@URender@@2KA, edi	; URender::Stamp
	mov	DWORD PTR _Viewport$15982[ebp], eax
	call	DWORD PTR __imp_?PushBytes@FMemStack@@QAEPAEHH@Z

; 1149 : 	AllPolyDrawLists    = new(GMem,MEM_Zeroed,Model->Surfs->Max())FBspDrawList*;

	mov	edx, DWORD PTR _?Model@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUModel@@A$S15898
	mov	edi, DWORD PTR __imp_?GMem@@3VFMemStack@@A
	mov	DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909, eax
	mov	eax, DWORD PTR [edx+144]
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	add	esi, 7
	mov	eax, DWORD PTR [eax+96]
	and	esi, -8					; fffffff8H
	lea	ebx, DWORD PTR [eax*4]
	lea	eax, DWORD PTR [esi+ebx]
	cmp	eax, ecx
	mov	DWORD PTR [edi+4], eax
	jbe	SHORT $L20110
	push	8
	push	ebx
	mov	ecx, edi
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	esi, DWORD PTR [edi+4]
	add	esi, 7
	and	esi, -8					; fffffff8H
	lea	ecx, DWORD PTR [esi+ebx]
	mov	DWORD PTR [edi+4], ecx
$L20110:
	push	ebx
	push	0
	push	esi
	call	DWORD PTR __imp_?appMemset@@YAPAXPAXHH@Z

; 1150 : 	Nodes				= Model->Nodes;

	mov	eax, DWORD PTR _?Model@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUModel@@A$S15898

; 1151 : 	Surfs				= Model->Surfs;
; 1152 : 	Origin				= Frame->Coords.Origin;

	mov	ebx, DWORD PTR _Frame$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _?AllPolyDrawLists@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAPAUFBspDrawList@@A$S15911, esi
	mov	edi, DWORD PTR [eax+140]
	mov	edx, DWORD PTR [eax+144]
	lea	eax, DWORD PTR [ebx+52]
	mov	DWORD PTR _?Surfs@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUBspSurfs@@A$S15919, edx
	mov	DWORD PTR _?Nodes@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUBspNodes@@A$S15917, edi
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927, ecx

; 1153 : 	iViewZone			= Frame->ZoneNumber;

	mov	cl, BYTE PTR [ebx+24]
	mov	edx, DWORD PTR [eax+4]
	mov	BYTE PTR _?iViewZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15949, cl

; 1154 : 	ViewZoneMask		= iViewZone ? ~0 : 0;
; 1155 : 	NumActiveZones      = 1;
; 1156 : 	ActiveZones[0]      = iViewZone;
; 1157 : 	ActiveZoneMask		= ((QWORD)1) << iViewZone;

	mov	esi, DWORD PTR _?iViewZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15949
	mov	DWORD PTR _?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927+4, edx
	mov	eax, DWORD PTR [eax+8]
	mov	BYTE PTR _?ActiveZones@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAEA$S15973, cl
	mov	DWORD PTR _?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927+8, eax
	mov	al, cl
	neg	al
	sbb	eax, eax
	and	esi, 255				; 000000ffH
	mov	BYTE PTR _?ViewZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15953, al
	mov	eax, 1
	mov	ecx, esi
	xor	edx, edx
	mov	DWORD PTR _?NumActiveZones@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15971, eax
	call	__allshl
	mov	DWORD PTR _?ActiveZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4_KA$S15941, eax

; 1158 : 	IsVolumetric        = RenDev->VolumetricLighting && RenDev->SupportsFogMaps && Viewport->Actor->Region.Zone->bFogZone;

	mov	eax, DWORD PTR _RenDev$15983[ebp]
	mov	DWORD PTR _?ActiveZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4_KA$S15941+4, edx
	mov	ecx, DWORD PTR [eax+120]
	test	ecx, ecx
	je	SHORT $L21218
	mov	ecx, DWORD PTR [eax+108]
	test	ecx, ecx
	je	SHORT $L21218
	mov	eax, DWORD PTR _Viewport$15982[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR [ecx+124]
	test	BYTE PTR [edx+560], 2
	je	SHORT $L19999
	mov	DWORD PTR _?IsVolumetric@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15965, 1
	jmp	SHORT $L20000
$L21218:
	mov	eax, DWORD PTR _Viewport$15982[ebp]
$L19999:
	mov	DWORD PTR _?IsVolumetric@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15965, 0
$L20000:

; 1159 : 	PolyFlagMask        = (Viewport->Actor->ShowFlags & SHOW_PlayerCtrl) ? ~0 : ~PF_Invisible;

	mov	ecx, DWORD PTR [eax+92]

; 1160 : 	ExtraPolyFlags		= Viewport->ExtraPolyFlags;

	mov	eax, DWORD PTR [eax+164]
	mov	DWORD PTR _?ExtraPolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15935, eax
	mov	edx, DWORD PTR [ecx+1036]

; 1161 : 
; 1162 : 	// If inside a warp zone, skip out and give this span buffer to the other side.
; 1163 : 	AWarpZoneInfo* Warp = (AWarpZoneInfo*)Model->Nodes->Zones[iViewZone].ZoneActor;

	lea	ecx, DWORD PTR [esi+esi*4]
	shr	edx, 11					; 0000000bH
	mov	edi, DWORD PTR [edi+ecx*4+104]
	or	edx, -2					; fffffffeH

; 1164 : 	if( Warp && Warp->IsA(AWarpZoneInfo::StaticClass) && Warp->OtherSideActor && Warp->OtherSideLevel )

	test	edi, edi
	mov	DWORD PTR _?PolyFlagMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15933, edx
	mov	DWORD PTR _Warp$15988[ebp], edi
	je	$L15990
	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR __imp_?StaticClass@AWarpZoneInfo@@2PAVUClass@@A
$L20123:
	test	eax, eax
	je	$L15990
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $L21099
	mov	eax, DWORD PTR [eax+96]
	jmp	SHORT $L20123
$L21099:
	mov	eax, DWORD PTR [edi+772]
	test	eax, eax
	je	$L15990
	mov	eax, DWORD PTR [edi+776]
	test	eax, eax
	je	$L15990

; 1165 : 	{
; 1166 : 		guard(HandleInWarp);
; 1167 : 		CreateChildFrame
; 1168 : 		(
; 1169 : 			Frame,
; 1170 : 			Frame->Span,
; 1171 : 			Frame->Level,
; 1172 : 			INDEX_NONE,
; 1173 : 			Warp->OtherSideActor->iWarpZone,
; 1174 : 			Frame->Mirror,
; 1175 : 			Frame->NearClip,
; 1176 : 			Frame->Coords * Warp->Coords * Warp->OtherSideActor->Coords.Transpose(),
; 1177 : 			1.0,
; 1178 : 			NULL
; 1179 : 		);

	mov	edx, DWORD PTR _Warp$15988[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	mov	esi, DWORD PTR [edx+772]
	mov	edx, DWORD PTR [esi+760]
	add	esi, 724				; 000002d4H
	push	edx
	fld	DWORD PTR [esi+44]
	fld	DWORD PTR [esi+32]
	fld	DWORD PTR [esi+20]
	fstp	DWORD PTR $T20138[ebp]
	mov	eax, DWORD PTR [esi+40]
	fstp	DWORD PTR $T20138[ebp+4]
	mov	ecx, eax
	mov	DWORD PTR $T20137[ebp], eax
	fstp	DWORD PTR $T20138[ebp+8]
	fld	DWORD PTR [esi+28]
	fld	DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR $T20139[ebp+8], ecx
	mov	ecx, DWORD PTR [esi+12]
	push	eax
	fstp	DWORD PTR $T20139[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T20140[ebp]
	fstp	DWORD PTR $T20139[ebp+4]
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	lea	edx, DWORD PTR $T20141[ebp]
	push	esi
	push	edx
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	lea	ecx, DWORD PTR $T20142[ebp]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR __imp_??GFVector@@QBE?AV0@XZ
	lea	edx, DWORD PTR $T20138[ebp]
	lea	ecx, DWORD PTR $T20139[ebp]
	push	edx
	push	ecx
	push	edi
	push	eax
	lea	ecx, DWORD PTR $T20002[ebp]
	call	DWORD PTR __imp_??0FCoords@@QAE@ABVFVector@@000@Z
	mov	edx, DWORD PTR _Warp$15988[ebp]
	lea	esi, DWORD PTR [ebx+52]
	mov	ecx, 12					; 0000000cH
	lea	edi, DWORD PTR $T20157[ebp]
	lea	eax, DWORD PTR [edx+724]
	mov	DWORD PTR $T20164[ebp], eax
	push	eax
	rep movsd
	lea	eax, DWORD PTR $T20158[ebp]
	lea	ecx, DWORD PTR $T20157[ebp]
	push	eax
	call	DWORD PTR __imp_?TransformPointBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR $T20164[ebp]
	mov	DWORD PTR $T20157[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T20159[ebp]
	mov	DWORD PTR $T20157[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	push	esi
	push	ecx
	lea	ecx, DWORD PTR $T20157[ebp+12]
	mov	DWORD PTR $T20157[ebp+8], eax
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	DWORD PTR $T20157[ebp+12], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T20157[ebp+16], ecx
	mov	edx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR $T20160[ebp]
	lea	ecx, DWORD PTR $T20157[ebp+24]
	push	eax
	mov	DWORD PTR $T20157[ebp+20], edx
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	DWORD PTR $T20157[ebp+24], ecx
	mov	edx, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T20161[ebp]
	mov	DWORD PTR $T20157[ebp+28], edx
	mov	eax, DWORD PTR [eax+8]
	push	ecx
	lea	ecx, DWORD PTR $T20157[ebp+36]
	mov	DWORD PTR $T20157[ebp+32], eax
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	edx, DWORD PTR [eax]
	lea	esi, DWORD PTR $T20157[ebp]
	mov	DWORD PTR $T20157[ebp+36], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T20157[ebp+40], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	ecx, 12					; 0000000cH
	lea	edi, DWORD PTR $T20175[ebp]
	mov	DWORD PTR $T20157[ebp+44], edx
	lea	eax, DWORD PTR $T20002[ebp]
	rep movsd
	lea	ecx, DWORD PTR $T20176[ebp]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T20175[ebp]
	call	DWORD PTR __imp_?TransformPointBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T20175[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T20175[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR $T20002[ebp]
	lea	ecx, DWORD PTR $T20177[ebp]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T20175[ebp+12]
	mov	DWORD PTR $T20175[ebp+8], edx
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T20175[ebp+12], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T20175[ebp+16], ecx
	mov	edx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR $T20002[ebp]
	lea	ecx, DWORD PTR $T20178[ebp]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T20175[ebp+24]
	mov	DWORD PTR $T20175[ebp+20], edx
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T20175[ebp+24], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T20175[ebp+28], ecx
	mov	edx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR $T20002[ebp]
	lea	ecx, DWORD PTR $T20179[ebp]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T20175[ebp+36]
	mov	DWORD PTR $T20175[ebp+32], edx
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	edx, DWORD PTR [eax]
	lea	esi, DWORD PTR $T20175[ebp]
	mov	DWORD PTR $T20175[ebp+36], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T20175[ebp+40], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	ecx, 12					; 0000000cH
	lea	edi, DWORD PTR $T20003[ebp]
	mov	DWORD PTR $T20175[ebp+44], edx
	push	0
	rep movsd
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR $T20003[ebp]
	push	1065353216				; 3f800000H
	push	edx
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [ebx+36]
	push	edx
	mov	edx, DWORD PTR [ebx+32]
	push	edx
	mov	edx, DWORD PTR _Warp$15988[ebp]
	mov	edx, DWORD PTR [edx+772]
	mov	edx, DWORD PTR [edx+720]
	push	edx
	mov	edx, DWORD PTR [ebx+4]
	push	-1
	push	edx
	mov	edx, DWORD PTR [ebx+148]
	push	edx
	push	ebx
	call	DWORD PTR [eax+120]

; 1102 : 	static FSpanBuffer*			SpanBuffer;

	xor	eax, eax

; 1103 : 	static FBspDrawList*		TempDrawList;

	DB	15					; 0000000fH

; 1104 : 	static FBspDrawList**		AllPolyDrawLists;

	DB	49					; 00000031H

; 1105 : 	static FBspDrawList*		Merge;

	xor	edx, edx

; 1180 : 		STAT(unclock(GStat.OcclusionTime));

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+64
	lea	edx, DWORD PTR [ecx+eax-34]
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+64, edx

; 1693 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L20052:

; 1181 : 		unguard;

	mov	eax, DWORD PTR _Err$15997[ebp]
	lea	ecx, DWORD PTR $T20004[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	ecx
	mov	DWORD PTR $T20004[ebp], eax
	call	__CxxThrowException@8
	mov	eax, $L15976
	ret	0
$L20053:
	push	OFFSET FLAT:_?__FUNC_NAME__@?BB@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S15992
	push	OFFSET FLAT:$SG15999
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L15976
	ret	0
$L15990:

; 1182 : 		return;
; 1183 : 	}
; 1184 : 
; 1185 : 	// Init zone span buffers.
; 1186 : 	for( INT i=0; i<UBspNodes::MAX_ZONES; i++ )

	xor	esi, esi
$L16001:
	cmp	esi, 64					; 00000040H
	jge	SHORT $L16003

; 1187 : 		ZoneSpanBuffer[i].AllocIndex(0,0,&GDynMem);

	mov	edx, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	lea	eax, DWORD PTR [esi+esi*8]
	push	edx
	push	0
	push	0
	lea	ecx, DWORD PTR _?ZoneSpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15900[eax*4]
	call	?AllocIndex@FSpanBuffer@@QAEXHHPAVFMemStack@@@Z ; FSpanBuffer::AllocIndex
	inc	esi
	jmp	SHORT $L16001
$L16003:

; 1188 : 	ZoneSpanBuffer[iViewZone] = *Frame->Span;

	mov	eax, DWORD PTR _?iViewZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15949
	mov	esi, DWORD PTR [ebx+148]
	and	eax, 255				; 000000ffH

; 1189 : 
; 1190 : 	// Init unrolled recursion stack.
; 1191 : 	Stack				= new(GMem)FNodeStack;

	mov	edx, DWORD PTR __imp_?GMem@@3VFMemStack@@A
	lea	ecx, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 7
	lea	edi, DWORD PTR _?ZoneSpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15900[ecx*4]
	mov	ecx, 9
	rep movsd
	lea	esi, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx+8]
	and	al, -8					; fffffff8H
	lea	ecx, DWORD PTR [eax+24]
	cmp	ecx, edi
	mov	DWORD PTR [esi], ecx
	jbe	SHORT $L20191
	push	8
	push	24					; 00000018H
	mov	ecx, edx
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	eax, DWORD PTR [esi]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [esi], edx
$L20191:

; 1192 : 	Stack->Next			= NULL;

	xor	ecx, ecx
	mov	DWORD PTR _?Stack@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFNodeStack@@A$S15923, eax
	mov	DWORD PTR [eax+20], ecx

; 1193 : 	iNode				= 0;
; 1194 : 	Outside				= Model->RootOutside;

	mov	eax, DWORD PTR _?Model@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUModel@@A$S15898
	mov	DWORD PTR _?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943, ecx
	mov	edx, DWORD PTR [eax+240]

; 1264 : 				Outside				= Node->ChildOutside(IsFront,Outside);

$L20262:

; 1193 : 	iNode				= 0;
; 1194 : 	Outside				= Model->RootOutside;

	mov	DWORD PTR _?Outside@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15959, edx

; 1264 : 				Outside				= Node->ChildOutside(IsFront,Outside);

$L20263:

; 1195 : 	Pass				= PASS_Front;

	xor	eax, eax
$L21241:

; 1196 : 
; 1197 : 	// Process everything in the world.
; 1198 : 	for( ;; )
; 1199 : 	{
; 1200 : 		Node = &Nodes->Element(iNode);

	mov	edx, DWORD PTR _?Nodes@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUBspNodes@@A$S15917
	mov	ebx, ecx
	shl	ebx, 6
	mov	esi, DWORD PTR [edx+88]
	mov	DWORD PTR _?Pass@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15961, eax
	add	ebx, esi

; 1201 : 
; 1202 : 		// Pass 1: Process node for the first time and optionally recurse with front node.
; 1203 : 		if( Pass==PASS_Front )

	test	eax, eax
	mov	DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915, ebx
	jne	$L16008

; 1204 : 		{
; 1205 : 			// Zone mask rejection.
; 1206 : 			if( iViewZone && !(Node->ZoneMask & ActiveZoneMask))

	mov	al, BYTE PTR _?iViewZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15949
	test	al, al
	je	$L16009
	mov	eax, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR _?ActiveZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4_KA$S15941
	mov	edi, DWORD PTR _?ActiveZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4_KA$S15941+4
	and	eax, edx
	mov	edx, DWORD PTR [ebx+20]
	and	edx, edi
	or	eax, edx
	jne	$L16009

; 1207 : 			{
; 1208 : 				// Use pure zone rejection.
; 1209 : 				STAT(GStat.MaskRejectZones++);

	inc	DWORD PTR ?GStat@@3UFRenderStats@@A+204
$PopStack$16010:

; 1668 : 			}
; 1669 : 		}
; 1670 : 
; 1671 : 		// Return from recursion, noting that the node we're returning to is guaranteed visible if the
; 1672 : 		// child we're processing now is visible.
; 1673 : 		PopStack:
; 1674 : 		Stack = Stack->Next;

	mov	edx, DWORD PTR _?Stack@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFNodeStack@@A$S15923
	mov	eax, DWORD PTR [edx+20]

; 1675 : 		if( !Stack )

	test	eax, eax
	mov	DWORD PTR _?Stack@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFNodeStack@@A$S15923, eax
	jne	SHORT $L16238
$DoneRendering$16227:

; 1682 : 	DoneRendering:
; 1683 : 
; 1684 : 	// Update stats.
; 1685 : 	STAT(GStat.NumZones += Model->Nodes->NumZones);

	mov	eax, DWORD PTR _?Model@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUModel@@A$S15898
	mov	esi, DWORD PTR ?GStat@@3UFRenderStats@@A+196
	mov	ecx, DWORD PTR [eax+140]

; 1686 : 	STAT(GStat.CurZone=iViewZone);

	mov	eax, DWORD PTR _?iViewZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15949
	and	eax, 255				; 000000ffH
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+192, eax
	add	esi, edx

; 1687 : 	for( i=0; i<UBspNodes::MAX_ZONES; i++ )

	xor	eax, eax
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+196, esi
$L16239:
	cmp	eax, 64					; 00000040H
	jge	SHORT $L16241

; 1688 : 		if( ZoneSpanBuffer[i].EndY )

	lea	ecx, DWORD PTR [eax+eax*8]
	mov	edx, DWORD PTR _?ZoneSpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15900[ecx*4+4]
	test	edx, edx
	je	SHORT $L16240

; 1689 : 			STAT(GStat.VisibleZones++);

	inc	DWORD PTR ?GStat@@3UFRenderStats@@A+200
$L16240:

; 1687 : 	for( i=0; i<UBspNodes::MAX_ZONES; i++ )

	inc	eax
	jmp	SHORT $L16239
$L16241:

; 1102 : 	static FSpanBuffer*			SpanBuffer;

	xor	eax, eax

; 1103 : 	static FBspDrawList*		TempDrawList;

	DB	15					; 0000000fH

; 1104 : 	static FBspDrawList**		AllPolyDrawLists;

	DB	49					; 00000031H

; 1105 : 	static FBspDrawList*		Merge;

	xor	edx, edx

; 1690 : 
; 1691 : 	STAT(unclock(GStat.OcclusionTime));

	mov	edx, DWORD PTR ?GStat@@3UFRenderStats@@A+64
	lea	eax, DWORD PTR [edx+eax-34]
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+64, eax

; 1693 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L16238:

; 1676 : 			break;
; 1677 : 
; 1678 : 		iNode		= Stack->iNode;

	mov	ecx, DWORD PTR [eax]

; 1679 : 		Outside		= Stack->Outside;

	mov	edx, DWORD PTR [eax+12]

; 1680 : 		Pass		= Stack->Pass;

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943, ecx
	mov	DWORD PTR _?Outside@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15959, edx

; 1681 : 	}

	jmp	$L21241
$L20063:

; 1692 : 	unguard;

	mov	eax, DWORD PTR _Err$16243[ebp]
	lea	ecx, DWORD PTR $T20049[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	ecx
	mov	DWORD PTR $T20049[ebp], eax
	call	__CxxThrowException@8
	mov	eax, $L15976
	ret	0
$L20064:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S15975
	push	OFFSET FLAT:$SG16245
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L15976
	ret	0
$L15976:

; 1693 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L16009:

; 1210 : 				goto PopStack;
; 1211 : 			}
; 1212 : 
; 1213 : 			// Bound rejection.
; 1214 : 			if
; 1215 : 			(	Node->iRenderBound!=INDEX_NONE
; 1216 : 			&&	iNode<Model->Nodes->Num() 
; 1217 : 			&&	((Node->NodeFlags&NF_BoxOccluded) || !((iNode^Stamp)&15)) )

	cmp	DWORD PTR [ebx+48], -1
	je	$L16025
	mov	esi, DWORD PTR _?Model@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUModel@@A$S15898
	mov	eax, DWORD PTR [esi+140]
	cmp	ecx, DWORD PTR [eax+92]
	jge	$L16025
	test	BYTE PTR [ebx+55], 16			; 00000010H
	jne	SHORT $L16013
	mov	edi, DWORD PTR ?Stamp@URender@@2KA	; URender::Stamp
	mov	edx, ecx
	xor	edx, edi
	test	dl, 15					; 0000000fH
	jne	$L16025
$L16013:

; 1218 : 			{
; 1219 : 				// Use bounding box rejection.
; 1220 : 				Node->NodeFlags &= ~NF_BoxOccluded;

	mov	al, BYTE PTR [ebx+55]

; 1221 : 				FScreenBounds Results;
; 1222 : 				if( !BoundVisible(Frame,&Model->Bounds(Node->iRenderBound),iViewZone?NULL:&ZoneSpanBuffer[0],Results) )

	mov	esi, DWORD PTR [esi+180]
	and	al, 239					; 000000efH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ebx+55], al
	lea	eax, DWORD PTR _Results$16014[ebp]
	push	eax
	mov	al, BYTE PTR _?iViewZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15949
	mov	ebx, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [ecx]
	neg	al
	sbb	eax, eax
	not	eax
	and	eax, OFFSET FLAT:_?ZoneSpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15900
	push	eax
	mov	eax, ebx
	shl	eax, 3
	sub	eax, ebx
	lea	eax, DWORD PTR [esi+eax*4]
	push	eax
	mov	eax, DWORD PTR _Frame$[ebp]
	push	eax
	call	DWORD PTR [edx+144]
	test	eax, eax
	jne	SHORT $L16015

; 1223 : 				{
; 1224 : 					Node->NodeFlags |= NF_BoxOccluded;

	mov	eax, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	or	BYTE PTR [eax+55], 16			; 00000010H

; 1225 : 					goto PopStack;

	jmp	$PopStack$16010
$L16015:

; 1226 : 				}
; 1227 : 				if( iViewZone )

	mov	al, BYTE PTR _?iViewZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15949
	test	al, al
	je	$L21173

; 1228 : 				{
; 1229 : 					for( INT i=0; i<NumActiveZones; i++ )

	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	xor	edi, edi
$L16019:
	cmp	edi, DWORD PTR _?NumActiveZones@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15971
	jge	SHORT $L21229

; 1230 : 					{
; 1231 : 						INT iZone = ActiveZones[i];

	xor	ecx, ecx

; 1232 : 						if
; 1233 : 						(	(Node->ZoneMask & ((QWORD)1<<iZone))
; 1234 : 						&&	(ZoneSpanBuffer[iZone].BoxIsVisible(Results.MinX,Results.MinY,Results.MaxX,Results.MaxY)) )

	mov	eax, 1
	mov	cl, BYTE PTR _?ActiveZones@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAEA$S15973[edi]
	xor	edx, edx
	mov	esi, ecx
	call	__allshl
	mov	ecx, DWORD PTR [ebx+16]
	and	eax, ecx
	mov	ecx, DWORD PTR [ebx+20]
	and	edx, ecx
	or	eax, edx
	je	SHORT $L16020
	fld	DWORD PTR _Results$16014[ebp+12]
	call	__ftol
	fld	DWORD PTR _Results$16014[ebp+8]
	push	eax
	call	__ftol
	fld	DWORD PTR _Results$16014[ebp+4]
	push	eax
	call	__ftol
	fld	DWORD PTR _Results$16014[ebp]
	push	eax
	call	__ftol
	lea	edx, DWORD PTR [esi+esi*8]
	push	eax
	lea	ecx, DWORD PTR _?ZoneSpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15900[edx*4]
	call	?BoxIsVisible@FSpanBuffer@@QAEHHHHH@Z	; FSpanBuffer::BoxIsVisible
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	test	eax, eax
	jne	SHORT $L21171
$L16020:

; 1228 : 				{
; 1229 : 					for( INT i=0; i<NumActiveZones; i++ )

	inc	edi
	jmp	SHORT $L16019
$L21171:

; 1235 : 							break;
; 1236 : 					}
; 1237 : 					if( i==NumActiveZones )

	cmp	edi, DWORD PTR _?NumActiveZones@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15971
$L21229:
	jne	SHORT $L21172

; 1238 : 					{
; 1239 : 						STAT(GStat.BoxSpanOccluded++;);

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+124

; 1240 : 						Node->NodeFlags |= NF_BoxOccluded;

	mov	al, BYTE PTR [ebx+55]
	inc	ecx
	or	al, 16					; 00000010H
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+124, ecx
	mov	BYTE PTR [ebx+55], al

; 1241 : 						goto PopStack;

	jmp	$PopStack$16010
$L21172:
	mov	ecx, DWORD PTR _?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943
	jmp	SHORT $L16025
$L21173:
	mov	ecx, DWORD PTR _?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
$L16025:

; 1242 : 					}
; 1243 : 				}
; 1244 : 			}
; 1245 : 
; 1246 : 			// Filter dynamics.
; 1247 : 			for( FDynamicItem* Item = Dynamic(iNode,0); Item; Item=Item->FilterNext )

	mov	eax, DWORD PTR ?DynamicsCache@URender@@2PAUFDynamicsCache@1@A ; URender::DynamicsCache
	mov	esi, DWORD PTR [eax+ecx*8]
$L16028:
	test	esi, esi
	je	SHORT $L16030

; 1248 : 				Item->Filter( Viewport, Frame, iNode, Outside );

	mov	eax, DWORD PTR _?Outside@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15959
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR _Viewport$15982[ebp]
	push	ecx
	mov	ecx, DWORD PTR _Frame$[ebp]
	push	ecx
	push	eax
	mov	ecx, esi
	call	DWORD PTR [edx]
	mov	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	jmp	SHORT $L16028
$L16030:

; 1249 : 
; 1250 : 			INT IsFront       = Node->Plane.PlaneDot(Origin) > 0.0;

	fld	DWORD PTR [ebx]
	fmul	DWORD PTR _?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927
	fld	DWORD PTR [ebx+4]
	fmul	DWORD PTR _?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ebx+8]
	fmul	DWORD PTR _?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927+8
	faddp	ST(1), ST(0)
	fsub	DWORD PTR [ebx+12]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L20005
	mov	edx, 1
	jmp	SHORT $L21230
$L20005:
	xor	edx, edx
$L21230:

; 1251 : 			Stack->iFarNode   = Node->iChild[1-IsFront];

	mov	esi, DWORD PTR _?Stack@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFNodeStack@@A$S15923
	mov	eax, 9
	sub	eax, edx
	mov	DWORD PTR _IsFront$16031[ebp], edx
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1252 : 			Stack->FarOutside = Node->ChildOutside(1-IsFront,Outside);

	mov	eax, 1
	sub	eax, edx
	mov	eax, DWORD PTR _?Outside@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15959
	je	SHORT $L20226
	test	eax, eax
	jne	SHORT $L20232
	mov	al, BYTE PTR [ebx+54]
	test	al, al
	jbe	SHORT $L20223
	test	BYTE PTR [ebx+55], 33			; 00000021H
	jne	SHORT $L20223
	mov	eax, 1
	jmp	SHORT $L20224
$L20226:
	test	eax, eax
	je	SHORT $L20223
	mov	al, BYTE PTR [ebx+54]
	test	al, al
	jbe	SHORT $L20232
	test	BYTE PTR [ebx+55], 33			; 00000021H
	je	SHORT $L20223
$L20232:
	mov	eax, 1
	jmp	SHORT $L20224
$L20223:
	xor	eax, eax
$L20224:
	mov	DWORD PTR [esi+8], eax

; 1253 : 			if( Node->iChild[IsFront] != INDEX_NONE )

	mov	eax, DWORD PTR [ebx+edx*4+32]
	cmp	eax, -1
	je	$L16032

; 1254 : 			{
; 1255 : 				Stack->iNode		= iNode;
; 1256 : 				Stack->Outside		= Outside;
; 1257 : 				Stack->Pass  		= PASS_Plane;
; 1258 : 
; 1259 : 				FNodeStack* Next	= Stack;
; 1260 : 				Stack				= new(GMem)FNodeStack;

	mov	edx, DWORD PTR __imp_?GMem@@3VFMemStack@@A
	mov	edi, DWORD PTR _?Stack@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFNodeStack@@A$S15923
	mov	eax, DWORD PTR [edx+4]
	lea	esi, DWORD PTR [edx+4]
	add	eax, 7
	mov	DWORD PTR [edi], ecx
	mov	ecx, DWORD PTR _?Outside@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15959
	and	al, -8					; fffffff8H
	mov	DWORD PTR [edi+12], ecx
	mov	DWORD PTR [edi+16], 1
	lea	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [esi], ecx
	jbe	SHORT $L20241
	push	8
	push	24					; 00000018H
	mov	ecx, edx
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [esi], edx
$L20241:
	mov	DWORD PTR _?Stack@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFNodeStack@@A$S15923, eax

; 1261 : 				Stack->Next			= Next;

	mov	DWORD PTR [eax+20], edi

; 1262 : 
; 1263 : 				iNode				= Node->iChild[IsFront];

	mov	eax, DWORD PTR _IsFront$16031[ebp]

; 1264 : 				Outside				= Node->ChildOutside(IsFront,Outside);

	xor	edx, edx
	cmp	eax, edx
	mov	ecx, DWORD PTR [ebx+eax*4+32]
	mov	eax, DWORD PTR _?Outside@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15959
	mov	DWORD PTR _?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943, ecx
	je	SHORT $L20265
	cmp	eax, edx
	jne	SHORT $L20271
	mov	al, BYTE PTR [ebx+54]
	test	al, al
	jbe	$L20262
	test	BYTE PTR [ebx+55], 33			; 00000021H
	je	SHORT $L20271
	jmp	$L20262
$L20265:
	cmp	eax, edx
	je	$L20262
	mov	al, BYTE PTR [ebx+54]
	test	al, al
	jbe	SHORT $L20271
	test	BYTE PTR [ebx+55], 33			; 00000021H
	je	$L20262
$L20271:
	mov	DWORD PTR _?Outside@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15959, 1
	jmp	$L20263
$L16032:

; 1265 : 				Pass				= PASS_Front;
; 1266 : 
; 1267 : 				continue;
; 1268 : 			}
; 1269 : 			Pass = PASS_Plane;

	mov	eax, 1
	mov	DWORD PTR _?Pass@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15961, eax
$L16008:

; 1270 : 		}
; 1271 : 
; 1272 : 		// Pass 2: Process polys within this node and optionally recurse with back.
; 1273 : 		if( Pass == PASS_Plane )

	cmp	eax, 1
	jne	$PopStack$16010

; 1274 : 		{
; 1275 : 			// Zone mask rejection.
; 1276 : 			if( iViewZone && !(Node->ZoneMask & ActiveZoneMask) )

	mov	al, BYTE PTR _?iViewZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15949
	test	al, al
	je	SHORT $L16036
	mov	eax, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR _?ActiveZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4_KA$S15941
	mov	edi, DWORD PTR _?ActiveZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4_KA$S15941+4
	and	eax, edx
	mov	edx, DWORD PTR [ebx+20]
	and	edx, edi
	or	eax, edx
	jne	SHORT $L16036

; 1277 : 			{
; 1278 : 				STAT(GStat.MaskRejectZones++);

	inc	DWORD PTR ?GStat@@3UFRenderStats@@A+204

; 1279 : 				goto PopStack;

	jmp	$PopStack$16010
$L16036:

; 1280 : 			}
; 1281 : 
; 1282 : 			// Setup.
; 1283 : 			iOriginalNode	= iNode;
; 1284 : 			FLOAT Dot		= Node->Plane.PlaneDot(Origin);

	fld	DWORD PTR [ebx]
	fmul	DWORD PTR _?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927
	fld	DWORD PTR [ebx+4]
	fmul	DWORD PTR _?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927+4
	mov	DWORD PTR _?iOriginalNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15945, ecx

; 1285 : 			INT IsFront		= Dot>0.0;

	mov	DWORD PTR _IsFront$16039[ebp], 1
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ebx+8]
	fmul	DWORD PTR _?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927+8
	faddp	ST(1), ST(0)
	fsub	DWORD PTR [ebx+12]
	fst	DWORD PTR _Dot$16038[ebp]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L20008
	mov	DWORD PTR _IsFront$16039[ebp], 0
$L20008:

; 1286 : 			iThingZone      = Node->iZone[IsFront] & ViewZoneMask;

	mov	edi, DWORD PTR _IsFront$16039[ebp]
	mov	edx, DWORD PTR _?ViewZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15953
	xor	eax, eax
	and	edx, 255				; 000000ffH
	mov	al, BYTE PTR [edi+ebx+52]
	and	eax, edx

; 1287 : 
; 1288 : 			// Render dynamic stuff in front of the plane.
; 1289 : 			if( IsVolumetric && Node->iLeaf[IsFront]!=INDEX_NONE )

	mov	edx, DWORD PTR _?IsVolumetric@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15965
	test	edx, edx
	mov	DWORD PTR _?iThingZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15947, eax
	je	SHORT $L16040
	mov	edx, DWORD PTR [ebx+edi*4+56]
	cmp	edx, -1
	je	SHORT $L16040

; 1290 : 				LeafVolumetricLighting( Frame, Model, Node->iLeaf[IsFront] );

	mov	eax, DWORD PTR _?Model@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUModel@@A$S15898
	mov	ecx, DWORD PTR _Frame$[ebp]
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LeafVolumetricLighting@URender@@QAEXPAUFSceneNode@@PAVUModel@@H@Z ; URender::LeafVolumetricLighting
	mov	ecx, DWORD PTR _?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	mov	eax, DWORD PTR _?iThingZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15947
$L16040:

; 1291 : 			if( ZoneSpanBuffer[iThingZone].ValidLines && (Node->ChildOutside(IsFront,Outside)||Toggle) )

	lea	edx, DWORD PTR [eax+eax*8]
	mov	esi, DWORD PTR _?ZoneSpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15900[edx*4+8]
	test	esi, esi
	je	$L16046
	mov	edx, DWORD PTR _?Outside@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15959
	test	edi, edi
	je	SHORT $L20295
	test	edx, edx
	jne	SHORT $L20301
	mov	dl, BYTE PTR [ebx+54]
	test	dl, dl
	jbe	SHORT $L20292
	test	BYTE PTR [ebx+55], 33			; 00000021H
	jne	SHORT $L20292
	mov	edx, 1
	jmp	SHORT $L20293
$L20295:
	test	edx, edx
	je	SHORT $L20292
	mov	dl, BYTE PTR [ebx+54]
	test	dl, dl
	jbe	SHORT $L20301
	test	BYTE PTR [ebx+55], 33			; 00000021H
	je	SHORT $L20292
$L20301:
	mov	edx, 1
	jmp	SHORT $L20293
$L20292:
	xor	edx, edx
$L20293:
	test	edx, edx
	jne	SHORT $L16042
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+112]
	test	esi, esi
	je	SHORT $L16046
$L16042:

; 1292 : 				for( FDynamicItem* Item = Dynamic(iNode,1-IsFront); Item; Item=Item->FilterNext )

	mov	esi, DWORD PTR ?DynamicsCache@URender@@2PAUFDynamicsCache@1@A ; URender::DynamicsCache
	lea	edx, DWORD PTR [ecx+ecx]
	sub	edx, edi
	mov	esi, DWORD PTR [esi+edx*4+4]
$L16044:
	test	esi, esi
	je	SHORT $L16046

; 1293 : 					Item->PreRender( Viewport, Frame, &ZoneSpanBuffer[iThingZone], iNode, FirstVolumetric );

	mov	ebx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*8]
	mov	ebx, DWORD PTR [ebx+108]
	push	ebx
	push	ecx
	lea	ecx, DWORD PTR _?ZoneSpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15900[eax*4]
	mov	eax, DWORD PTR _Frame$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _Viewport$15982[ebp]
	push	eax
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [edx+4]
	mov	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	mov	eax, DWORD PTR _?iThingZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15947
	jmp	SHORT $L16044
$L16046:

; 1294 : 
; 1295 : 			// View frustrum rejection of the plane and back subtree.
; 1296 : 			FLOAT Sign = IsFront ? 1.0 : -1.0;

	test	edi, edi
	je	SHORT $L20009
	fld	QWORD PTR $T19299
	jmp	SHORT $L20010
$L20009:
	fld	QWORD PTR $T21145
$L20010:

; 1297 : 			if
; 1298 : 			(	(Sign * (Node->Plane | Frame->ViewSides[0]) > 0.0)
; 1299 : 			&&	(Sign * (Node->Plane | Frame->ViewSides[1]) > 0.0)
; 1300 : 			&&	(Sign * (Node->Plane | Frame->ViewSides[2]) > 0.0)
; 1301 : 			&&	(Sign * (Node->Plane | Frame->ViewSides[3]) > 0.0) )

	mov	ecx, DWORD PTR _Frame$[ebp]
	fstp	DWORD PTR _Sign$16047[ebp]
	fld	DWORD PTR [ecx+272]
	fmul	DWORD PTR [ebx]
	fld	DWORD PTR [ecx+280]
	fmul	DWORD PTR [ebx+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ecx+276]
	fmul	DWORD PTR [ebx+4]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _Sign$16047[ebp]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L21147
	fld	DWORD PTR [ecx+284]
	fmul	DWORD PTR [ebx]
	fld	DWORD PTR [ecx+292]
	fmul	DWORD PTR [ebx+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ecx+288]
	fmul	DWORD PTR [ebx+4]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _Sign$16047[ebp]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L21147
	fld	DWORD PTR [ecx+296]
	fmul	DWORD PTR [ebx]
	fld	DWORD PTR [ecx+304]
	fmul	DWORD PTR [ebx+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ecx+300]
	fmul	DWORD PTR [ebx+4]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _Sign$16047[ebp]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L21147
	fld	DWORD PTR [ecx+308]
	fmul	DWORD PTR [ebx]
	fld	DWORD PTR [ecx+316]
	fmul	DWORD PTR [ebx+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ecx+312]
	fmul	DWORD PTR [ebx+4]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _Sign$16047[ebp]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$PopStack$16010
$L21147:

; 1302 : 				goto PopStack;
; 1303 : 
; 1304 : 			// Process node and all of its coplanars.
; 1305 : 			for( ;; )
; 1306 : 			{
; 1307 : 				// Note: Can't zone mask reject coplanars due to moving brush rules.
; 1308 : 				Poly		= &Surfs->Element(Node->iSurf);

	mov	eax, DWORD PTR [ebx+28]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _?Surfs@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUBspSurfs@@A$S15919
	mov	ecx, DWORD PTR [eax+88]
	lea	eax, DWORD PTR [ecx+edx*8]

; 1309 : 				PolyFlags	= Poly->PolyFlags | ExtraPolyFlags;

	mov	edx, DWORD PTR _?ExtraPolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15935
	mov	DWORD PTR _?Poly@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspSurf@@A$S15921, eax
	mov	ecx, DWORD PTR [eax+4]

; 1310 : 
; 1311 : 				// Backface and portal reject.
; 1312 : 				if( !IsFront && Dot<-1.0 && !(PolyFlags & (PF_TwoSided|PF_Portal)) )

	mov	eax, DWORD PTR _IsFront$16039[ebp]
	or	ecx, edx
	test	eax, eax
	mov	DWORD PTR _?PolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15931, ecx
	jne	SHORT $L16053
	fld	DWORD PTR _Dot$16038[ebp]
	fcomp	QWORD PTR $T21145
	fnstsw	ax
	test	ah, 1
	je	SHORT $L16053
	test	ecx, 67109120				; 04000100H
	je	$NextCoplanar$16054
$L16053:

; 1313 : 					goto NextCoplanar;
; 1314 : 				if( (PolyFlags & PF_Portal) && iViewZone==0 )

	test	ecx, 67108864				; 04000000H
	je	SHORT $L16056
	mov	al, BYTE PTR _?iViewZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15949
	test	al, al
	je	$NextCoplanar$16054
$L16056:

; 1315 : 					goto NextCoplanar;
; 1316 : 
; 1317 : 				// Get zones.
; 1318 : 				iZone         = Node->iZone[IsFront  ] & ViewZoneMask;

	mov	edx, DWORD PTR _IsFront$16039[ebp]
	mov	cl, BYTE PTR _?ViewZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15953
	mov	al, BYTE PTR [edx+ebx+52]
	and	al, cl
	mov	BYTE PTR _?iZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15951, al

; 1319 : 				SpanBuffer    = &ZoneSpanBuffer[iZone];

	mov	eax, DWORD PTR _?iZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15951
	and	eax, 255				; 000000ffH
	lea	ecx, DWORD PTR [eax+eax*8]
	lea	eax, DWORD PTR _?ZoneSpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15900[ecx*4]
	mov	DWORD PTR _?SpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15907, eax

; 1320 : 
; 1321 : 				// Span reject.
; 1322 : 				if( SpanBuffer->ValidLines <= 0 )

	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	jle	$NextCoplanar$16054

; 1102 : 	static FSpanBuffer*			SpanBuffer;

	xor	eax, eax

; 1103 : 	static FBspDrawList*		TempDrawList;

	DB	15					; 0000000fH

; 1104 : 	static FBspDrawList**		AllPolyDrawLists;

	DB	49					; 00000031H

; 1105 : 	static FBspDrawList*		Merge;

	xor	edx, edx

; 1323 : 					goto NextCoplanar;
; 1324 : 
; 1325 : 				// Clip it.
; 1326 : 				clock(GStat.ClipTime);

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+68

; 1327 : 				STAT(GStat.NodesDone++);
; 1328 : 				NumPts = ClipBspSurf( Frame, Model, iNode, Pts );

	mov	edx, DWORD PTR _?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943
	mov	ebx, DWORD PTR ?GStat@@3UFRenderStats@@A+80
	mov	edi, DWORD PTR _Frame$[ebp]
	sub	ecx, eax
	mov	eax, DWORD PTR _?Model@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUModel@@A$S15898
	push	OFFSET FLAT:_?Pts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAPAUFTransform@@A$S15925
	push	edx
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+68, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	inc	ebx
	push	eax
	push	edi
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+80, ebx
	call	?ClipBspSurf@URender@@QAEHPAUFSceneNode@@PAVUModel@@HAAPAPAUFTransform@@@Z ; URender::ClipBspSurf
	mov	DWORD PTR _?NumPts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15963, eax

; 1102 : 	static FSpanBuffer*			SpanBuffer;

	xor	eax, eax

; 1103 : 	static FBspDrawList*		TempDrawList;

	DB	15					; 0000000fH

; 1104 : 	static FBspDrawList**		AllPolyDrawLists;

	DB	49					; 00000031H

; 1105 : 	static FBspDrawList*		Merge;

	xor	edx, edx

; 1329 : 				unclock(GStat.ClipTime);

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+68

; 1330 : 				if( !NumPts )

	mov	ebx, DWORD PTR _?NumPts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15963
	test	ebx, ebx
	lea	edx, DWORD PTR [ecx+eax-34]
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+68, edx
	je	$L21180

; 1331 : 					goto NextCoplanar;
; 1332 : 
; 1333 : 				// Fix facing.
; 1334 : 				if( (!IsFront && (PolyFlags & (PF_TwoSided | PF_Portal))) ^ Frame->Mirror==-1.f )

	mov	eax, DWORD PTR _IsFront$16039[ebp]
	test	eax, eax
	jne	SHORT $L20011
	test	DWORD PTR _?PolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15931, 67109120 ; 04000100H
	je	SHORT $L20011
	mov	ecx, 1
	jmp	SHORT $L20012
$L20011:
	xor	ecx, ecx
$L20012:
	cmp	DWORD PTR [edi+32], -1082130432		; bf800000H
	jne	SHORT $L20013
	mov	eax, 1
	jmp	SHORT $L20014
$L20013:
	xor	eax, eax
$L20014:
	xor	eax, ecx
	je	SHORT $L16066

; 1335 : 					for( INT i=0; i<NumPts/2; i++ )

	mov	esi, DWORD PTR _?Pts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAPAUFTransform@@A$S15925
	xor	ecx, ecx
$L16064:
	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jge	SHORT $L16066

; 1336 : 						Exchange( Pts[i], Pts[NumPts-i-1] );

	mov	eax, ebx
	mov	edx, DWORD PTR [esi+ecx*4]
	sub	eax, ecx
	inc	ecx
	mov	edi, DWORD PTR [esi+eax*4-4]
	lea	eax, DWORD PTR [esi+eax*4-4]
	mov	DWORD PTR [esi+ecx*4-4], edi
	mov	edi, DWORD PTR _Frame$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $L16064
$L16066:

; 1102 : 	static FSpanBuffer*			SpanBuffer;

	xor	eax, eax

; 1103 : 	static FBspDrawList*		TempDrawList;

	DB	15					; 0000000fH

; 1104 : 	static FBspDrawList**		AllPolyDrawLists;

	DB	49					; 00000031H

; 1105 : 	static FBspDrawList*		Merge;

	xor	edx, edx

; 1337 : 
; 1338 : 				// Setup.
; 1339 : 				clock(GStat.RasterTime);

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+72

; 1340 : 				if( !SetupRaster( Pts, NumPts, (Node->NodeFlags & NF_PolyOccluded) ? SpanBuffer : NULL, Frame->Y ) )

	mov	edx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	sub	ecx, eax
	mov	al, BYTE PTR [edx+55]
	mov	edx, DWORD PTR _?SpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15907
	and	al, 8
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+72, ecx
	mov	ecx, DWORD PTR [edi+180]
	neg	al
	sbb	eax, eax
	push	ecx
	mov	ecx, DWORD PTR _?NumPts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15963
	and	eax, edx
	mov	edx, DWORD PTR _?Pts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAPAUFTransform@@A$S15925
	push	eax
	push	ecx
	push	edx
	call	?SetupRaster@@YAHPAPAUFTransform@@HPAVFSpanBuffer@@H@Z ; SetupRaster
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$L16071

; 1102 : 	static FSpanBuffer*			SpanBuffer;

	xor	eax, eax

; 1103 : 	static FBspDrawList*		TempDrawList;

	DB	15					; 0000000fH

; 1104 : 	static FBspDrawList**		AllPolyDrawLists;

	DB	49					; 00000031H

; 1105 : 	static FBspDrawList*		Merge;

	xor	edx, edx

; 1341 : 				{
; 1342 : 					unclock(GStat.RasterTime);

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+72
	lea	edx, DWORD PTR [ecx+eax-34]
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+72, edx
$L21180:

; 1514 : 								goto NextCoplanar;

	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
$NextCoplanar$16054:

; 1636 : 							goto DoneRendering;
; 1637 : 					}
; 1638 : 				}
; 1639 : 
; 1640 : 				NextCoplanar:
; 1641 : 				iNode = Node->iPlane;

	mov	ebx, DWORD PTR [ebx+40]

; 1642 : 				if( iNode==INDEX_NONE )

	cmp	ebx, -1
	mov	DWORD PTR _?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943, ebx
	jne	$L16229

; 1648 : 			iNode      = iOriginalNode;

	mov	ecx, DWORD PTR _?iOriginalNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15945

; 1649 : 			Node       = &Nodes->Element(iNode);

	mov	eax, DWORD PTR _?Nodes@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUBspNodes@@A$S15917
	mov	DWORD PTR _?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943, ecx
	mov	edx, DWORD PTR [eax+88]
	shl	ecx, 6
	add	ecx, edx
	mov	DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915, ecx

; 1650 : 			Dot		   = Node->Plane.PlaneDot( Origin );
; 1651 : 			IsFront	   = Dot > 0.0;

	fld	DWORD PTR [ecx]
	fmul	DWORD PTR _?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR _?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927+8
	faddp	ST(1), ST(0)
	fsub	DWORD PTR [ecx+12]
	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L20047
	mov	esi, 1
	jmp	SHORT $L20048
$L20047:
	xor	esi, esi
$L20048:

; 1652 : 			iThingZone = Node->iZone[1-IsFront] & ViewZoneMask;

	mov	edx, ecx
	xor	eax, eax
	sub	edx, esi
	mov	al, BYTE PTR [edx+53]
	mov	edx, DWORD PTR _?ViewZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15953
	and	edx, 255				; 000000ffH
	and	eax, edx

; 1653 : 
; 1654 : 			// Render dynamic stuff behind the plane.
; 1655 : 			if( IsVolumetric && Node->iLeaf[1-IsFront]!=INDEX_NONE )

	mov	edx, DWORD PTR _?IsVolumetric@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15965
	test	edx, edx
	mov	DWORD PTR _?iThingZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15947, eax
	je	SHORT $L21204
	mov	edx, 15					; 0000000fH
	sub	edx, esi
	mov	edx, DWORD PTR [ecx+edx*4]
	cmp	edx, -1
	je	SHORT $L21204

; 1656 : 				LeafVolumetricLighting( Frame, Model, Node->iLeaf[1-IsFront] );

	mov	eax, DWORD PTR _?Model@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUModel@@A$S15898
	mov	ecx, DWORD PTR _Frame$[ebp]
	mov	ebx, DWORD PTR _this$[ebp]
	push	edx
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?LeafVolumetricLighting@URender@@QAEXPAUFSceneNode@@PAVUModel@@H@Z ; URender::LeafVolumetricLighting
	mov	ecx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	mov	eax, DWORD PTR _?iThingZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15947
	jmp	SHORT $L16230
$L21204:
	mov	ebx, DWORD PTR _this$[ebp]
$L16230:

; 1657 : 			if( ZoneSpanBuffer[iThingZone].ValidLines && (Node->ChildOutside(1-IsFront,Outside)||Toggle) )

	lea	edx, DWORD PTR [eax+eax*8]
	mov	edi, DWORD PTR _?ZoneSpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15900[edx*4+8]
	test	edi, edi
	je	$L16236
	mov	edx, 1
	sub	edx, esi
	mov	edx, DWORD PTR _?Outside@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15959
	je	SHORT $L21057
	test	edx, edx
	jne	SHORT $L21063
	mov	dl, BYTE PTR [ecx+54]
	test	dl, dl
	jbe	SHORT $L21054
	test	BYTE PTR [ecx+55], 33			; 00000021H
	jne	SHORT $L21054
	mov	ecx, 1
	jmp	SHORT $L21055
$L21057:
	test	edx, edx
	je	SHORT $L21054
	mov	dl, BYTE PTR [ecx+54]
	test	dl, dl
	jbe	SHORT $L21063
	test	BYTE PTR [ecx+55], 33			; 00000021H
	je	SHORT $L21054
$L21063:
	mov	ecx, 1
	jmp	SHORT $L21055
$L21054:
	xor	ecx, ecx
$L21055:
	test	ecx, ecx
	jne	SHORT $L16232
	mov	ecx, DWORD PTR [ebx+112]
	test	ecx, ecx
	je	SHORT $L16236
$L16232:

; 1658 : 				for( FDynamicItem* Item = Dynamic(iNode,IsFront); Item; Item=Item->FilterNext )

	mov	ecx, DWORD PTR _?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943
	mov	edi, DWORD PTR _Viewport$15982[ebp]
	lea	edx, DWORD PTR [esi+ecx*2]
	mov	ecx, DWORD PTR ?DynamicsCache@URender@@2PAUFDynamicsCache@1@A ; URender::DynamicsCache
	mov	esi, DWORD PTR [ecx+edx*4]
$L16234:
	test	esi, esi
	je	SHORT $L16236

; 1659 : 					Item->PreRender( Viewport, Frame, &ZoneSpanBuffer[iThingZone], iNode, FirstVolumetric );

	mov	ecx, DWORD PTR [ebx+108]
	mov	edx, DWORD PTR [esi]
	push	ecx
	mov	ecx, DWORD PTR _?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943
	lea	eax, DWORD PTR [eax+eax*8]
	push	ecx
	lea	ecx, DWORD PTR _?ZoneSpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15900[eax*4]
	mov	eax, DWORD PTR _Frame$[ebp]
	push	ecx
	push	eax
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+4]
	mov	esi, DWORD PTR [esi+4]
	mov	eax, DWORD PTR _?iThingZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15947
	jmp	SHORT $L16234
$L16236:

; 1660 : 
; 1661 : 			// Set up recursion for back.
; 1662 : 			if( Stack->iFarNode != INDEX_NONE )

	mov	ecx, DWORD PTR _?Stack@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFNodeStack@@A$S15923
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, -1
	je	$PopStack$16010

; 1663 : 			{
; 1664 : 				iNode				= Stack->iFarNode;
; 1665 : 				Outside				= Stack->FarOutside;

	mov	edx, DWORD PTR _?Stack@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFNodeStack@@A$S15923
	mov	ecx, eax
	mov	DWORD PTR _?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943, ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _?Outside@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15959, eax

; 1666 : 				Pass				= PASS_Front;
; 1667 : 				continue;

	jmp	$L20263
$L16229:

; 1643 : 					break;
; 1644 : 				Node	= &Nodes->Element(iNode);

	mov	ecx, DWORD PTR _?Nodes@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUBspNodes@@A$S15917
	shl	ebx, 6
	add	ebx, DWORD PTR [ecx+88]
	mov	DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915, ebx

; 1645 : 				Dot		= Node->Plane.PlaneDot(Origin);

	fld	DWORD PTR [ebx]
	fmul	DWORD PTR _?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927
	fld	DWORD PTR [ebx+4]
	fmul	DWORD PTR _?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927+4
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ebx+8]
	fmul	DWORD PTR _?Origin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4VFVector@@A$S15927+8
	faddp	ST(1), ST(0)
	fsub	DWORD PTR [ebx+12]
	fst	DWORD PTR _Dot$16038[ebp]

; 1646 : 				IsFront	= Dot > 0.0;

	fcomp	QWORD PTR $T19300
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L20045
	mov	DWORD PTR _IsFront$16039[ebp], 1
	jmp	$L21147
$L20045:
	mov	DWORD PTR _IsFront$16039[ebp], 0

; 1647 : 			}

	jmp	$L21147
$L16071:

; 1102 : 	static FSpanBuffer*			SpanBuffer;

	xor	eax, eax

; 1103 : 	static FBspDrawList*		TempDrawList;

	DB	15					; 0000000fH

; 1104 : 	static FBspDrawList**		AllPolyDrawLists;

	DB	49					; 00000031H

; 1105 : 	static FBspDrawList*		Merge;

	xor	edx, edx

; 1343 : 					goto NextCoplanar;
; 1344 : 				}
; 1345 : 				unclock(GStat.RasterTime);

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+72
	lea	edx, DWORD PTR [ecx+eax-34]

; 1346 : 
; 1347 : 				// Assimilate the texture's flags.
; 1348 : 				if( Poly->Texture )

	mov	eax, DWORD PTR _?Poly@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspSurf@@A$S15921
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+72, edx
	mov	ecx, DWORD PTR [eax]

; 1349 : 					PolyFlags |= Poly->Texture->PolyFlags;

	mov	eax, DWORD PTR _?PolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15931
	test	ecx, ecx
	je	SHORT $L21174
	or	eax, DWORD PTR [ecx+176]
$L21174:

; 1350 : 				PolyFlags &= PolyFlagMask;

	and	eax, DWORD PTR _?PolyFlagMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15933
	mov	DWORD PTR _?PolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15931, eax

; 1351 : 
; 1352 : 				// See if we should merge.
; 1353 : 				Mergeable = !(PolyFlags & (PF_NoOcclude|PF_NoMerge|PF_Portal));

	and	eax, 67174471				; 04010047H
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	DWORD PTR _?Mergeable@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15957, eax

; 1354 : 				Merge = NULL;

	mov	eax, 0
	mov	DWORD PTR _?Merge@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15913, eax

; 1355 : 				if( Mergeable )

	je	$L16078

; 1356 : 				{
; 1357 : 					AZoneInfo* ZoneActor = Frame->Level->GetZoneActor(Node->iZone[IsFront]);

	mov	ecx, DWORD PTR _IsFront$16039[ebp]
	mov	edx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	mov	al, BYTE PTR [ecx+edx+52]
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [ecx+192]
	lea	eax, DWORD PTR [eax+eax*4]
	mov	edx, DWORD PTR [edx+140]
	mov	eax, DWORD PTR [edx+eax*4+104]
	test	eax, eax
	je	SHORT $L20367
	mov	esi, eax
	jmp	SHORT $L20369
$L20367:
	mov	esi, DWORD PTR [ecx+88]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $L20370
	push	223					; 000000dfH
	push	OFFSET FLAT:??_C@_0EF@LODM@Check?5failed?3?5Actors?$CI0?$CJ?5?$FLFile?3?4?4@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L20370:
	mov	eax, DWORD PTR __imp_?StaticClass@ALevelInfo@@2PAVUClass@@A
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_?IsA@UObject@@QBEHPAVUClass@@@Z
	test	eax, eax
	jne	SHORT $L20371
	push	224					; 000000e0H
	push	OFFSET FLAT:??_C@_0GD@NDIK@Check?5failed?3?5Actors?$CI0?$CJ?9?$DOIsA?$CIALe@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L20371:
	mov	esi, DWORD PTR [esi]
$L20369:

; 1358 : 					for( Merge=AllPolyDrawLists[Node->iSurf]; Merge; Merge=Merge->SurfNext )

	mov	edx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	mov	ecx, DWORD PTR _?AllPolyDrawLists@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAPAUFBspDrawList@@A$S15911
	mov	eax, DWORD PTR [edx+28]
	mov	eax, DWORD PTR [ecx+eax*4]
$L21233:
	test	eax, eax
	mov	DWORD PTR _?Merge@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15913, eax
	je	SHORT $L21232

; 1359 : 						if( Merge->Zone==ZoneActor )

	cmp	DWORD PTR [eax+56], esi
	je	SHORT $L16078

; 1358 : 					for( Merge=AllPolyDrawLists[Node->iSurf]; Merge; Merge=Merge->SurfNext )

	mov	eax, DWORD PTR [eax+64]
	jmp	SHORT $L21233
$L16078:

; 1360 : 							break;
; 1361 : 				}
; 1362 : 
; 1363 : 				// Allocate fragment span buffer.
; 1364 : 				TempDrawList->Span.AllocIndex( RasterStartY, RasterEndY, (Merge || !RenDev->SpanBased) ? &GMem : &GDynMem );

	test	eax, eax
	jne	SHORT $L20015
$L21232:
	mov	edx, DWORD PTR _RenDev$15983[ebp]
	mov	eax, DWORD PTR [edx+96]
	test	eax, eax
	mov	eax, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	jne	SHORT $L20016
$L20015:
	mov	eax, DWORD PTR __imp_?GMem@@3VFMemStack@@A
$L20016:
	mov	ecx, DWORD PTR ?RasterStartY@@3HA	; RasterStartY
	mov	edx, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	push	eax
	mov	eax, DWORD PTR ?RasterEndY@@3HA		; RasterEndY
	push	eax
	push	ecx
	lea	ecx, DWORD PTR [edx+20]
	call	?AllocIndex@FSpanBuffer@@QAEXHHPAVFMemStack@@@Z ; FSpanBuffer::AllocIndex

; 1102 : 	static FSpanBuffer*			SpanBuffer;

	xor	eax, eax

; 1103 : 	static FBspDrawList*		TempDrawList;

	DB	15					; 0000000fH

; 1104 : 	static FBspDrawList**		AllPolyDrawLists;

	DB	49					; 00000031H

; 1105 : 	static FBspDrawList*		Merge;

	xor	edx, edx

; 1365 : 
; 1366 : 				// Perform the span buffer clipping and updating.
; 1367 : 				clock(GStat.SpanTime);

	mov	edx, DWORD PTR ?GStat@@3UFRenderStats@@A+76
	sub	edx, eax

; 1368 : 				if
; 1369 : 				(	!(PolyFlags & PF_NoOcclude)
; 1370 : 				||	(PolyFlags&(PF_Portal|PF_Invisible))==(PF_Portal|PF_Invisible) 
; 1371 : 				||	(PolyFlags&(PF_Mirrored)) )

	mov	eax, DWORD PTR _?PolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15931
	test	al, 71					; 00000047H
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+76, edx
	je	SHORT $L16081
	mov	ecx, eax
	and	ecx, 67108865				; 04000001H
	cmp	ecx, 67108865				; 04000001H
	je	SHORT $L16081
	test	eax, 134217728				; 08000000H
	jne	SHORT $L16081

; 1373 : 				else		
; 1374 : 					Visible = TempDrawList->Span.CopyFromRaster( *SpanBuffer, RasterStartY, RasterEndY, HackRaster+RasterStartY );

	mov	eax, DWORD PTR ?RasterStartY@@3HA	; RasterStartY
	mov	ecx, DWORD PTR ?RasterEndY@@3HA		; RasterEndY
	lea	edx, DWORD PTR ?HackRaster@@3PAUFRasterSpan@@A[eax*8]
	push	edx
	mov	edx, DWORD PTR _?SpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15907
	push	ecx
	push	eax
	mov	eax, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	push	edx
	lea	ecx, DWORD PTR [eax+20]
	call	?CopyFromRaster@FSpanBuffer@@QAEHAAV1@HHPAUFRasterSpan@@@Z ; FSpanBuffer::CopyFromRaster
	jmp	SHORT $L21234
$L16081:

; 1372 : 					Visible = TempDrawList->Span.CopyFromRasterUpdate( *SpanBuffer, RasterStartY, RasterEndY, HackRaster+RasterStartY );

	mov	eax, DWORD PTR ?RasterStartY@@3HA	; RasterStartY
	mov	edx, DWORD PTR ?RasterEndY@@3HA		; RasterEndY
	lea	ecx, DWORD PTR ?HackRaster@@3PAUFRasterSpan@@A[eax*8]
	push	ecx
	mov	ecx, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	push	edx
	push	eax
	mov	eax, DWORD PTR _?SpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15907
	add	ecx, 20					; 00000014H
	push	eax
	call	?CopyFromRasterUpdate@FSpanBuffer@@QAEHAAV1@HHPAUFRasterSpan@@@Z ; FSpanBuffer::CopyFromRasterUpdate
$L21234:
	mov	DWORD PTR _?Visible@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15955, eax

; 1102 : 	static FSpanBuffer*			SpanBuffer;

	xor	eax, eax

; 1103 : 	static FBspDrawList*		TempDrawList;

	DB	15					; 0000000fH

; 1104 : 	static FBspDrawList**		AllPolyDrawLists;

	DB	49					; 00000031H

; 1105 : 	static FBspDrawList*		Merge;

	xor	edx, edx

; 1375 : 				unclock(GStat.SpanTime);

	mov	edx, DWORD PTR ?GStat@@3UFRenderStats@@A+76
	lea	eax, DWORD PTR [edx+eax-34]

; 1376 : 
; 1377 : 				// Process the spans.
; 1378 : 				DrawBin = 1 + ((PolyFlags & PF_NoOcclude)!=0);

	mov	edx, DWORD PTR _?PolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15931
	mov	ecx, edx
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+76, eax

; 1379 : 				if( !Visible )

	mov	eax, DWORD PTR _?Visible@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15955
	and	cl, 71					; 00000047H
	neg	cl
	sbb	ecx, ecx
	neg	ecx
	inc	ecx
	test	eax, eax
	mov	DWORD PTR _?DrawBin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15969, ecx
	jne	SHORT $L16083

; 1380 : 				{
; 1381 : 					// Rejected, span buffer wasn't affected.
; 1382 : 					Node->NodeFlags |= NF_PolyOccluded;

	mov	eax, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915

; 1383 : 					TempDrawList->Span.Release();

	mov	edx, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	mov	cl, BYTE PTR [eax+55]
	or	cl, 8
	mov	BYTE PTR [eax+55], cl
	lea	ecx, DWORD PTR [edx+20]
	call	?Release@FSpanBuffer@@QAEXXZ		; FSpanBuffer::Release

; 1384 : 				}
; 1385 : 				else if

	jmp	$L21180
$L16083:

; 1386 : 				(	(PolyFlags & PF_FakeBackdrop)
; 1387 : 				&&	(Frame->Level->GetZoneActor(iZone)->SkyZone)
; 1388 : 				&&	(Frame->Recursion<MAX_FRAME_RECURSION-1)
; 1389 : 				&&	(Viewport->Actor->ShowFlags & SHOW_PlayerCtrl) )

	test	dl, 128					; 00000080H
	je	$L16085
	mov	ebx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR _?iZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15951
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR [ebx+192]
	lea	eax, DWORD PTR [eax+eax*4]
	mov	ecx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR [ecx+eax*4+104]
	test	eax, eax
	jne	SHORT $L20445
	mov	esi, DWORD PTR [ebx+88]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $L20446
	push	223					; 000000dfH
	push	OFFSET FLAT:??_C@_0EF@LODM@Check?5failed?3?5Actors?$CI0?$CJ?5?$FLFile?3?4?4@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L20446:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+12]
$L20461:
	test	eax, eax
	je	SHORT $L20458
	mov	ecx, DWORD PTR __imp_?StaticClass@ALevelInfo@@2PAVUClass@@A
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $L20447
	mov	eax, DWORD PTR [eax+96]
	jmp	SHORT $L20461
$L20458:
	push	224					; 000000e0H
	push	OFFSET FLAT:??_C@_0GD@NDIK@Check?5failed?3?5Actors?$CI0?$CJ?9?$DOIsA?$CIALe@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L20447:
	mov	edx, DWORD PTR [ebx+88]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _?PolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15931
$L20445:
	mov	ecx, DWORD PTR [eax+556]
	test	ecx, ecx
	je	$L16085
	cmp	DWORD PTR [edi+28], 3
	jge	$L16085
	mov	eax, DWORD PTR _Viewport$15982[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	eax, DWORD PTR [ecx+1036]
	test	ah, 8
	je	$L16085

; 1390 : 				{
; 1391 : 					// Handle sky portal.
; 1392 : 					guard(HandleSkyWarp);
; 1393 : 					AZoneInfo* SkyZone=(AZoneInfo*)Frame->Level->GetZoneActor(iZone)->SkyZone;

	mov	eax, DWORD PTR _?iZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15951
	mov	esi, DWORD PTR [edi+4]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+192]
	mov	ecx, DWORD PTR [eax+140]
	mov	eax, DWORD PTR [ecx+edx*4+104]
	test	eax, eax
	jne	SHORT $L20536
	mov	edi, DWORD PTR [esi+88]
	cmp	DWORD PTR [edi], 0
	jne	SHORT $L20537
	push	223					; 000000dfH
	push	OFFSET FLAT:??_C@_0EF@LODM@Check?5failed?3?5Actors?$CI0?$CJ?5?$FLFile?3?4?4@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L20537:
	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR __imp_?StaticClass@ALevelInfo@@2PAVUClass@@A
	mov	eax, DWORD PTR [edx+12]
$L20526:
	test	eax, eax
	je	SHORT $L20531
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $L20538
	mov	eax, DWORD PTR [eax+96]
	jmp	SHORT $L20526
$L20531:
	push	224					; 000000e0H
	push	OFFSET FLAT:??_C@_0GD@NDIK@Check?5failed?3?5Actors?$CI0?$CJ?9?$DOIsA?$CIALe@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L20538:
	mov	eax, DWORD PTR [esi+88]
	mov	eax, DWORD PTR [eax]
$L20536:

; 1394 : 					FCoords Coords = Frame->Coords;

	mov	ecx, DWORD PTR _Frame$[ebp]
	mov	ebx, DWORD PTR [eax+556]
	lea	edi, DWORD PTR _Coords$16091[ebp]

; 1395 : 					Coords *= Frame->Coords.Origin;
; 1396 : 					Coords /= SkyZone->Rotation;

	mov	edx, DWORD PTR __imp_?GMath@@3VFGlobalMath@@A
	lea	eax, DWORD PTR [ecx+52]
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	push	0
	rep movsd
	fld	DWORD PTR _Coords$16091[ebp]
	fsub	DWORD PTR [eax]
	fstp	DWORD PTR _Coords$16091[ebp]
	fld	DWORD PTR _Coords$16091[ebp+4]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR _Coords$16091[ebp+4]
	fld	DWORD PTR _Coords$16091[ebp+8]
	fsub	DWORD PTR [eax+8]
	push	0
	push	0
	fstp	DWORD PTR _Coords$16091[ebp+8]
	mov	eax, DWORD PTR [ebx+224]
	lea	ecx, DWORD PTR [eax+16384]
	sar	ecx, 2
	and	ecx, 16383				; 00003fffH
	sar	eax, 2
	fld	DWORD PTR [edx+ecx*4+140]
	and	eax, 16383				; 00003fffH
	lea	ecx, DWORD PTR [edx+ecx*4+140]
	fld	DWORD PTR [edx+eax*4+140]
	lea	eax, DWORD PTR [edx+eax*4+140]
	mov	DWORD PTR $T20596[ebp], 0
	fchs
	fstp	DWORD PTR $T20596[ebp+4]
	fstp	DWORD PTR $T20596[ebp+8]
	fld	DWORD PTR [eax]
	fld	DWORD PTR [ecx]
	lea	ecx, DWORD PTR $T20599[ebp]
	mov	DWORD PTR $T20597[ebp], 0
	fstp	DWORD PTR $T20597[ebp+4]
	mov	DWORD PTR $T20598[ebp], 1065353216	; 3f800000H
	mov	DWORD PTR $T20598[ebp+4], 0
	fstp	DWORD PTR $T20597[ebp+8]
	mov	DWORD PTR $T20598[ebp+8], 0
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	lea	edx, DWORD PTR $T20596[ebp]
	lea	ecx, DWORD PTR $T20597[ebp]
	push	edx
	lea	edx, DWORD PTR $T20598[ebp]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T20595[ebp]
	call	DWORD PTR __imp_??0FCoords@@QAE@ABVFVector@@000@Z
	push	eax
	lea	ecx, DWORD PTR _Coords$16091[ebp]
	call	DWORD PTR __imp_??XFCoords@@QAEAAV0@ABV0@@Z
	mov	eax, DWORD PTR [ebx+216]
	mov	edx, DWORD PTR __imp_?GMath@@3VFGlobalMath@@A
	lea	ecx, DWORD PTR [eax+16384]
	sar	eax, 2
	sar	ecx, 2
	and	eax, 16383				; 00003fffH
	and	ecx, 16383				; 00003fffH
	mov	esi, DWORD PTR [edx+ecx*4+140]
	lea	eax, DWORD PTR [edx+eax*4+140]
	lea	ecx, DWORD PTR [edx+ecx*4+140]
	mov	DWORD PTR $T20580[ebp], esi
	mov	edx, DWORD PTR [eax]
	mov	ecx, esi
	mov	DWORD PTR $T20582[ebp], edx
	mov	eax, edx
	mov	edx, esi
	mov	DWORD PTR $T20586[ebp], ecx
	push	edx
	push	0
	push	eax
	lea	ecx, DWORD PTR $T20601[ebp]
	mov	DWORD PTR $T20584[ebp], eax
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	mov	esi, eax
	push	0
	push	1065353216				; 3f800000H
	push	0
	lea	ecx, DWORD PTR $T20602[ebp]
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	fld	DWORD PTR $T20584[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T20586[ebp]
	fchs
	fstp	DWORD PTR [esp]
	push	0
	push	ecx
	lea	ecx, DWORD PTR $T20603[ebp]
	mov	DWORD PTR -20+[ebp], eax
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR $T20604[ebp]
	mov	edi, eax
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	mov	edx, DWORD PTR -20+[ebp]
	push	esi
	push	edx
	push	edi
	push	eax
	lea	ecx, DWORD PTR $T20600[ebp]
	call	DWORD PTR __imp_??0FCoords@@QAE@ABVFVector@@000@Z
	push	eax
	lea	ecx, DWORD PTR _Coords$16091[ebp]
	call	DWORD PTR __imp_??XFCoords@@QAEAAV0@ABV0@@Z
	mov	eax, DWORD PTR [ebx+220]
	mov	edx, DWORD PTR __imp_?GMath@@3VFGlobalMath@@A
	push	1065353216				; 3f800000H
	push	0
	lea	ecx, DWORD PTR [eax+16384]
	push	0
	sar	ecx, 2
	and	ecx, 16383				; 00003fffH
	sar	eax, 2
	mov	esi, DWORD PTR [edx+ecx*4+140]
	and	eax, 16383				; 00003fffH
	lea	ecx, DWORD PTR [edx+ecx*4+140]
	mov	DWORD PTR $T20588[ebp], esi
	lea	eax, DWORD PTR [edx+eax*4+140]
	mov	ecx, esi
	mov	DWORD PTR $T20594[ebp], ecx
	lea	ecx, DWORD PTR $T20606[ebp]
	mov	edx, DWORD PTR [eax]
	mov	eax, edx
	mov	DWORD PTR $T20590[ebp], edx
	mov	DWORD PTR $T20592[ebp], eax
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	mov	edx, DWORD PTR $T20588[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR $T20590[ebp]
	push	0
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T20607[ebp]
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	fld	DWORD PTR $T20592[ebp]
	push	0
	push	ecx
	mov	ecx, DWORD PTR $T20594[ebp]
	mov	DWORD PTR -20+[ebp], eax
	fchs
	fstp	DWORD PTR [esp]
	push	ecx
	lea	ecx, DWORD PTR $T20608[ebp]
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR $T20609[ebp]
	mov	edi, eax
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	mov	edx, DWORD PTR -20+[ebp]
	push	esi
	push	edx
	push	edi
	push	eax
	lea	ecx, DWORD PTR $T20605[ebp]
	call	DWORD PTR __imp_??0FCoords@@QAE@ABVFVector@@000@Z
	push	eax
	lea	ecx, DWORD PTR _Coords$16091[ebp]
	call	DWORD PTR __imp_??XFCoords@@QAEAAV0@ABV0@@Z

; 1397 : 					Coords /= SkyZone->Location;

	fld	DWORD PTR [ebx+204]
	fadd	DWORD PTR _Coords$16091[ebp]

; 1398 : 
; 1399 : 					FScreenBounds Bounds;
; 1400 : 					Bounds.MinY = RasterStartY;
; 1401 : 					Bounds.MaxY = RasterEndY;
; 1402 : 					Bounds.MinX = RasterStartX;
; 1403 : 					Bounds.MaxX = RasterEndX;
; 1404 : 
; 1405 : 					CreateChildFrame
; 1406 : 					(
; 1407 : 						Frame,
; 1408 : 						&TempDrawList->Span,
; 1409 : 						Frame->Level,
; 1410 : 						0,
; 1411 : 						SkyZone->Region.ZoneNumber,
; 1412 : 						Frame->Mirror,
; 1413 : 						Frame->NearClip,
; 1414 : 						Coords,
; 1415 : 						96.0,
; 1416 : 						Toggle ? NULL : &Bounds
; 1417 : 					);

	mov	esi, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR _Bounds$16092[ebp]
	mov	eax, DWORD PTR [esi+112]
	mov	edx, DWORD PTR [esi]
	fstp	DWORD PTR _Coords$16091[ebp]
	fld	DWORD PTR [ebx+208]
	fadd	DWORD PTR _Coords$16091[ebp+4]
	neg	eax
	sbb	eax, eax
	not	eax
	fstp	DWORD PTR _Coords$16091[ebp+4]
	fld	DWORD PTR [ebx+212]
	fadd	DWORD PTR _Coords$16091[ebp+8]
	and	eax, ecx
	push	eax
	lea	eax, DWORD PTR _Coords$16091[ebp]
	push	1119879168				; 42c00000H
	push	eax
	fstp	DWORD PTR _Coords$16091[ebp+8]
	fild	DWORD PTR ?RasterStartY@@3HA		; RasterStartY
	mov	eax, DWORD PTR _Frame$[ebp]
	fstp	DWORD PTR _Bounds$16092[ebp+4]
	fild	DWORD PTR ?RasterEndY@@3HA		; RasterEndY
	lea	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	ecx, DWORD PTR [eax+32]
	fstp	DWORD PTR _Bounds$16092[ebp+12]
	fild	DWORD PTR ?RasterStartX@@3HA		; RasterStartX
	push	ecx
	xor	ecx, ecx
	fstp	DWORD PTR _Bounds$16092[ebp]
	fild	DWORD PTR ?RasterEndX@@3HA		; RasterEndX
	fstp	DWORD PTR _Bounds$16092[ebp+8]
	mov	cl, BYTE PTR [ebx+132]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	0
	push	ecx
	mov	ecx, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	add	ecx, 20					; 00000014H
	push	ecx
	push	eax
	mov	ecx, esi
	call	DWORD PTR [edx+120]

; 1463 : 					unguard;

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1464 : 				}
; 1465 : 				else if( (PolyFlags & PF_Portal) && (Viewport->Actor->RendMap!=REN_Zones || (PolyFlags&PF_NoOcclude) ) )

	jmp	$L21180
$L20055:

; 1418 : 					unguard;

	mov	edx, DWORD PTR _Err$16093[ebp]
	lea	eax, DWORD PTR $T20017[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	eax
	mov	DWORD PTR $T20017[ebp], edx
	call	__CxxThrowException@8
	mov	eax, $L16088
	ret	0
$L20056:
	push	OFFSET FLAT:_?__FUNC_NAME__@?GJ@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S16087
	push	OFFSET FLAT:$SG16095
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L16088
	ret	0

; 1419 : 				}
; 1420 : 				else if

	jmp	$L21180
$L16085:

; 1421 : 				(	(PolyFlags & PF_Mirrored)
; 1422 : 				&&	(Frame->Recursion<MAX_FRAME_RECURSION-1)
; 1423 : 				&&	(Viewport->Actor->ShowFlags & SHOW_PlayerCtrl) )

	test	edx, 134217728				; 08000000H
	je	$L16097
	cmp	DWORD PTR [edi+28], 3
	jge	$L16097
	mov	ecx, DWORD PTR _Viewport$15982[ebp]
	mov	eax, DWORD PTR [ecx+92]
	mov	ecx, DWORD PTR [eax+1036]
	test	ch, 8
	je	$L16097

; 1424 : 				{
; 1425 : 					// Handle mirrored surface.
; 1426 : 					guard(HandleMirrorWarp);
; 1427 : 					if( (PolyFlags & PF_Translucent) && !RenDev->ShinySurfaces )

	mov	eax, DWORD PTR _?PolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15931
	mov	BYTE PTR __$EHRec$[ebp+12], 5
	test	al, 4
	je	SHORT $L16101
	mov	ecx, DWORD PTR _RenDev$15983[ebp]
	mov	edx, DWORD PTR [ecx+124]
	test	edx, edx
	jne	SHORT $L16101

; 1428 : 					{
; 1429 : 						PolyFlags &= ~PF_Translucent;
; 1430 : 						PolyFlags |= PF_Occlude;

	and	al, -5					; fffffffbH

; 1431 : 						DrawBin = 1;

	mov	DWORD PTR _?DrawBin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15969, 1
	or	eax, -2147483648			; 80000000H

; 1693 : }

	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR _?PolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15931, eax
	jmp	$L21235
$L16101:

; 1432 : 						goto DrawIt;
; 1433 : 					}
; 1434 : 
; 1435 : 					FScreenBounds Bounds;
; 1436 : 					Bounds.MinY = RasterStartY;

	fild	DWORD PTR ?RasterStartY@@3HA		; RasterStartY

; 1437 : 					Bounds.MaxY = RasterEndY;
; 1438 : 					Bounds.MinX = RasterStartX;
; 1439 : 					Bounds.MaxX = RasterEndX;
; 1440 : 
; 1441 : 					CreateChildFrame
; 1442 : 					(
; 1443 : 						Frame,
; 1444 : 						&TempDrawList->Span,
; 1445 : 						Frame->Level,
; 1446 : 						0,
; 1447 : 						iZone,
; 1448 : 						-Frame->Mirror,
; 1449 : 						Node->Plane.TransformPlaneByOrtho( Frame->Coords ).Flip(),
; 1450 : 						Frame->Coords.MirrorByPlane(Node->Plane),
; 1451 : 						1.0,
; 1452 : 						Toggle ? NULL : &Bounds
; 1453 : 					);

	mov	edx, DWORD PTR _Frame$[ebp]
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	push	ebx
	fstp	DWORD PTR _Bounds$16104[ebp+4]
	fild	DWORD PTR ?RasterEndY@@3HA		; RasterEndY
	lea	esi, DWORD PTR [edx+52]
	fstp	DWORD PTR _Bounds$16104[ebp+12]
	fild	DWORD PTR ?RasterStartX@@3HA		; RasterStartX
	lea	edi, DWORD PTR [esi+36]
	mov	ecx, edi
	fstp	DWORD PTR _Bounds$16104[ebp]
	fild	DWORD PTR ?RasterEndX@@3HA		; RasterEndX
	fstp	DWORD PTR _Bounds$16104[ebp+8]
	call	DWORD PTR __imp_??UFVector@@QBEMABV0@@Z
	fst	DWORD PTR -20+[ebp]
	push	ecx
	lea	eax, DWORD PTR $T20649[ebp]
	fadd	ST(0), ST(0)
	fstp	DWORD PTR [esp]
	push	eax
	mov	ecx, ebx
	call	DWORD PTR __imp_??DFVector@@QBE?AV0@M@Z
	lea	ecx, DWORD PTR $T20645[ebp]
	push	eax
	push	ecx
	mov	ecx, edi
	call	DWORD PTR __imp_??GFVector@@QBE?AV0@ABV0@@Z
	lea	edi, DWORD PTR [esi+24]
	push	ebx
	mov	ecx, edi
	call	DWORD PTR __imp_??UFVector@@QBEMABV0@@Z
	fst	DWORD PTR -20+[ebp]
	push	ecx
	lea	edx, DWORD PTR $T20651[ebp]
	fadd	ST(0), ST(0)
	fstp	DWORD PTR [esp]
	push	edx
	mov	ecx, ebx
	call	DWORD PTR __imp_??DFVector@@QBE?AV0@M@Z
	push	eax
	lea	eax, DWORD PTR $T20646[ebp]
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_??GFVector@@QBE?AV0@ABV0@@Z
	lea	ecx, DWORD PTR $T20647[ebp]
	push	ebx
	push	ecx
	lea	ecx, DWORD PTR [esi+12]
	call	DWORD PTR __imp_?MirrorByVector@FVector@@QBE?AV1@ABV1@@Z
	lea	edx, DWORD PTR $T20648[ebp]
	push	ebx
	push	edx
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_?MirrorByPlane@FVector@@QBE?AV1@ABVFPlane@@@Z
	lea	ecx, DWORD PTR $T20645[ebp]
	lea	edx, DWORD PTR $T20646[ebp]
	push	ecx
	push	edx
	push	edi
	push	eax
	lea	ecx, DWORD PTR $T20018[ebp]
	call	DWORD PTR __imp_??0FCoords@@QAE@ABVFVector@@000@Z
	mov	ecx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	fld	DWORD PTR [esi+36]
	fmul	DWORD PTR [ecx]
	fld	DWORD PTR [esi+44]
	fmul	DWORD PTR [ecx+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [esi+40]
	fmul	DWORD PTR [ecx+4]
	mov	edi, ecx
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T20664[ebp]
	fld	DWORD PTR [esi+24]
	fmul	DWORD PTR [ecx]
	fld	DWORD PTR [esi+32]
	fmul	DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [esi+12]
	push	eax
	faddp	ST(1), ST(0)
	fld	DWORD PTR [esi+28]
	fmul	DWORD PTR [ecx+4]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T20663[ebp]
	call	DWORD PTR __imp_??UFVector@@QBEMABV0@@Z
	fstp	DWORD PTR -20+[ebp]
	mov	ecx, DWORD PTR -20+[ebp]
	mov	edx, DWORD PTR $T20663[ebp]
	mov	eax, DWORD PTR $T20664[ebp]
	mov	DWORD PTR _Normal$20674[ebp], ecx
	lea	ecx, DWORD PTR $T20668[ebp]
	push	esi
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _Normal$20674[ebp+4], edx
	mov	DWORD PTR _Normal$20674[ebp+8], eax
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	lea	edx, DWORD PTR _Normal$20674[ebp]
	mov	ecx, eax
	push	edx
	call	DWORD PTR __imp_??UFVector@@QBEMABV0@@Z
	fst	DWORD PTR -20+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	esi, DWORD PTR _Bounds$16104[ebp]
	fsubr	DWORD PTR [edi+12]
	fld	DWORD PTR _Normal$20674[ebp]
	mov	eax, DWORD PTR [ecx+112]
	mov	edx, DWORD PTR [ecx]
	fchs
	fstp	DWORD PTR $T20020[ebp]
	fld	DWORD PTR _Normal$20674[ebp+4]
	fchs
	neg	eax
	fstp	DWORD PTR $T20020[ebp+4]
	fld	DWORD PTR _Normal$20674[ebp+8]
	sbb	eax, eax
	not	eax
	and	eax, esi
	mov	esi, DWORD PTR _?iZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15951
	fchs
	push	eax
	lea	eax, DWORD PTR $T20018[ebp]
	fstp	DWORD PTR $T20020[ebp+8]
	push	1065353216				; 3f800000H
	push	eax
	lea	eax, DWORD PTR $T20020[ebp]
	and	esi, 255				; 000000ffH
	fchs
	push	eax
	mov	eax, DWORD PTR _Frame$[ebp]
	fstp	DWORD PTR $T20020[ebp+12]
	fld	DWORD PTR [eax+32]
	push	ecx
	fchs
	fstp	DWORD PTR [esp]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	0
	push	esi
	mov	esi, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	add	esi, 20					; 00000014H
	push	esi
	push	eax
	call	DWORD PTR [edx+120]

; 1454 : 					DrawBin = 0;
; 1455 : 					if( !(PolyFlags & PF_NoOcclude) )

	mov	eax, DWORD PTR _?PolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15931
	mov	DWORD PTR _?DrawBin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15969, 0
	test	al, 71					; 00000047H
	jne	$L16108

; 1456 : 					{
; 1457 : 						if( RenDev->SpanBased )

	mov	ecx, DWORD PTR _RenDev$15983[ebp]
	mov	edx, DWORD PTR [ecx+96]
	test	edx, edx
	je	SHORT $L16109

; 1693 : }

	mov	BYTE PTR __$EHRec$[ebp+12], 0

; 1458 : 							goto NextCoplanar;

	jmp	$L21180
$L16109:

; 1459 : 						PolyFlags |= PF_Invisible;

	or	al, 1

; 1460 : 					}
; 1461 : 					PolyFlags |= PF_Occlude;
; 1462 : 					goto DrawIt;

	jmp	$L16108
$L20058:

; 1463 : 					unguard;

	mov	edx, DWORD PTR _Err$16112[ebp]
	lea	eax, DWORD PTR $T20021[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	eax
	mov	DWORD PTR $T20021[ebp], edx
	call	__CxxThrowException@8
	mov	eax, $L16100
	ret	0
$L20059:
	push	OFFSET FLAT:_?__FUNC_NAME__@?HB@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S16099
	push	OFFSET FLAT:$SG16114
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L16100
	ret	0
$L16100:
$L16088:
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1464 : 				}
; 1465 : 				else if( (PolyFlags & PF_Portal) && (Viewport->Actor->RendMap!=REN_Zones || (PolyFlags&PF_NoOcclude) ) )

	jmp	$L21180
$L16097:
	test	edx, 67108864				; 04000000H
	je	$L16116
	mov	ecx, DWORD PTR _Viewport$15982[ebp]
	mov	eax, DWORD PTR [ecx+92]
	cmp	DWORD PTR [eax+1040], 2
	jne	SHORT $L16117
	test	dl, 71					; 00000047H
	je	$L16116
$L16117:

; 1466 : 				{
; 1467 : 					UBOOL RenderPortal = !(PolyFlags & PF_Invisible);
; 1468 : 					BYTE iOppositeZone = Node->iZone[1-IsFront] & ViewZoneMask;

	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	mov	esi, DWORD PTR _IsFront$16039[ebp]
	mov	eax, ebx
	mov	ecx, edx
	sub	eax, esi
	not	ecx
	mov	al, BYTE PTR [eax+53]
	and	ecx, 1
	and	al, BYTE PTR _?ViewZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15953
	mov	DWORD PTR _RenderPortal$16118[ebp], ecx
	mov	BYTE PTR _iOppositeZone$16119[ebp], al

; 1469 : 					if( iOppositeZone!=0 && (PolyFlags&PF_NoOcclude) )

	je	$L16132
	test	dl, 71					; 00000047H
	je	$L16132

; 1470 : 					{
; 1471 : 						AWarpZoneInfo* Warp = (AWarpZoneInfo*)Model->Nodes->Zones[iOppositeZone].ZoneActor;

	mov	eax, DWORD PTR _iOppositeZone$16119[ebp]
	mov	edx, DWORD PTR _?Model@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVUModel@@A$S15898
	and	eax, 255				; 000000ffH
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+140]
	mov	esi, DWORD PTR [eax+ecx*4+104]

; 1472 : 						if( !Warp || !Warp->IsA(AWarpZoneInfo::StaticClass) || Frame->Recursion>=MAX_FRAME_RECURSION-1 )

	test	esi, esi
	mov	DWORD PTR _Warp$16121[ebp], esi
	je	$NormalZone$16125
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR __imp_?StaticClass@AWarpZoneInfo@@2PAVUClass@@A
$L20690:
	test	eax, eax
	je	$NormalZone$16125
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $L21100
	mov	eax, DWORD PTR [eax+96]
	jmp	SHORT $L20690
$L21100:
	cmp	DWORD PTR [edi+28], 3
	jge	$NormalZone$16125

; 1486 : 						}
; 1487 : 						else
; 1488 : 						{
; 1489 : 							// Warp zone.
; 1490 : 							if( Warp->OtherSideLevel==NULL || Warp->OtherSideActor==NULL )

	mov	eax, DWORD PTR [esi+776]
	test	eax, eax
	je	SHORT $L16134
	mov	eax, DWORD PTR [esi+772]
	test	eax, eax
	jne	SHORT $L16135
$L16134:

; 1491 : 							{
; 1492 : 								Warp->Generate();

	mov	eax, DWORD PTR __imp_?ENGINE_Generate@@3VFName@@A
	mov	edx, DWORD PTR [esi]
	push	0
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [edx+16]

; 1493 : 								if( Warp->OtherSideLevel==NULL || Warp->OtherSideActor==NULL )

	mov	eax, DWORD PTR [esi+776]
	test	eax, eax
	je	$NormalZone$16125
	mov	eax, DWORD PTR [esi+772]
	test	eax, eax
	je	$NormalZone$16125
$L16135:

; 1494 : 									goto NormalZone;
; 1495 : 							}
; 1496 : 
; 1497 : 							// Handle warp zone.
; 1498 : 							guard(HandleWarpPortal);
; 1499 : 							CreateChildFrame
; 1500 : 							(
; 1501 : 								Frame,
; 1502 : 								&TempDrawList->Span,
; 1503 : 								(ULevel*)Warp->OtherSideLevel,
; 1504 : 								Node->iSurf,
; 1505 : 								Warp->OtherSideActor->iWarpZone,
; 1506 : 								Frame->Mirror,
; 1507 : 								(IsFront ? Node->Plane.Flip() : Node->Plane).TransformPlaneByOrtho(Frame->Coords),
; 1508 : 								Frame->Coords * Warp->Coords * Warp->OtherSideActor->Coords.Transpose(),
; 1509 : 								1.0,
; 1510 : 								NULL
; 1511 : 							);

	mov	eax, DWORD PTR _IsFront$16039[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	test	eax, eax
	mov	eax, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	je	SHORT $L20028
	fld	DWORD PTR [eax]
	fchs
	fstp	DWORD PTR $T20027[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	fstp	DWORD PTR $T20027[ebp+4]
	fld	DWORD PTR [eax+8]
	fchs
	fstp	DWORD PTR $T20027[ebp+8]
	fld	DWORD PTR [eax+12]
	fchs
	lea	edx, DWORD PTR $T20027[ebp]
	fstp	DWORD PTR $T20027[ebp+12]
	mov	DWORD PTR $T20026[ebp], edx
	jmp	SHORT $L20029
$L20028:
	mov	DWORD PTR $T20026[ebp], eax
$L20029:
	mov	ecx, DWORD PTR [esi+772]
	add	ecx, 724				; 000002d4H
	push	ecx
	fld	DWORD PTR [ecx+44]
	fld	DWORD PTR [ecx+32]
	fld	DWORD PTR [ecx+20]
	fstp	DWORD PTR $T20763[ebp]
	mov	edx, DWORD PTR [ecx+40]
	fstp	DWORD PTR $T20763[ebp+4]
	mov	DWORD PTR $T20758[ebp], edx
	mov	eax, edx
	fstp	DWORD PTR $T20763[ebp+8]
	fld	DWORD PTR [ecx+28]
	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR $T20764[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR $T20764[ebp+8], eax
	fstp	DWORD PTR $T20764[ebp+4]
	fld	DWORD PTR [ecx+24]
	fld	DWORD PTR [ecx+12]
	mov	DWORD PTR $T20762[ebp], edx
	mov	eax, edx
	fstp	DWORD PTR $T20765[ebp]
	lea	edx, DWORD PTR $T20766[ebp]
	mov	DWORD PTR $T20765[ebp+8], eax
	fstp	DWORD PTR $T20765[ebp+4]
	push	edx
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	lea	ecx, DWORD PTR $T20767[ebp]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR __imp_??GFVector@@QBE?AV0@XZ
	lea	edx, DWORD PTR $T20763[ebp]
	lea	ecx, DWORD PTR $T20764[ebp]
	push	edx
	lea	edx, DWORD PTR $T20765[ebp]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T20024[ebp]
	call	DWORD PTR __imp_??0FCoords@@QAE@ABVFVector@@000@Z
	mov	ecx, DWORD PTR _Frame$[ebp]
	mov	eax, DWORD PTR _Warp$16121[ebp]
	lea	edi, DWORD PTR $T20783[ebp]
	add	eax, 724				; 000002d4H
	lea	ebx, DWORD PTR [ecx+52]
	mov	ecx, 12					; 0000000cH
	mov	esi, ebx
	lea	edx, DWORD PTR $T20784[ebp]
	rep movsd
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T20783[ebp]
	mov	DWORD PTR $T20790[ebp], eax
	call	DWORD PTR __imp_?TransformPointBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	ecx, DWORD PTR [eax]
	mov	esi, DWORD PTR $T20790[ebp]
	mov	DWORD PTR $T20783[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T20785[ebp]
	mov	DWORD PTR $T20783[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	push	esi
	push	ecx
	lea	ecx, DWORD PTR $T20783[ebp+12]
	mov	DWORD PTR $T20783[ebp+8], eax
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	DWORD PTR $T20783[ebp+12], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T20783[ebp+16], ecx
	mov	edx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR $T20786[ebp]
	lea	ecx, DWORD PTR $T20783[ebp+24]
	push	eax
	mov	DWORD PTR $T20783[ebp+20], edx
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	DWORD PTR $T20783[ebp+24], ecx
	mov	edx, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T20787[ebp]
	mov	DWORD PTR $T20783[ebp+28], edx
	mov	eax, DWORD PTR [eax+8]
	push	ecx
	lea	ecx, DWORD PTR $T20783[ebp+36]
	mov	DWORD PTR $T20783[ebp+32], eax
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	edx, DWORD PTR [eax]
	lea	esi, DWORD PTR $T20783[ebp]
	mov	DWORD PTR $T20783[ebp+36], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T20783[ebp+40], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	ecx, 12					; 0000000cH
	lea	edi, DWORD PTR $T20801[ebp]
	mov	DWORD PTR $T20783[ebp+44], edx
	lea	eax, DWORD PTR $T20024[ebp]
	rep movsd
	lea	ecx, DWORD PTR $T20802[ebp]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T20801[ebp]
	call	DWORD PTR __imp_?TransformPointBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T20801[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T20801[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR $T20024[ebp]
	lea	ecx, DWORD PTR $T20803[ebp]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T20801[ebp+12]
	mov	DWORD PTR $T20801[ebp+8], edx
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T20801[ebp+12], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T20801[ebp+16], ecx
	mov	edx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR $T20024[ebp]
	lea	ecx, DWORD PTR $T20804[ebp]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T20801[ebp+24]
	mov	DWORD PTR $T20801[ebp+20], edx
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T20801[ebp+24], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T20801[ebp+28], ecx
	mov	edx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR $T20024[ebp]
	lea	ecx, DWORD PTR $T20805[ebp]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T20801[ebp+36]
	mov	DWORD PTR $T20801[ebp+32], edx
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	edx, DWORD PTR [eax]
	lea	esi, DWORD PTR $T20801[ebp]
	fld	DWORD PTR [ebx+44]
	mov	DWORD PTR $T20801[ebp+36], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T20801[ebp+40], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR $T20026[ebp]
	mov	ecx, 12					; 0000000cH
	lea	edi, DWORD PTR $T20025[ebp]
	mov	DWORD PTR $T20801[ebp+44], edx
	rep movsd
	fmul	DWORD PTR [eax+8]
	fld	DWORD PTR [ebx+40]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ebx+36]
	fmul	DWORD PTR [eax]
	faddp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [ebx+32]
	fmul	DWORD PTR [eax+8]
	fld	DWORD PTR [ebx+28]
	fmul	DWORD PTR [eax+4]
	push	ecx
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ebx+24]
	fmul	DWORD PTR [eax]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [ebx+20]
	fmul	DWORD PTR [eax+8]
	fld	DWORD PTR [ebx+16]
	fmul	DWORD PTR [eax+4]
	push	ecx
	lea	ecx, DWORD PTR _Normal$20824[ebp]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ebx+12]
	fmul	DWORD PTR [eax]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	lea	eax, DWORD PTR $T20818[ebp]
	push	ebx
	push	eax
	mov	ecx, ebx
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	lea	ecx, DWORD PTR _Normal$20824[ebp]
	push	ecx
	mov	ecx, eax
	call	DWORD PTR __imp_??UFVector@@QBEMABV0@@Z
	mov	edx, DWORD PTR $T20026[ebp]
	mov	eax, DWORD PTR _Normal$20824[ebp]
	fst	DWORD PTR -40+[ebp]
	fsubr	DWORD PTR [edx+12]
	mov	edx, DWORD PTR _Normal$20824[ebp+8]
	mov	DWORD PTR $T20030[ebp], eax
	push	0
	lea	eax, DWORD PTR $T20025[ebp]
	push	1065353216				; 3f800000H
	mov	DWORD PTR $T20030[ebp+8], edx
	push	eax
	mov	eax, DWORD PTR _Frame$[ebp]
	lea	edx, DWORD PTR $T20030[ebp]
	mov	ecx, DWORD PTR _Normal$20824[ebp+4]
	push	edx
	mov	edx, DWORD PTR [eax+32]
	fstp	DWORD PTR $T20030[ebp+12]
	push	edx
	mov	edx, DWORD PTR _Warp$16121[ebp]
	mov	DWORD PTR $T20030[ebp+4], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR [edx+772]
	mov	edx, DWORD PTR [edx+776]
	mov	esi, DWORD PTR [ecx]
	mov	edi, DWORD PTR [edi+720]
	push	edi
	mov	edi, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	mov	edi, DWORD PTR [edi+28]
	push	edi
	push	edx
	mov	edx, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	add	edx, 20					; 00000014H
	push	edx
	push	eax
	call	DWORD PTR [esi+120]

; 1512 : 							DrawBin = 0;
; 1513 : 							if( (PolyFlags & PF_Invisible) && RenDev->SpanBased )

	mov	al, BYTE PTR _?PolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15931
	mov	DWORD PTR _?DrawBin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15969, 0
	test	al, 1
	je	SHORT $L16148
	mov	eax, DWORD PTR _RenDev$15983[ebp]
	mov	ecx, DWORD PTR [eax+96]
	test	ecx, ecx
	je	SHORT $L16148

; 1693 : }

	mov	BYTE PTR __$EHRec$[ebp+12], 0

; 1514 : 								goto NextCoplanar;

	jmp	$L21180
$L16148:

; 1515 : 							PolyFlags |= PF_Occlude;

	mov	eax, DWORD PTR _?PolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15931
$L16108:
	or	eax, -2147483648			; 80000000H

; 1693 : }

	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR _?PolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15931, eax
	jmp	$L21235
$L20061:

; 1516 : 							goto DrawIt;
; 1517 : 							unguard;

	mov	ecx, DWORD PTR _Err$16151[ebp]
	lea	edx, DWORD PTR $T20031[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	edx
	mov	DWORD PTR $T20031[ebp], ecx
	call	__CxxThrowException@8
	mov	eax, $L16139
	ret	0
$L20062:
	push	OFFSET FLAT:_?__FUNC_NAME__@?JF@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S16138
	push	OFFSET FLAT:$SG16153
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L16139
	ret	0
$L16139:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	$L21236
$NormalZone$16125:

; 1473 : 						{
; 1474 : 							// Normal zone.
; 1475 : 							NormalZone:;
; 1476 : 							QWORD OldMask = ActiveZoneMask;
; 1477 : 							ActiveZoneMask |= ((QWORD)1)<<iOppositeZone;

	mov	ebx, DWORD PTR _iOppositeZone$16119[ebp]
	mov	esi, DWORD PTR _?ActiveZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4_KA$S15941
	mov	edi, DWORD PTR _?ActiveZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4_KA$S15941+4
	and	ebx, 255				; 000000ffH
	mov	ecx, ebx
	mov	eax, 1
	xor	edx, edx
	mov	DWORD PTR _OldMask$16126[ebp], esi
	mov	DWORD PTR _OldMask$16126[ebp+4], edi
	call	__allshl
	or	esi, eax

; 1478 : 							if( ActiveZoneMask != OldMask )

	mov	eax, DWORD PTR _OldMask$16126[ebp]
	or	edi, edx
	cmp	esi, eax
	mov	DWORD PTR _?ActiveZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4_KA$S15941, esi
	mov	DWORD PTR _?ActiveZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4_KA$S15941+4, edi
	jne	SHORT $L21144
	cmp	edi, DWORD PTR _OldMask$16126[ebp+4]
	je	SHORT $L16128
$L21144:

; 1479 : 								ActiveZones[NumActiveZones++] = iOppositeZone;

	mov	eax, DWORD PTR _?NumActiveZones@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15971
	mov	cl, BYTE PTR _iOppositeZone$16119[ebp]
	mov	BYTE PTR _?ActiveZones@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAEA$S15973[eax], cl
	inc	eax
	mov	DWORD PTR _?NumActiveZones@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15971, eax
$L16128:

; 1102 : 	static FSpanBuffer*			SpanBuffer;

	xor	eax, eax

; 1103 : 	static FBspDrawList*		TempDrawList;

	DB	15					; 0000000fH

; 1104 : 	static FBspDrawList**		AllPolyDrawLists;

	DB	49					; 00000031H

; 1105 : 	static FBspDrawList*		Merge;

	xor	edx, edx

; 1480 : 							clock(GStat.SpanTime);

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+76
	sub	ecx, eax

; 1481 : 							if( RenderPortal )

	mov	eax, DWORD PTR _RenderPortal$16118[ebp]
	test	eax, eax
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+76, ecx
	je	$L16129

; 1482 : 								ZoneSpanBuffer[iOppositeZone].MergeWith( FSpanBuffer( TempDrawList->Span, GDynMem) );

	mov	edx, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	mov	esi, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	push	8
	mov	ecx, DWORD PTR [edx+20]
	lea	edi, DWORD PTR [edx+20]
	mov	DWORD PTR $T20022[ebp], ecx
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR $T20022[ebp+4], eax
	mov	edx, DWORD PTR [edi+8]
	sub	eax, ecx
	mov	ecx, esi
	shl	eax, 2
	push	eax
	mov	DWORD PTR $T20022[ebp+8], edx
	call	DWORD PTR __imp_?PushBytes@FMemStack@@QAEPAEHH@Z
	mov	DWORD PTR $T20022[ebp+12], eax
	mov	DWORD PTR $T20022[ebp+16], esi
	mov	DWORD PTR $T20022[ebp+20], esi
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR $T20022[ebp+24], eax
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR $T20022[ebp+28], ecx
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR $T20022[ebp+32], edx
	xor	eax, eax
$L21237:
	mov	ecx, DWORD PTR $T20022[ebp+4]
	mov	esi, DWORD PTR $T20022[ebp]
	sub	ecx, esi
	mov	DWORD PTR _i$20721[ebp], eax
	cmp	eax, ecx
	jge	SHORT $L20724
	mov	edx, DWORD PTR $T20022[ebp+12]
	mov	ecx, DWORD PTR [edi+12]
	shl	eax, 2
	mov	esi, DWORD PTR [ecx+eax]
	lea	ebx, DWORD PTR [edx+eax]
$L20727:
	test	esi, esi
	je	SHORT $L20729
	mov	ecx, DWORD PTR $T20022[ebp+16]
	push	4
	push	12					; 0000000cH
	call	DWORD PTR __imp_?PushBytes@FMemStack@@QAEPAEHH@Z
	test	eax, eax
	je	SHORT $L20714
	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx], eax
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	lea	ebx, DWORD PTR [eax+8]
	jmp	SHORT $L20727
$L20714:
	mov	esi, DWORD PTR [esi+8]
	xor	eax, eax
	mov	DWORD PTR [ebx], eax
	lea	ebx, DWORD PTR [eax+8]
	jmp	SHORT $L20727
$L20729:
	mov	eax, DWORD PTR _i$20721[ebp]
	mov	DWORD PTR [ebx], 0
	inc	eax
	jmp	SHORT $L21237
$L20724:
	mov	eax, DWORD PTR _iOppositeZone$16119[ebp]
	lea	edx, DWORD PTR $T20022[ebp]
	and	eax, 255				; 000000ffH
	push	edx
	lea	eax, DWORD PTR [eax+eax*8]
	lea	ecx, DWORD PTR _?ZoneSpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15900[eax*4]

; 1483 : 							else

	jmp	SHORT $L21238
$L16129:

; 1484 : 								ZoneSpanBuffer[iOppositeZone].MergeWith( TempDrawList->Span );

	mov	ecx, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	lea	edx, DWORD PTR [ebx+ebx*8]
	add	ecx, 20					; 00000014H
	push	ecx
	lea	ecx, DWORD PTR _?ZoneSpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15900[edx*4]
$L21238:
	call	?MergeWith@FSpanBuffer@@QAEXABV1@@Z	; FSpanBuffer::MergeWith

; 1102 : 	static FSpanBuffer*			SpanBuffer;

	xor	eax, eax

; 1103 : 	static FBspDrawList*		TempDrawList;

	DB	15					; 0000000fH

; 1104 : 	static FBspDrawList**		AllPolyDrawLists;

	DB	49					; 00000031H

; 1105 : 	static FBspDrawList*		Merge;

	xor	edx, edx

; 1485 : 							unclock(GStat.SpanTime);

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+76
	lea	edx, DWORD PTR [ecx+eax-34]
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+76, edx
$L21236:
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	mov	ecx, DWORD PTR _RenderPortal$16118[ebp]
$L16132:

; 1518 : 						}
; 1519 : 					}
; 1520 : 					if( RenderPortal )

	test	ecx, ecx
	je	$NextCoplanar$16054

; 1521 : 					{
; 1522 : 						// Actually display zone portals.
; 1523 : 						Merge = 0;

	mov	DWORD PTR _?Merge@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15913, 0

; 1524 : 						goto DrawIt;

	jmp	SHORT $DrawIt$16102
$L16116:

; 1525 : 					}
; 1526 : 				}
; 1527 : 				else if( !(PolyFlags & PF_Invisible) )

	test	dl, 1
	jne	$L21180
$L21235:
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
$DrawIt$16102:

; 1528 : 				{
; 1529 : 					// Draw it.
; 1530 : 					DrawIt:
; 1531 : 
; 1532 : 					// Handle volumetrics.
; 1533 : 					static FVector VolCross[32];

	mov	al, BYTE PTR _?$S113@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15902
	test	al, 4
	jne	SHORT $L16160
	mov	edi, DWORD PTR __imp_??0FVector@@QAE@XZ
	or	al, 4
	mov	BYTE PTR _?$S113@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15902, al
	mov	DWORD PTR $T20831[ebp], 32		; 00000020H
	mov	ebx, 12					; 0000000cH
	mov	esi, OFFSET FLAT:_?VolCross@?KB@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFVector@@A$S16159
$L20827:
	mov	eax, DWORD PTR $T20831[ebp]
	dec	eax
	mov	DWORD PTR $T20831[ebp], eax
	js	SHORT $L20828
	mov	ecx, esi
	call	edi
	add	esi, ebx
	jmp	SHORT $L20827
$L20828:
	push	OFFSET FLAT:_$E116
	call	_atexit
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	add	esp, 4
$L16160:

; 1534 : 					INT NumVolCross=0;
; 1535 : 					if( FirstVolumetric )

	mov	eax, DWORD PTR _this$[ebp]
	xor	edi, edi
	mov	DWORD PTR _NumVolCross$16163[ebp], edi
	mov	ecx, DWORD PTR [eax+108]
	test	ecx, ecx
	je	$L16169

; 1536 : 					{
; 1537 : 						for( FTransform** P1=Pts,**P2=Pts+NumPts-1; P1<Pts+NumPts; P2=P1++ )

	mov	eax, DWORD PTR _?Pts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAPAUFTransform@@A$S15925
	mov	ecx, DWORD PTR _?NumPts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15963
	mov	edx, eax
	lea	ecx, DWORD PTR [eax+ecx*4-4]
$L16167:
	mov	esi, DWORD PTR _?NumPts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15963
	lea	esi, DWORD PTR [eax+esi*4]
	cmp	edx, esi
	jae	$L16169

; 1538 : 						{
; 1539 : 							if( (*P2)->IntY!=INDEX_NONE )

	mov	ecx, DWORD PTR [ecx]
	cmp	DWORD PTR [ecx+24], -1
	je	$L16168

; 1540 : 							{
; 1541 : 								VolCross[NumVolCross] = (*P1)->Point ^ (*P2)->Point;

	mov	eax, DWORD PTR [edx]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [eax+4]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR $T20032[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR [eax+8]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	esi, DWORD PTR $T20032[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR $T20032[ebp+4]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edi+edi*2]
	lea	ecx, DWORD PTR _?VolCross@?KB@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFVector@@A$S16159[eax*4]
	mov	eax, ecx
	fsubp	ST(1), ST(0)
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR $T20032[ebp+4]
	fstp	DWORD PTR $T20032[ebp+8]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR $T20032[ebp+8]
	mov	DWORD PTR [eax+8], esi

; 1542 : 								VolCross[NumVolCross] *= DivSqrtApprox(VolCross[NumVolCross].SizeSquared());

	fld	DWORD PTR [ecx+4]
	fld	DWORD PTR [ecx+8]
	fld	DWORD PTR [ecx]
	fld	ST(2)
	fmul	ST(0), ST(3)
	fld	ST(2)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR $T20844[ebp]
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)

; 1099 : {

	mov	eax, DWORD PTR $T20844[ebp]
	shr	eax, 13					; 0000000dH
	mov	ebx, DWORD PTR $T20844[ebp]
	shr	ebx, 23					; 00000017H
	and	eax, 1023				; 000003ffH
	fld	DWORD PTR ?DivSqrtManTbl@@3PAMA[eax*4]
	fmul	DWORD PTR ?DivSqrtExpTbl@@3PAMA[ebx*4]
	fstp	DWORD PTR $T20844[ebp]

; 1542 : 								VolCross[NumVolCross] *= DivSqrtApprox(VolCross[NumVolCross].SizeSquared());

	fld	DWORD PTR $T20844[ebp]
	fmul	DWORD PTR [ecx]

; 1543 : 								NumVolCross++;

	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	mov	eax, DWORD PTR _?Pts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAPAUFTransform@@A$S15925
	inc	edi
	mov	DWORD PTR _NumVolCross$16163[ebp], edi
	fstp	DWORD PTR [ecx]
	fld	DWORD PTR $T20844[ebp]
	fmul	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ecx+4]
	fld	DWORD PTR $T20844[ebp]
	fmul	DWORD PTR [ecx+8]
	fstp	DWORD PTR [ecx+8]
$L16168:
	mov	ecx, edx
	add	edx, 4
	jmp	$L16167
$L16169:

; 1544 : 							}
; 1545 : 						}
; 1546 : 					}
; 1547 : 
; 1548 : 					// Save drawing info.
; 1549 : 					if( !Merge )

	mov	eax, DWORD PTR _?Merge@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15913
	test	eax, eax
	jne	$L16173

; 1550 : 					{
; 1551 : 						// Create new draw-list entry.
; 1552 : 						TempDrawList->iNode		 = iNode;

	mov	edx, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	mov	ecx, DWORD PTR _?iNode@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15943

; 1553 : 						TempDrawList->iZone		 = Node->iZone[IsFront];

	xor	eax, eax
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR _IsFront$16039[ebp]
	mov	al, BYTE PTR [ecx+ebx+52]

; 1554 : 						TempDrawList->Zone       = Frame->Level->GetZoneActor(TempDrawList->iZone);

	mov	ecx, DWORD PTR _Frame$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	esi, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+eax*4]
	mov	ecx, DWORD PTR [esi+192]
	mov	ecx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR [ecx+eax*4+104]
	test	eax, eax
	jne	SHORT $L20922
	mov	edi, DWORD PTR [esi+88]
	cmp	DWORD PTR [edi], 0
	jne	SHORT $L20923
	push	223					; 000000dfH
	push	OFFSET FLAT:??_C@_0EF@LODM@Check?5failed?3?5Actors?$CI0?$CJ?5?$FLFile?3?4?4@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	mov	edx, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	add	esp, 8
$L20923:
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+12]
$L20918:
	test	eax, eax
	je	SHORT $L20915
	mov	ecx, DWORD PTR __imp_?StaticClass@ALevelInfo@@2PAVUClass@@A
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $L20924
	mov	eax, DWORD PTR [eax+96]
	jmp	SHORT $L20918
$L20915:
	push	224					; 000000e0H
	push	OFFSET FLAT:??_C@_0GD@NDIK@Check?5failed?3?5Actors?$CI0?$CJ?9?$DOIsA?$CIALe@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	mov	edx, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	add	esp, 8
$L20924:
	mov	eax, DWORD PTR [esi+88]
	mov	eax, DWORD PTR [eax]
$L20922:

; 1555 : 						TempDrawList->iSurf		 = Node->iSurf;
; 1556 : 						TempDrawList->PolyFlags	 = PolyFlags;

	mov	ecx, DWORD PTR _?PolyFlags@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4KA$S15931

; 1557 : 						TempDrawList->Next       = Frame->Draw[DrawBin];

	mov	esi, DWORD PTR _?DrawBin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15969
	mov	DWORD PTR [edx+56], eax
	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR [edx+4], eax
	mov	DWORD PTR [edx+16], ecx
	mov	ecx, DWORD PTR _Frame$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4+152]
	mov	DWORD PTR [edx+60], ecx

; 1558 : 
; 1559 : 						// Add to linked list.
; 1560 : 						TempDrawList->SurfNext  = AllPolyDrawLists[Node->iSurf];

	mov	ecx, DWORD PTR _?AllPolyDrawLists@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAPAUFBspDrawList@@A$S15911
	mov	esi, DWORD PTR [ecx+eax*4]

; 1561 : 						AllPolyDrawLists[Node->iSurf] = TempDrawList;

	mov	DWORD PTR [ecx+eax*4], edx

; 1562 : 
; 1563 : 						// Save applicable volumetric lights.
; 1564 : 						TempDrawList->Volumetrics = NULL;
; 1565 : 						for( FVolActorLink* Link=FirstVolumetric; Link; Link=Link->Next )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	mov	DWORD PTR [edx+64], esi
	mov	DWORD PTR [edx+68], 0
	mov	edi, DWORD PTR [eax+108]
$L16175:
	test	edi, edi
	je	$L16177

; 1566 : 							if( VolumetricOccludes( Link, VolCross, NumVolCross ) )

	xor	esi, esi
$L20935:
	cmp	esi, DWORD PTR _NumVolCross$16163[ebp]
	jge	SHORT $L20937
	lea	eax, DWORD PTR [esi+esi*2]
	xor	ebx, ebx
	fld	DWORD PTR _?VolCross@?KB@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFVector@@A$S16159[eax*4+4]
	fmul	DWORD PTR [edi+4]
	fld	DWORD PTR _?VolCross@?KB@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFVector@@A$S16159[eax*4+8]
	lea	eax, DWORD PTR _?VolCross@?KB@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFVector@@A$S16159[eax*4]
	fmul	DWORD PTR [edi+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+12]
	fmul	DWORD PTR [edi]
	mov	bl, BYTE PTR [eax+370]
	inc	ebx
	faddp	ST(1), ST(0)
	mov	DWORD PTR -40+[ebp], ebx
	fild	DWORD PTR -40+[ebp]
	fmul	QWORD PTR $T19990
	fxch	ST(1)
	fxch	ST(1)
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L21198
	inc	esi
	jmp	SHORT $L20935
$L20937:

; 1567 : 								TempDrawList->Volumetrics = new(GDynMem)FActorLink( Link->Actor, TempDrawList->Volumetrics );

	mov	eax, DWORD PTR [ecx+4]
	lea	esi, DWORD PTR [ecx+4]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	ebx, DWORD PTR [eax+8]
	cmp	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi], ebx
	jbe	SHORT $L21197
	push	8
	push	8
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
$L21197:
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	test	eax, eax
	je	SHORT $L20035
	mov	esi, DWORD PTR [edi+12]
	mov	edi, DWORD PTR [edi+16]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+68]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [edx+68], eax
	jmp	$L16175
$L20035:

; 1562 : 
; 1563 : 						// Save applicable volumetric lights.
; 1564 : 						TempDrawList->Volumetrics = NULL;
; 1565 : 						for( FVolActorLink* Link=FirstVolumetric; Link; Link=Link->Next )

	mov	edi, DWORD PTR [edi+16]

; 1567 : 								TempDrawList->Volumetrics = new(GDynMem)FActorLink( Link->Actor, TempDrawList->Volumetrics );

	xor	eax, eax
	mov	DWORD PTR [edx+68], eax
	jmp	$L16175
$L21198:
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	mov	edi, DWORD PTR [edi+16]
	jmp	$L16175
$L16177:

; 1568 : 
; 1569 : 						// Save stuff out for hardware rendering.
; 1570 : 						if( !RenDev->SpanBased )

	mov	eax, DWORD PTR _RenDev$15983[ebp]
	mov	esi, DWORD PTR [eax+96]
	test	esi, esi
	jne	SHORT $L16181

; 1571 : 						{
; 1572 : 							FSavedPoly* Saved   = (FSavedPoly*)new(GDynMem)BYTE[sizeof(FSavedPoly)+NumPts*sizeof(FTransform*)];

	mov	eax, DWORD PTR _?NumPts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15963
	lea	esi, DWORD PTR [ecx+4]
	lea	edi, DWORD PTR [eax*4+12]
	mov	eax, DWORD PTR [esi]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	ebx, DWORD PTR [eax+edi]
	cmp	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi], ebx
	jbe	SHORT $L21201
	push	8
	push	edi
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	ecx, DWORD PTR [eax+edi]
	mov	DWORD PTR [esi], ecx
$L21201:
	mov	esi, DWORD PTR _?NumPts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15963

; 1573 : 							Saved->Next         = NULL;

	mov	DWORD PTR [eax], 0

; 1574 : 							TempDrawList->Polys = Saved;

	mov	DWORD PTR [edx+72], eax

; 1575 : 							Saved->NumPts       = NumPts;

	mov	DWORD PTR [eax+8], esi

; 1576 : 							for( INT i=0; i<NumPts; i++ )

	xor	ecx, ecx
$L16188:
	cmp	ecx, esi
	jge	SHORT $L16190

; 1577 : 								Saved->Pts[i] = Pts[i];;

	mov	edi, DWORD PTR _?Pts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAPAUFTransform@@A$S15925
	inc	ecx
	mov	edi, DWORD PTR [edi+ecx*4-4]
	mov	DWORD PTR [eax+ecx*4+8], edi
	jmp	SHORT $L16188
$L16190:

; 1578 : 							TempDrawList->Span.Release();

	lea	ecx, DWORD PTR [edx+20]
	call	?Release@FSpanBuffer@@QAEXXZ		; FSpanBuffer::Release
	mov	edx, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	mov	ecx, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
$L16181:

; 1579 : 						}
; 1580 : 
; 1581 : 						// Sort key.
; 1582 : 						TempDrawList->Key = TempDrawList->Zone->GetIndex() << (32-6);

	mov	eax, DWORD PTR [edx+56]
	mov	esi, DWORD PTR [eax+32]

; 1583 : 						if( Poly->Texture )

	mov	eax, DWORD PTR _?Poly@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspSurf@@A$S15921
	shl	esi, 26					; 0000001aH
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+12], esi
	test	eax, eax
	je	SHORT $L16192

; 1584 : 						{
; 1585 : 							TempDrawList->Key += Poly->Texture->GetIndex();

	mov	edi, DWORD PTR [eax+32]

; 1586 : 							if( Poly->Texture->Palette )	

	mov	eax, DWORD PTR [eax+92]
	add	esi, edi
	test	eax, eax
	mov	DWORD PTR [edx+12], esi
	je	SHORT $L16192

; 1587 : 								TempDrawList->Key += Poly->Texture->Palette->GetIndex() << 12;

	mov	eax, DWORD PTR [eax+32]
	shl	eax, 12					; 0000000cH
	add	eax, esi
	mov	DWORD PTR [edx+12], eax
$L16192:

; 1588 : 						}
; 1589 : 
; 1590 : 						Frame->Draw[DrawBin] = TempDrawList;

	mov	eax, DWORD PTR _Frame$[ebp]
	mov	esi, DWORD PTR _?DrawBin@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15969

; 1591 : 						TempDrawList = new(GDynMem)FBspDrawList;

	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+esi*4+152], edx
	mov	eax, DWORD PTR [ecx+4]
	lea	esi, DWORD PTR [ecx+4]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	edx, DWORD PTR [eax+80]
	cmp	edx, edi
	mov	DWORD PTR [esi], edx
	jbe	SHORT $L20976
	push	8
	push	80					; 00000050H
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR [esi], ecx
$L20976:
	mov	DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909, eax

; 1592 : 						PolysDraw++;

	mov	eax, DWORD PTR _this$[ebp]
	inc	DWORD PTR [eax+148]

; 1593 : 					}
; 1594 : 					else

	jmp	$L16210
$L16173:

; 1595 : 					{
; 1596 : 						// Add to existing draw-list entry.
; 1597 : 						if( !RenDev->SpanBased )

	mov	edx, DWORD PTR _RenDev$15983[ebp]
	mov	eax, DWORD PTR [edx+96]
	test	eax, eax
	jne	SHORT $L16196

; 1598 : 						{
; 1599 : 							// Save stuff out for hardware rendering.
; 1600 : 							FSavedPoly* Saved   = (FSavedPoly*)new(GDynMem)BYTE[sizeof(FSavedPoly)+NumPts*sizeof(FTransform*)];

	mov	esi, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	mov	edx, DWORD PTR _?NumPts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15963
	mov	eax, DWORD PTR [esi+4]
	lea	ebx, DWORD PTR [edx*4+12]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	ecx, DWORD PTR [eax+ebx]
	cmp	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+4], ecx
	jbe	SHORT $L20992
	push	8
	push	ebx
	mov	ecx, esi
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _?NumPts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15963
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	ecx, DWORD PTR [eax+ebx]
	mov	DWORD PTR [esi+4], ecx
$L20992:

; 1601 : 							Saved->Next         = Merge->Polys;

	mov	ecx, DWORD PTR _?Merge@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15913

; 1602 : 							Merge->Polys        = Saved;
; 1603 : 							Saved->NumPts       = NumPts;

	mov	DWORD PTR [eax+8], edx
	mov	esi, DWORD PTR [ecx+72]
	mov	DWORD PTR [ecx+72], eax
	mov	DWORD PTR [eax], esi

; 1604 : 							for( INT i=0; i<NumPts; i++ )

	xor	ecx, ecx
$L16203:
	cmp	ecx, edx
	jge	SHORT $L16206

; 1605 : 								Saved->Pts[i] = Pts[i];

	mov	esi, DWORD PTR _?Pts@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAPAUFTransform@@A$S15925
	inc	ecx
	mov	esi, DWORD PTR [esi+ecx*4-4]
	mov	DWORD PTR [eax+ecx*4+8], esi
	jmp	SHORT $L16203
$L16196:

; 1102 : 	static FSpanBuffer*			SpanBuffer;

	xor	eax, eax

; 1103 : 	static FBspDrawList*		TempDrawList;

	DB	15					; 0000000fH

; 1104 : 	static FBspDrawList**		AllPolyDrawLists;

	DB	49					; 00000031H

; 1105 : 	static FBspDrawList*		Merge;

	xor	edx, edx

; 1606 : 						}
; 1607 : 						else
; 1608 : 						{
; 1609 : 							clock(GStat.SpanTime);

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+76

; 1610 : 							Merge->Span.MergeWith( TempDrawList->Span );

	mov	edx, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	sub	ecx, eax
	mov	eax, DWORD PTR _?Merge@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15913
	add	edx, 20					; 00000014H
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+76, ecx
	push	edx
	lea	ecx, DWORD PTR [eax+20]
	call	?MergeWith@FSpanBuffer@@QAEXABV1@@Z	; FSpanBuffer::MergeWith

; 1102 : 	static FSpanBuffer*			SpanBuffer;

	xor	eax, eax

; 1103 : 	static FBspDrawList*		TempDrawList;

	DB	15					; 0000000fH

; 1104 : 	static FBspDrawList**		AllPolyDrawLists;

	DB	49					; 00000031H

; 1105 : 	static FBspDrawList*		Merge;

	xor	edx, edx

; 1611 : 							unclock(GStat.SpanTime);

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+76
	lea	edx, DWORD PTR [ecx+eax-34]
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+76, edx
$L16206:

; 1612 : 						}
; 1613 : 						TempDrawList->Span.Release();

	mov	eax, DWORD PTR _?TempDrawList@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15909
	lea	ecx, DWORD PTR [eax+20]
	call	?Release@FSpanBuffer@@QAEXXZ		; FSpanBuffer::Release

; 1614 : 
; 1615 : 						// Merge in the new volumetrics.
; 1616 : 						for( FVolActorLink* Link=FirstVolumetric; Link; Link=Link->Next )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ebx, DWORD PTR [ecx+108]
	mov	ecx, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
$L16208:
	test	ebx, ebx
	je	$L21178

; 1617 : 						{
; 1618 : 							for( FActorLink* Other=Merge->Volumetrics; Other; Other=Other->Next )

	mov	edx, DWORD PTR _?Merge@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15913
	mov	eax, DWORD PTR [edx+68]
$L16212:
	test	eax, eax
	je	SHORT $L21240

; 1619 : 								if( Other->Actor == Link->Actor )

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [ebx+12]
	cmp	edx, esi
	je	SHORT $L16214

; 1617 : 						{
; 1618 : 							for( FActorLink* Other=Merge->Volumetrics; Other; Other=Other->Next )

	mov	eax, DWORD PTR [eax+4]
	jmp	SHORT $L16212
$L16214:

; 1620 : 									break;
; 1621 : 							if( Other==NULL && VolumetricOccludes( Link, VolCross, NumVolCross ) )

	test	eax, eax
	jne	$L16209
$L21240:
	xor	edx, edx
$L21006:
	cmp	edx, edi
	jge	SHORT $L21008
	lea	eax, DWORD PTR [edx+edx*2]
	mov	esi, DWORD PTR [ebx+12]
	fld	DWORD PTR _?VolCross@?KB@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFVector@@A$S16159[eax*4+4]
	fmul	DWORD PTR [ebx+4]
	fld	DWORD PTR _?VolCross@?KB@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFVector@@A$S16159[eax*4+8]
	lea	eax, DWORD PTR _?VolCross@?KB@??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFVector@@A$S16159[eax*4]
	fmul	DWORD PTR [ebx+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ebx]
	xor	eax, eax
	mov	al, BYTE PTR [esi+370]
	inc	eax
	faddp	ST(1), ST(0)
	mov	DWORD PTR -40+[ebp], eax
	fild	DWORD PTR -40+[ebp]
	fmul	QWORD PTR $T19990
	fxch	ST(1)
	fxch	ST(1)
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L16209
	inc	edx
	jmp	SHORT $L21006
$L21008:

; 1622 : 								Merge->Volumetrics = new(GDynMem)FActorLink( Link->Actor, Merge->Volumetrics );

	mov	eax, DWORD PTR [ecx+4]
	lea	esi, DWORD PTR [ecx+4]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi], edx
	jbe	SHORT $L21019
	push	8
	push	8
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	eax, DWORD PTR [esi]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
$L21019:
	test	eax, eax
	je	SHORT $L20041
	mov	edx, DWORD PTR [ebx+12]
	mov	ebx, DWORD PTR [ebx+16]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR _?Merge@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15913
	mov	edx, DWORD PTR [edx+68]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _?Merge@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15913
	mov	DWORD PTR [edx+68], eax
	jmp	$L16208
$L20041:
	mov	edx, DWORD PTR _?Merge@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAUFBspDrawList@@A$S15913
	xor	eax, eax
	mov	DWORD PTR [edx+68], eax
$L16209:

; 1614 : 
; 1615 : 						// Merge in the new volumetrics.
; 1616 : 						for( FVolActorLink* Link=FirstVolumetric; Link; Link=Link->Next )

	mov	ebx, DWORD PTR [ebx+16]
	jmp	$L16208
$L21178:
	mov	ebx, DWORD PTR _?Node@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFBspNode@@A$S15915
$L16210:

; 1623 : 						}
; 1624 : 					}
; 1625 : 					Node->NodeFlags &= ~NF_PolyOccluded;

	mov	al, BYTE PTR [ebx+55]
	and	al, 247					; 000000f7H
	mov	BYTE PTR [ebx+55], al

; 1626 : 					NodesDraw++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+144]
	inc	edx
	mov	DWORD PTR [eax+144], edx

; 1627 : 
; 1628 : 					// See if filled up.
; 1629 : 					if( SpanBuffer->ValidLines <= 0 )

	mov	eax, DWORD PTR _?SpanBuffer@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAVFSpanBuffer@@A$S15907
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	jg	$NextCoplanar$16054

; 1630 : 					{
; 1631 : 						for( INT i=0,j=0; i<NumActiveZones; j+=ActiveZones[i++]!=iZone )

	mov	cl, BYTE PTR _?iZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15951
	xor	edi, edi
	xor	esi, esi
$L16222:
	cmp	edi, DWORD PTR _?NumActiveZones@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15971
	jge	SHORT $L16224

; 1632 : 							ActiveZones[j] = ActiveZones[i];

	mov	dl, BYTE PTR _?ActiveZones@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAEA$S15973[edi]
	lea	eax, DWORD PTR _?ActiveZones@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAEA$S15973[edi]
	mov	BYTE PTR _?ActiveZones@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4PAEA$S15973[esi], dl
	inc	edi
	cmp	BYTE PTR [eax], cl
	je	SHORT $L20043
	mov	eax, 1
	add	esi, eax
	jmp	SHORT $L16222
$L20043:

; 1630 : 					{
; 1631 : 						for( INT i=0,j=0; i<NumActiveZones; j+=ActiveZones[i++]!=iZone )

	xor	eax, eax
	add	esi, eax
	jmp	SHORT $L16222
$L16224:

; 1633 : 						NumActiveZones=j;
; 1634 : 						ActiveZoneMask &= ~(((QWORD)1)<<iZone);

	mov	ecx, DWORD PTR _?iZone@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4EA$S15951
	mov	eax, 1
	and	ecx, 255				; 000000ffH
	xor	edx, edx
	mov	DWORD PTR _?NumActiveZones@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4HA$S15971, esi
	call	__allshl
	mov	edi, DWORD PTR _?ActiveZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4_KA$S15941
	mov	ecx, DWORD PTR _?ActiveZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4_KA$S15941+4
	not	eax
	not	edx
	and	edi, eax
	and	ecx, edx

; 1635 : 						if( NumActiveZones==0 )

	test	esi, esi
	mov	DWORD PTR _?ActiveZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4_KA$S15941, edi
	mov	DWORD PTR _?ActiveZoneMask@?1??OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z@4_KA$S15941+4, ecx
	je	$DoneRendering$16227

; 1514 : 								goto NextCoplanar;

	jmp	$NextCoplanar$16054
_TEXT	ENDS
text$x	SEGMENT
$L21228:
	mov	eax, OFFSET FLAT:$T21069
	jmp	___CxxFrameHandler
text$x	ENDS
?OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z ENDP		; URender::OccludeBsp
CONST	SEGMENT
$T21317	DQ	040f0000000000000r		; 65536
$T21318	DQ	0c0f0000000000000r		; -65536
CONST	ENDS
xdata$x	SEGMENT
$T21311	DD	019930520H
	DD	02H
	DD	FLAT:$T21329
	DD	01H
	DD	FLAT:$T21330
	DD	2 DUP(00H)
	ORG $+4
$T21329	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T21330	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T21331
	ORG $+4
$T21331	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffe0H
	DD	FLAT:$L21251
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L21252
xdata$x	ENDS
_TEXT	SEGMENT
_Pts$ = 8
_NumPts$ = 12
_Span$ = 16
_EndY$ = 20
_P$15627 = -36
_FDX$15637 = -28
_Err$15647 = -32
$T21249 = 8
_I$21254 = -24
$T21255 = -20
_I$21257 = -20
$T21258 = -24
_I$21298 = 12
$T21299 = 8
_I$21302 = 20
$T21303 = 8
__$EHRec$ = -16
?SetupRaster@@YAHPAPAUFTransform@@HPAVFSpanBuffer@@H@Z PROC NEAR ; SetupRaster

; 761  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L21326
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 765  : 	RasterStartY = RasterEndY = Pts[0]->IntY;

	mov	esi, DWORD PTR _Pts$[ebp]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+24]

; 766  : 	RasterStartX = RasterEndX = appFloor( Pts[0]->ScreenX );

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR ?RasterEndY@@3HA, ecx		; RasterEndY
	mov	DWORD PTR ?RasterStartY@@3HA, ecx	; RasterStartY
	mov	DWORD PTR $T21255[ebp], eax

; 762  : 	guard(SetupRaster);
; 763  : 
; 764  : 	// Compute integer coords.

	fld	DWORD PTR $T21255[ebp]

; 765  : 	RasterStartY = RasterEndY = Pts[0]->IntY;

	fsub	DWORD PTR ?Half@?1??appFloor@@YAHM@Z@4MA ; Half

; 766  : 	RasterStartX = RasterEndX = appFloor( Pts[0]->ScreenX );

	fistp	DWORD PTR _I$21254[ebp]
	mov	eax, DWORD PTR _I$21254[ebp]

; 767  : 	for( INT i=1; i<NumPts; i++ )

	mov	edx, 1
	mov	edi, eax
	mov	DWORD PTR ?RasterEndX@@3HA, eax		; RasterEndX
	mov	DWORD PTR ?RasterStartX@@3HA, edi	; RasterStartX
$L15592:
	cmp	edx, DWORD PTR _NumPts$[ebp]
	jge	SHORT $L15594

; 768  : 	{
; 769  : 		INT Y = Pts[i]->IntY;

	mov	ecx, DWORD PTR [esi+edx*4]

; 770  : 		if( Y < RasterStartY )

	mov	edi, DWORD PTR ?RasterStartY@@3HA	; RasterStartY
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, edi
	jge	SHORT $L15596

; 771  : 			RasterStartY = Y;

	mov	DWORD PTR ?RasterStartY@@3HA, eax	; RasterStartY

; 772  : 		else if( Y > RasterEndY )

	jmp	SHORT $L15598
$L15596:
	cmp	eax, DWORD PTR ?RasterEndY@@3HA		; RasterEndY
	jle	SHORT $L15598

; 773  : 			RasterEndY = Y;

	mov	DWORD PTR ?RasterEndY@@3HA, eax		; RasterEndY
$L15598:

; 774  : 
; 775  : 		INT X = appFloor( Pts[i]->ScreenX );

	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T21258[ebp], ecx

; 762  : 	guard(SetupRaster);
; 763  : 
; 764  : 	// Compute integer coords.

	fld	DWORD PTR $T21258[ebp]

; 765  : 	RasterStartY = RasterEndY = Pts[0]->IntY;

	fsub	DWORD PTR ?Half@?1??appFloor@@YAHM@Z@4MA ; Half

; 766  : 	RasterStartX = RasterEndX = appFloor( Pts[0]->ScreenX );

	fistp	DWORD PTR _I$21257[ebp]

; 776  : 		if( X < RasterStartX )

	mov	eax, DWORD PTR _I$21257[ebp]
	mov	edi, DWORD PTR ?RasterStartX@@3HA	; RasterStartX
	cmp	eax, edi
	jge	SHORT $L15600

; 777  : 			RasterStartX = X;

	mov	edi, eax
	inc	edx
	mov	DWORD PTR ?RasterStartX@@3HA, edi	; RasterStartX
	jmp	SHORT $L15592
$L15600:

; 778  : 		else if( X > RasterEndX )

	cmp	eax, DWORD PTR ?RasterEndX@@3HA		; RasterEndX
	jle	SHORT $L15593

; 779  : 			RasterEndX = X;

	mov	DWORD PTR ?RasterEndX@@3HA, eax		; RasterEndX
$L15593:

; 767  : 	for( INT i=1; i<NumPts; i++ )

	inc	edx
	jmp	SHORT $L15592
$L15594:

; 780  : 	}
; 781  : 	if( RasterStartY<0 || RasterEndY>EndY )

	mov	eax, DWORD PTR ?RasterStartY@@3HA	; RasterStartY
	test	eax, eax
	jl	SHORT $L21320
	mov	ebx, DWORD PTR ?RasterEndY@@3HA		; RasterEndY
	mov	esi, DWORD PTR _EndY$[ebp]
	cmp	ebx, esi
	jle	$L15616
	jmp	SHORT $L15604
$L21320:
	mov	esi, DWORD PTR _EndY$[ebp]
	mov	ebx, DWORD PTR ?RasterEndY@@3HA		; RasterEndY
$L15604:

; 782  : 	{
; 783  : 		RasterStartY = Clamp( RasterStartY, 0, EndY );

	xor	edx, edx
	cmp	eax, edx
	jge	SHORT $L21266
	mov	DWORD PTR ?RasterStartY@@3HA, edx	; RasterStartY
	jmp	SHORT $L21265
$L21266:
	cmp	eax, esi
	jl	SHORT $L21265
	mov	DWORD PTR ?RasterStartY@@3HA, esi	; RasterStartY
$L21265:

; 784  : 		RasterEndY   = Clamp( RasterEndY,   0, EndY );

	cmp	ebx, edx
	jge	SHORT $L21275
	xor	ebx, ebx
	jmp	SHORT $L21327
$L21275:
	cmp	ebx, esi
	jl	SHORT $L21274
	mov	ebx, esi
$L21327:
	mov	DWORD PTR ?RasterEndY@@3HA, ebx		; RasterEndY
$L21274:

; 785  : 		for( INT i=0; i<NumPts; i++ )

	cmp	edx, DWORD PTR _NumPts$[ebp]
	jge	SHORT $L21325

; 786  : 		{
; 787  : 			Pts[i]->IntY    = Clamp( Pts[i]->IntY, 0, EndY );

	mov	eax, DWORD PTR _Pts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx+24]
	test	eax, eax
	jge	SHORT $L21284
	xor	eax, eax
	jmp	SHORT $L21283
$L21284:
	cmp	eax, esi
	jl	SHORT $L21283
	mov	eax, esi
$L21283:

; 788  : 			Pts[i]->ScreenY = Clamp( Pts[i]->IntY, 0, EndY );

	test	eax, eax
	mov	DWORD PTR [ecx+24], eax
	jge	SHORT $L21294
	mov	DWORD PTR 20+[ebp], 0
	inc	edx
	fild	DWORD PTR 20+[ebp]
	fstp	DWORD PTR [ecx+20]
	jmp	SHORT $L21274
$L21294:
	cmp	eax, esi
	mov	DWORD PTR 20+[ebp], eax
	jl	SHORT $L21293
	mov	DWORD PTR 20+[ebp], esi
$L21293:
	fild	DWORD PTR 20+[ebp]
	inc	edx
	fstp	DWORD PTR [ecx+20]
	jmp	SHORT $L21274
$L21325:

; 785  : 		for( INT i=0; i<NumPts; i++ )

	mov	eax, DWORD PTR ?RasterStartY@@3HA	; RasterStartY
$L15616:

; 789  : 		}
; 790  : 	}
; 791  : 
; 792  : 	// Check bounds for visibility.
; 793  : 	if( Span && !Span->BoxIsVisible( RasterStartX, RasterStartY, RasterEndX, RasterEndY ) )

	mov	ecx, DWORD PTR _Span$[ebp]
	test	ecx, ecx
	je	SHORT $L15625
	mov	edx, DWORD PTR ?RasterEndX@@3HA		; RasterEndX
	push	ebx
	push	edx
	push	eax
	push	edi
	call	?BoxIsVisible@FSpanBuffer@@QAEHHHHH@Z	; FSpanBuffer::BoxIsVisible
	test	eax, eax
	jne	SHORT $L15625

; 794  : 	{
; 795  : 		STAT(GStat.NumRasterBoxReject++);

	mov	eax, DWORD PTR ?GStat@@3UFRenderStats@@A+92
	inc	eax
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+92, eax

; 796  : 		return 0;

	xor	eax, eax

; 834  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L21251:

; 833  : 	unguard;

	mov	eax, DWORD PTR _Err$15647[ebp]
	lea	ecx, DWORD PTR $T21249[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	ecx
	mov	DWORD PTR $T21249[ebp], eax
	call	__CxxThrowException@8
	mov	eax, $L15587
	ret	0
$L21252:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??SetupRaster@@YAHPAPAUFTransform@@HPAVFSpanBuffer@@H@Z@4PBDB$S15589
	push	OFFSET FLAT:$SG15649
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L15587
	ret	0
$L15625:
	mov	ebx, DWORD PTR _Pts$[ebp]
	mov	edx, DWORD PTR _NumPts$[ebp]
	mov	eax, DWORD PTR ?GStat@@3UFRenderStats@@A+88
	mov	ecx, DWORD PTR [ebx+edx*4-4]
	lea	edx, DWORD PTR [ebx+edx*4]
	inc	eax
	mov	DWORD PTR 16+[ebp], edx
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+88, eax
	mov	DWORD PTR _P$15627[ebp], ecx
$L21328:
	mov	eax, DWORD PTR [ebx]
	cmp	ebx, edx
	mov	DWORD PTR _P$15627[ebp+4], eax
	jae	$L15632
	mov	eax, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR [ecx+24]
	cmp	eax, ecx
	je	$L15631
	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	mov	eax, edx
	lea	edx, DWORD PTR _P$15627[ebp+4]
	lea	ecx, DWORD PTR [eax*4]
	sub	edx, ecx
	mov	edi, DWORD PTR _P$15627[ebp+ecx]
	mov	edx, DWORD PTR [edx]
	fld	DWORD PTR [edi+16]
	fsub	DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR 8+[ebp], ecx
	fmul	QWORD PTR $T21317
	fld	DWORD PTR [edi+20]
	fsub	DWORD PTR [edx+20]
	lea	eax, DWORD PTR [eax+ecx*2]
	fdivp	ST(1), ST(0)
	lea	ecx, DWORD PTR ?HackRaster@@3PAUFRasterSpan@@A[eax*4]
	fstp	QWORD PTR _FDX$15637[ebp]
	fild	DWORD PTR 8+[ebp]
	fsub	DWORD PTR [edx+20]
	fmul	QWORD PTR _FDX$15637[ebp]
	fld	DWORD PTR [edx+16]
	fmul	QWORD PTR $T21318
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR $T21299[ebp]

; 762  : 	guard(SetupRaster);
; 763  : 
; 764  : 	// Compute integer coords.

	fld	DWORD PTR $T21299[ebp]

; 765  : 	RasterStartY = RasterEndY = Pts[0]->IntY;

	fsub	DWORD PTR ?Half@?1??appFloor@@YAHM@Z@4MA ; Half

; 766  : 	RasterStartX = RasterEndX = appFloor( Pts[0]->ScreenX );

	fistp	DWORD PTR _I$21298[ebp]

; 833  : 	unguard;

	fld	QWORD PTR _FDX$15637[ebp]
	mov	eax, DWORD PTR _I$21298[ebp]
	fstp	DWORD PTR $T21303[ebp]

; 762  : 	guard(SetupRaster);
; 763  : 
; 764  : 	// Compute integer coords.

	fld	DWORD PTR $T21303[ebp]

; 765  : 	RasterStartY = RasterEndY = Pts[0]->IntY;

	fsub	DWORD PTR ?Half@?1??appFloor@@YAHM@Z@4MA ; Half

; 766  : 	RasterStartX = RasterEndX = appFloor( Pts[0]->ScreenX );

	fistp	DWORD PTR _I$21302[ebp]

; 833  : 	unguard;

	mov	edi, DWORD PTR [edi+24]
	mov	esi, DWORD PTR _I$21302[ebp]
	sub	edi, DWORD PTR [edx+24]
$L15642:

; 803  : 	{
; 804  : 		if( P[1]->IntY != P[0]->IntY )
; 805  : 		{
; 806  : 			INT Index    = P[1]->IntY > P[0]->IntY;
; 807  : 			Bot          = P[Index];
; 808  : 			Top          = P[1-Index];
; 809  : 			INT*   Set   = HackRaster->X + Top->IntY*2 + Index;
; 810  : 			DOUBLE YAdj  = Top->IntY - Top->ScreenY;
; 811  : 			DOUBLE FDX   = 65536.0 * (Bot->ScreenX - Top->ScreenX) / (Bot->ScreenY - Top->ScreenY);
; 812  : 			DWORD  X     = appFloor( 65536.0 * Top->ScreenX + YAdj * FDX );
; 813  : 			DWORD  DX    = appFloor( FDX );
; 814  : 			INT    Count = Bot->IntY - Top->IntY;
; 815  : 			while( Count >= 4 )

	cmp	edi, 4
	jl	SHORT $L21319

; 816  : 			{
; 817  : 				Set[0]  = Unfix(X+=DX);

	add	eax, esi

; 818  : 				Set[2]  = Unfix(X+=DX);
; 819  : 				Set[4]  = Unfix(X+=DX);
; 820  : 				Set[6]  = Unfix(X+=DX);
; 821  : 				Set    += 2*4;

	add	ecx, 32					; 00000020H
	mov	edx, eax
	add	eax, esi
	sar	edx, 16					; 00000010H
	mov	DWORD PTR [ecx-32], edx
	mov	edx, eax
	sar	edx, 16					; 00000010H
	add	eax, esi
	mov	DWORD PTR [ecx-24], edx
	mov	edx, eax
	add	eax, esi
	sar	edx, 16					; 00000010H
	mov	DWORD PTR [ecx-16], edx
	mov	edx, eax
	sar	edx, 16					; 00000010H
	mov	DWORD PTR [ecx-8], edx

; 822  : 				Count  -= 4;

	sub	edi, 4

; 823  : 			}

	jmp	SHORT $L15642
$L21319:

; 824  : 			while( Count > 0 )

	test	edi, edi
	jle	SHORT $L21321

; 825  : 			{
; 826  : 				*Set   = Unfix(X+=DX);

	add	eax, esi

; 827  : 				Set   += 2;

	add	ecx, 8
	mov	edx, eax
	sar	edx, 16					; 00000010H
	mov	DWORD PTR [ecx-8], edx

; 828  : 				Count -= 1;

	dec	edi

; 829  : 			}

	jmp	SHORT $L21319
$L21321:
	mov	edx, DWORD PTR 16+[ebp]
$L15631:

; 797  : 	}
; 798  : 	STAT(GStat.NumRasterPolys++);
; 799  : 
; 800  : 	// Rasterize the edges.
; 801  : 	FTransform **Last=Pts+NumPts, *P[2], *Top, *Bot;
; 802  : 	for( P[0]=Pts[NumPts-1],P[1]=Pts[0]; Pts<Last; P[0]=*Pts,Pts++,P[1]=*Pts )

	mov	ecx, DWORD PTR [ebx]
	add	ebx, 4
	mov	DWORD PTR _P$15627[ebp], ecx
	jmp	$L21328
$L15632:

; 830  : 		}
; 831  : 	}
; 832  : 	return 1;

	mov	eax, 1
$L15587:

; 834  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
$L21326:
	mov	eax, OFFSET FLAT:$T21311
	jmp	___CxxFrameHandler
text$x	ENDS
?SetupRaster@@YAHPAPAUFTransform@@HPAVFSpanBuffer@@H@Z ENDP ; SetupRaster
_TEXT	SEGMENT
_$E116	PROC NEAR
	ret	0
_$E116	ENDP
_$E115	PROC NEAR
	ret	0
_$E115	ENDP
_$E114	PROC NEAR
	ret	0
_$E114	ENDP
_TEXT	ENDS
PUBLIC	?OccludeFrame@URender@@QAEXPAUFSceneNode@@@Z	; URender::OccludeFrame
EXTRN	__imp_?appRealloc@@YAPAXPAXHPBD@Z:NEAR
EXTRN	?SetupDynamics@URender@@QAEXPAUFSceneNode@@PAVAActor@@@Z:NEAR ; URender::SetupDynamics
xdata$x	SEGMENT
$T21374	DD	019930520H
	DD	02H
	DD	FLAT:$T21387
	DD	01H
	DD	FLAT:$T21388
	DD	2 DUP(00H)
	ORG $+4
$T21387	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T21388	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T21389
	ORG $+4
$T21389	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffe4H
	DD	FLAT:$L21338
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L21339
xdata$x	ENDS
_TEXT	SEGMENT
$T21336 = 8
__$EHRec$ = -16
_Frame$ = 8
_this$ = -20
_Level$16304 = -24
_Err$16348 = -28
?OccludeFrame@URender@@QAEXPAUFSceneNode@@@Z PROC NEAR	; URender::OccludeFrame

; 1753 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L21386
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 12					; 0000000cH

; 1754 : 	guard(URender::DrawLevel);
; 1755 : 	UViewport* Viewport = Frame->Viewport;

	mov	eax, DWORD PTR _Frame$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	ebx, DWORD PTR [eax]

; 1756 : 	ULevel*    Level    = Frame->Level;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _Level$16304[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1757 : 	UModel*	   Model    = Level->Model;
; 1758 : 	check(Model->Nodes->Num()>0);

	mov	edi, DWORD PTR [eax+192]
	xor	esi, esi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __$EHRec$[ebp+12], esi
	mov	eax, DWORD PTR [edi+140]
	cmp	DWORD PTR [eax+92], esi
	jg	SHORT $L16306
	push	1758					; 000006deH
	push	OFFSET FLAT:$SG16307
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L16306:

; 1759 : 
; 1760 : 	// Init rendering info.
; 1761 : 	if( SurfLights==NULL || Level->Model->Surfs->Max()>MaxSurfLights )

	mov	ecx, DWORD PTR ?SurfLights@URender@@2PAPAUFActorLink@@A ; URender::SurfLights
	cmp	ecx, esi
	je	SHORT $L16309
	mov	edx, DWORD PTR [edi+144]
	mov	eax, DWORD PTR [edx+96]
	mov	edx, DWORD PTR ?MaxSurfLights@URender@@2HA ; URender::MaxSurfLights
	cmp	eax, edx
	jle	SHORT $L16308
$L16309:

; 1762 : 	{
; 1763 : 		MaxSurfLights = Level->Model->Surfs->Max();

	mov	edx, DWORD PTR [edi+144]

; 1764 : 		SurfLights    = (FActorLink**)appRealloc( SurfLights, MaxSurfLights * sizeof(FActorLink*), "SurfLights" );

	push	OFFSET FLAT:$SG16312
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR ?MaxSurfLights@URender@@2HA, eax ; URender::MaxSurfLights
	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR __imp_?appRealloc@@YAPAXPAXHPBD@Z

; 1765 : 		appMemset( SurfLights, 0, MaxSurfLights * sizeof(FActorLink*) );

	mov	ecx, DWORD PTR ?MaxSurfLights@URender@@2HA ; URender::MaxSurfLights
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?SurfLights@URender@@2PAPAUFActorLink@@A, eax ; URender::SurfLights
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	push	esi
	push	eax
	call	DWORD PTR __imp_?appMemset@@YAPAXPAXHH@Z
	add	esp, 12					; 0000000cH
$L16308:

; 1766 : 	}
; 1767 : 	if( Level->Model->Leaves.Num() && (LeafLights==NULL || Level->Model->Leaves.Num()>MaxLeafLights) )

	mov	eax, DWORD PTR [edi+208]
	cmp	eax, esi
	je	SHORT $L16314
	mov	ecx, DWORD PTR ?LeafLights@URender@@2PAPAUFVolActorLink@@A ; URender::LeafLights
	cmp	ecx, esi
	je	SHORT $L16315
	cmp	eax, DWORD PTR ?MaxLeafLights@URender@@2HA ; URender::MaxLeafLights
	jle	SHORT $L16314
$L16315:

; 1768 : 	{
; 1769 : 		MaxLeafLights = Level->Model->Leaves.Num();

	mov	DWORD PTR ?MaxLeafLights@URender@@2HA, eax ; URender::MaxLeafLights

; 1770 : 		LeafLights    = (FVolActorLink**)appRealloc( LeafLights, MaxLeafLights * sizeof(FActorLink*), "LeafLights" );

	push	OFFSET FLAT:$SG16318
	shl	eax, 2
	push	eax
	push	ecx
	call	DWORD PTR __imp_?appRealloc@@YAPAXPAXHPBD@Z

; 1771 : 		appMemset( LeafLights, 0, MaxLeafLights * sizeof(FVolActorLink*) );

	mov	ecx, DWORD PTR ?MaxLeafLights@URender@@2HA ; URender::MaxLeafLights
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?LeafLights@URender@@2PAPAUFVolActorLink@@A, eax ; URender::LeafLights
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	push	esi
	push	eax
	call	DWORD PTR __imp_?appMemset@@YAPAXPAXHH@Z
	add	esp, 12					; 0000000cH
$L16314:

; 1772 : 	}
; 1773 : 	NumDynLightSurfs  = 0;
; 1774 : 	NumDynLightLeaves = 0;
; 1775 : 	NumPostDynamics   = 0;

	mov	eax, DWORD PTR _this$[ebp]

; 1776 : 	PostDynamics      = new(GDynMem,Level->Model->Nodes->Max())URender::FDynamicsCache*;

	mov	ecx, DWORD PTR [edi+140]
	mov	DWORD PTR ?NumDynLightSurfs@URender@@2HA, esi ; URender::NumDynLightSurfs
	mov	DWORD PTR ?NumDynLightLeaves@URender@@2HA, esi ; URender::NumDynLightLeaves
	mov	edi, DWORD PTR [ecx+96]
	mov	DWORD PTR [eax+232], esi
	mov	esi, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	shl	edi, 2
	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+8]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	ecx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	mov	DWORD PTR [esi+4], ecx
	jbe	SHORT $L21369
	push	8
	push	edi
	mov	ecx, esi
	call	DWORD PTR __imp_?AllocateNewChunk@FMemStack@@AAEPAEHH@Z
	mov	eax, DWORD PTR [esi+4]
	add	eax, 7
	and	al, -8					; fffffff8H
	lea	edx, DWORD PTR [eax+edi]
	mov	DWORD PTR [esi+4], edx
$L21369:
	mov	edi, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edi+236], eax

; 1777 : 	FirstVolumetric   = NULL;
; 1778 : 
; 1779 : 	// Perform occlusion checking.
; 1780 : 	SetupDynamics( Frame, (Viewport->Actor->bBehindView || Frame->Parent!=NULL) ? NULL : Viewport->Actor->ViewTarget ?  Viewport->Actor->ViewTarget : Viewport->Actor );

	mov	eax, DWORD PTR [ebx+92]
	mov	ebx, DWORD PTR _Frame$[ebp]
	mov	DWORD PTR [edi+108], 0
	test	BYTE PTR [eax+668], 1
	jne	SHORT $L21384
	mov	ecx, DWORD PTR [ebx+8]
	test	ecx, ecx
	jne	SHORT $L21384
	mov	ecx, DWORD PTR [eax+1052]
	test	ecx, ecx
	je	SHORT $L21335
	mov	eax, ecx
	jmp	SHORT $L21335
$L21384:
	xor	eax, eax
$L21335:
	push	eax
	push	ebx
	mov	ecx, edi
	call	?SetupDynamics@URender@@QAEXPAUFSceneNode@@PAVAActor@@@Z ; URender::SetupDynamics

; 1781 : 	OccludeBsp( Frame );

	push	ebx
	mov	ecx, edi
	call	?OccludeBsp@URender@@QAEXPAUFSceneNode@@@Z ; URender::OccludeBsp

; 1782 : 
; 1783 : 	// Remember surface lights.
; 1784 : 	for( INT i=0; i<3; i++ )

	mov	esi, DWORD PTR ?SurfLights@URender@@2PAPAUFActorLink@@A ; URender::SurfLights
	xor	ecx, ecx
$L16322:
	cmp	ecx, 3
	jge	SHORT $L16324

; 1785 : 		for( FBspDrawList* Draw=Frame->Draw[i]; Draw; Draw=Draw->Next )

	mov	eax, DWORD PTR [ebx+ecx*4+152]
$L16326:
	test	eax, eax
	je	SHORT $L16323

; 1786 : 			Draw->SurfLights = SurfLights[Draw->iSurf];

	mov	edx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [eax+76], edx
	mov	eax, DWORD PTR [eax+60]
	jmp	SHORT $L16326
$L16323:

; 1782 : 
; 1783 : 	// Remember surface lights.
; 1784 : 	for( INT i=0; i<3; i++ )

	inc	ecx
	jmp	SHORT $L16322
$L16324:

; 1787 : 
; 1788 : 	// Remember visible actor leaf lights.
; 1789 : 	if( Level->Model->Leaves.Num() )

	mov	eax, DWORD PTR _Level$16304[ebp]
	mov	ecx, DWORD PTR [eax+192]
	mov	eax, DWORD PTR [ecx+208]
	test	eax, eax
	je	SHORT $L21383

; 1790 : 		for( FDynamicSprite* Sprite = Frame->Sprite; Sprite; Sprite=Sprite->RenderNext )

	mov	eax, DWORD PTR [ebx+164]
	mov	edx, DWORD PTR ?LeafLights@URender@@2PAPAUFVolActorLink@@A ; URender::LeafLights
$L16331:
	test	eax, eax
	je	SHORT $L16333

; 1791 : 			if( Sprite->Actor->Region.iLeaf!=INDEX_NONE )

	mov	ecx, DWORD PTR [eax+148]
	mov	ecx, DWORD PTR [ecx+128]
	cmp	ecx, -1
	je	SHORT $L16332

; 1792 : 				Sprite->LeafLights = LeafLights[ Sprite->Actor->Region.iLeaf ];

	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+184], ecx
$L16332:

; 1790 : 		for( FDynamicSprite* Sprite = Frame->Sprite; Sprite; Sprite=Sprite->RenderNext )

	mov	eax, DWORD PTR [eax+16]
	jmp	SHORT $L16331
$L21383:
	mov	edx, DWORD PTR ?LeafLights@URender@@2PAPAUFVolActorLink@@A ; URender::LeafLights
$L16333:

; 1793 : 
; 1794 : 	// Cleanup rendering info.
; 1795 : 	for( i=0; i<NumPostDynamics; i++ )

	xor	ecx, ecx
$L16335:
	cmp	ecx, DWORD PTR [edi+232]
	jge	SHORT $L16337

; 1796 : 	{
; 1797 : 		PostDynamics[i]->Dynamics[0] = NULL;

	mov	eax, DWORD PTR [edi+236]
	inc	ecx
	mov	eax, DWORD PTR [eax+ecx*4-4]
	mov	DWORD PTR [eax], 0

; 1798 : 		PostDynamics[i]->Dynamics[1] = NULL;

	mov	DWORD PTR [eax+4], 0
	jmp	SHORT $L16335
$L16337:

; 1799 : 	}
; 1800 : 	for( i=0; i<NumDynLightSurfs; i++ )

	mov	ecx, DWORD PTR ?NumDynLightSurfs@URender@@2HA ; URender::NumDynLightSurfs
	xor	eax, eax
$L16338:
	cmp	eax, ecx
	jge	SHORT $L16340

; 1801 : 	{
; 1802 : 		SurfLights[ DynLightSurfs[i] ] = NULL;

	mov	ebx, DWORD PTR ?DynLightSurfs@URender@@2PAHA[eax*4]
	inc	eax
	mov	DWORD PTR [esi+ebx*4], 0
	mov	ebx, DWORD PTR _Frame$[ebp]
	jmp	SHORT $L16338
$L16340:

; 1803 : 	}
; 1804 : 	for( i=0; i<NumDynLightLeaves; i++ )

	mov	ecx, DWORD PTR ?NumDynLightLeaves@URender@@2HA ; URender::NumDynLightLeaves
	xor	eax, eax
$L16341:
	cmp	eax, ecx
	jge	SHORT $L16343

; 1805 : 	{
; 1806 : 		LeafLights[ DynLightLeaves[i] ] = NULL;

	mov	esi, DWORD PTR ?DynLightLeaves@URender@@2PAHA[eax*4]
	inc	eax
	mov	DWORD PTR [edx+esi*4], 0
	jmp	SHORT $L16341
$L16343:

; 1807 : 	}
; 1808 : 
; 1809 : 	// Occlude child frames.
; 1810 : 	for( FSceneNode* F=Frame->Child; F; F=F->Sibling )

	mov	esi, DWORD PTR [ebx+16]
$L16345:
	test	esi, esi
	je	SHORT $L16302

; 1811 : 		OccludeFrame( F );

	push	esi
	mov	ecx, edi
	call	?OccludeFrame@URender@@QAEXPAUFSceneNode@@@Z ; URender::OccludeFrame
	mov	esi, DWORD PTR [esi+12]
	jmp	SHORT $L16345
$L21338:

; 1812 : 
; 1813 : 	unguard;

	mov	ecx, DWORD PTR _Err$16348[ebp]
	lea	edx, DWORD PTR $T21336[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	edx
	mov	DWORD PTR $T21336[ebp], ecx
	call	__CxxThrowException@8
	mov	eax, $L16302
	ret	0
$L21339:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??OccludeFrame@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S16301
	push	OFFSET FLAT:$SG16350
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L16302
	ret	0
$L16302:

; 1814 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
$L21386:
	mov	eax, OFFSET FLAT:$T21374
	jmp	___CxxFrameHandler
text$x	ENDS
?OccludeFrame@URender@@QAEXPAUFSceneNode@@@Z ENDP	; URender::OccludeFrame
PUBLIC	?appSort@@YAXPAUFBspDrawListPtr@@HH@Z		; appSort
PUBLIC	??D@YA?AVFVector@@MABV0@@Z			; operator*
PUBLIC	?Clamp@@YAHHHH@Z				; Clamp
PUBLIC	?DrawFrame@URender@@QAEXPAUFSceneNode@@@Z	; URender::DrawFrame
EXTRN	__imp_??_7HBspSurf@@6B@:QWORD
EXTRN	__imp_?IsValid@UObject@@QAEHXZ:NEAR
EXTRN	__imp_?GHashTbl@@3PAKA:BYTE
EXTRN	__imp_?Create@FMemCache@@QAEPAE_KAAPAVFCacheItem@1@HHHH@Z:NEAR
EXTRN	__imp_?appSin@@YANN@Z:NEAR
EXTRN	__imp_?appCos@@YANN@Z:NEAR
EXTRN	__imp_?GetByteCount@FMemStack@@QAEHXZ:NEAR
EXTRN	__imp_?Update@UTexture@@QAEXN@Z:NEAR
EXTRN	?DrawActorSprite@URender@@QAEXPAUFSceneNode@@PAUFDynamicSprite@@@Z:NEAR ; URender::DrawActorSprite
EXTRN	__imp_?PushHit@UViewport@@QAEXABUHHitProxy@@H@Z:NEAR
EXTRN	__imp_?PopHit@UViewport@@QAEXH@Z:NEAR
_BSS	SEGMENT
_?LastTime@?EI@??DrawFrame@URender@@QAEXPAUFSceneNode@@@Z@4NA$S16478 DQ 01H DUP (?)
_?$S117@?EI@??DrawFrame@URender@@QAEXPAUFSceneNode@@@Z@4EA$S16480 DB 01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
$T21953	DD	0420c0000r			; 35
	ORG $+4
$T21954	DQ	04070000000000000r		; 256
$T21955	DQ	0bf70000000000000r		; -0.00390625
$T21956	DQ	04002666666666666r		; 2.3
$T21957	DQ	0c010000000000000r		; -4
$T21958	DQ	0c020000000000000r		; -8
$T21959	DD	03b808081r			; 0.00392157
$T21960	DD	03b800000r			; 0.00390625
$T21961	DQ	0bfb0000000000000r		; -0.0625
$T21962	DQ	03fe0000000000000r		; 0.5
$T21963	DD	043800000r			; 256
	ORG $+4
$T21964	DQ	0c1f0000000000000r		; -4.29497e+009
$T21965	DQ	04008000000000000r		; 3
$T21966	DD	03c40c0c1r			; 0.0117647
$T21967	DD	03c430c31r			; 0.0119048
$T21968	DQ	03f70101010101010r		; 0.00392157
$T21969	DD	03f4ccccdr			; 0.8
$T21970	DD	03f000000r			; 0.5
CONST	ENDS
xdata$x	SEGMENT
$T21934	DD	019930520H
	DD	02H
	DD	FLAT:$T21982
	DD	01H
	DD	FLAT:$T21983
	DD	2 DUP(00H)
	ORG $+4
$T21982	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T21983	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T21984
	ORG $+4
$T21984	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0fffffe38H
	DD	FLAT:$L21424
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L21425
xdata$x	ENDS
_TEXT	SEGMENT
_DrawPtr$16403 = -84
_Draw$16407 = -24
_PanU$16409 = -80
_PanV$16412 = -48
_T$16416 = -88
_Surface$16417 = -152
_TextureMap$16418 = -584
_Texture$16419 = -72
_BumpMap$16421 = -932
_DetailTexture$16423 = -816
_MacroTexture$16425 = -700
_Facet$16427 = -376
_Color$16436 = -60
_Item$16465 = -20
_Delta$16482 = -68
_i$16483 = -84
_iFree$16488 = -24
_Loc$16506 = -116
_H$16509 = -68
_Hue$16510 = -100
_Color$16517 = -200
_X$16523 = -64
_Y$16524 = -28
_Scale$16525 = -88
_Err$16529 = -456
$T21684 = -216
$T21685 = -944
$T21686 = -240
$T21687 = -468
_Temp$21689 = -228
$T21716 = -440
$T21727 = -48
$T21736 = -272
$T21743 = -80
$T21744 = -36
$T21757 = -36
$T21770 = -36
$T21783 = -36
$T21796 = -204
_I$21799 = -256
_I$21806 = -252
_I$21813 = -248
_I$21820 = -64
_L$21863 = -28
_H$21864 = -64
_L$21867 = -28
_H$21868 = -64
_L$21871 = -28
_H$21872 = -64
_Temp$21899 = -60
__$EHRec$ = -16
$T21392 = -188
$T21393 = -424
$T21399 = -116
$T21402 = -164
$T21404 = -20
$T21406 = -452
$T21408 = -216
$T21410 = -228
$T21411 = -164
$T21417 = -188
$T21418 = -176
$T21419 = -244
$T21420 = -204
$T21421 = -468
$T21422 = 8
_Frame$ = 8
_this$ = -28
_Viewport$16357 = -44
_Model$16358 = -104
_Num$16366 = -60
_Pass$16367 = -68
_FirstDraw$16375 = -200
$T21499 = -72
_LastDraw$16379 = -176
?DrawFrame@URender@@QAEXPAUFSceneNode@@@Z PROC NEAR	; URender::DrawFrame

; 1817 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L21980
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 928				; 000003a0H
	push	ebx
	push	esi
	push	edi

; 1818 : 	guard(URender::DrawFrame);
; 1819 : 	UViewport* Viewport = Frame->Viewport;

	mov	edi, DWORD PTR _Frame$[ebp]
	mov	ebx, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, DWORD PTR [edi]

; 1820 : 	UModel*	   Model    = Frame->Level->Model;

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR _Viewport$16357[ebp], eax
	mov	DWORD PTR _this$[ebp], ebx
	mov	eax, DWORD PTR [ecx+192]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR _Model$16358[ebp], eax

; 1821 : 	check(Model->Nodes->Num()>0);

	mov	edx, DWORD PTR [eax+140]
	mov	eax, DWORD PTR [edx+92]
	test	eax, eax
	jg	SHORT $L16359
	push	1821					; 0000071dH
	push	OFFSET FLAT:$SG16360
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L16359:

; 1824 : 	for( FSceneNode* F=Frame->Child; F; F=F->Sibling )

	mov	esi, DWORD PTR [edi+16]
$L16362:
	test	esi, esi
	je	SHORT $L16364

; 1825 : 		DrawFrame( F );

	push	esi
	mov	ecx, ebx
	call	?DrawFrame@URender@@QAEXPAUFSceneNode@@@Z ; URender::DrawFrame
	mov	esi, DWORD PTR [esi+12]
	jmp	SHORT $L16362
$L16364:

; 1827 : 	// Clear the Z-buffer if portal surfaces are visible.
; 1828 : 	if( Frame->Draw[0] )

	mov	eax, DWORD PTR [edi+152]
	test	eax, eax
	je	SHORT $L16365

; 1829 : 		Viewport->RenDev->ClearZ( Frame );

	mov	eax, DWORD PTR _Viewport$16357[ebp]
	push	edi
	mov	ecx, DWORD PTR [eax+112]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+144]
$L16365:

; 1830 : 
; 1831 : 	// Count surfaces to draw.
; 1832 : 	INT Num[3]={0,0,0};

	xor	edx, edx
	xor	ebx, ebx
	mov	DWORD PTR _Num$16366[ebp], ebx
	mov	DWORD PTR _Num$16366[ebp+4], edx
	mov	DWORD PTR _Num$16366[ebp+8], edx

; 1833 : 	for( INT Pass=0; Pass<3; Pass++ )

	xor	ecx, ecx
$L16368:
	cmp	ecx, 3
	jge	SHORT $L16370

; 1834 : 		for( FBspDrawList* Draw = Frame->Draw[Pass]; Draw; Draw = Draw->Next )

	mov	eax, DWORD PTR [edi+ecx*4+152]
$L16372:
	cmp	eax, edx
	je	SHORT $L16369

; 1835 : 			Num[Pass]++;

	mov	esi, DWORD PTR _Num$16366[ebp+ecx*4]
	mov	eax, DWORD PTR [eax+60]
	inc	esi
	mov	DWORD PTR _Num$16366[ebp+ecx*4], esi
	mov	ebx, DWORD PTR _Num$16366[ebp]
	jmp	SHORT $L16372
$L16369:

; 1833 : 	for( INT Pass=0; Pass<3; Pass++ )

	inc	ecx
	jmp	SHORT $L16368
$L16370:

; 1836 : 
; 1837 : 	// Group surfaces into solid (draw-order invariant) and transparent.
; 1838 : 	FBspDrawListPtr* FirstDraw [3] = {new(GMem,Num[0])FBspDrawListPtr,new(GMem,Num[1])FBspDrawListPtr,new(GMem,Num[2])FBspDrawListPtr};

	mov	ecx, DWORD PTR __imp_?GMem@@3VFMemStack@@A
	lea	eax, DWORD PTR [ebx*4]
	push	8
	push	eax
	call	DWORD PTR __imp_?PushBytes@FMemStack@@QAEPAEHH@Z
	mov	edx, DWORD PTR _Num$16366[ebp+4]
	mov	ecx, DWORD PTR __imp_?GMem@@3VFMemStack@@A
	mov	esi, eax
	push	8
	lea	eax, DWORD PTR [edx*4]
	mov	DWORD PTR _FirstDraw$16375[ebp], esi
	push	eax
	call	DWORD PTR __imp_?PushBytes@FMemStack@@QAEPAEHH@Z
	mov	edx, DWORD PTR _Num$16366[ebp+8]
	mov	ecx, DWORD PTR __imp_?GMem@@3VFMemStack@@A
	mov	DWORD PTR _FirstDraw$16375[ebp+4], eax
	push	8
	lea	eax, DWORD PTR [edx*4]
	push	eax
	call	DWORD PTR __imp_?PushBytes@FMemStack@@QAEPAEHH@Z

; 1839 : 	FBspDrawListPtr* LastDraw  [3] = {FirstDraw[0],FirstDraw[1],FirstDraw[2]};

	mov	ecx, DWORD PTR _FirstDraw$16375[ebp+4]
	mov	DWORD PTR _FirstDraw$16375[ebp+8], eax
	mov	DWORD PTR _LastDraw$16379[ebp], esi
	mov	DWORD PTR _LastDraw$16379[ebp+4], ecx
	mov	DWORD PTR _LastDraw$16379[ebp+8], eax

; 1840 : 	for( Pass=0; Pass<3; Pass++ )

	xor	edx, edx
$L16380:
	cmp	edx, 3
	jge	SHORT $L16382

; 1841 : 		for( FBspDrawList* Draw = Frame->Draw[Pass]; Draw; Draw = Draw->Next )

	mov	eax, DWORD PTR [edi+edx*4+152]
$L16384:
	test	eax, eax
	je	SHORT $L16381

; 1842 : 			(LastDraw[Pass]++)->Ptr = Draw;

	mov	ecx, DWORD PTR _LastDraw$16379[ebp+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+60]
	add	ecx, 4
	mov	DWORD PTR _LastDraw$16379[ebp+edx*4], ecx
	jmp	SHORT $L16384
$L16381:

; 1840 : 	for( Pass=0; Pass<3; Pass++ )

	inc	edx
	jmp	SHORT $L16380
$L16382:

; 1843 : 	for( INT i=0; i<Num[0]/2; i++ )

	xor	ecx, ecx
$L16388:
	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jge	SHORT $L16390

; 1844 : 		Exchange( FirstDraw[0][i], FirstDraw[0][Num[0]-i-1] );

	mov	edx, ebx
	sub	edx, ecx
	inc	ecx
	mov	edi, DWORD PTR [esi+edx*4-4]
	lea	eax, DWORD PTR [esi+edx*4-4]
	mov	edx, DWORD PTR [esi+ecx*4-4]
	mov	DWORD PTR [esi+ecx*4-4], edi
	mov	edi, DWORD PTR _Frame$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $L16388
$L16390:

; 1845 : 
; 1846 : 	// Sort solid surfaces by texture and then by palette for cache coherence.
; 1847 : 	appSort( FirstDraw[1], Num[1] );

	mov	eax, DWORD PTR _Num$16366[ebp+4]
	mov	ecx, DWORD PTR _FirstDraw$16375[ebp+4]
	push	8
	push	eax
	push	ecx
	call	?appSort@@YAXPAUFBspDrawListPtr@@HH@Z	; appSort
	add	esp, 12					; 0000000cH

; 1848 : 
; 1849 : 	// Render everything.
; 1850 : 	for( Pass=0; Pass<3; Pass++ )

	xor	ebx, ebx
$L21981:
	cmp	ebx, 3
	mov	DWORD PTR _Pass$16367[ebp], ebx
	jge	$L16402

; 1851 : 	{
; 1852 : 		// Draw everything in the world.
; 1853 : 		for( FBspDrawListPtr* DrawPtr = FirstDraw[Pass]; DrawPtr<LastDraw[Pass]; DrawPtr++ )

	mov	eax, DWORD PTR _FirstDraw$16375[ebp+ebx*4]
	mov	DWORD PTR _DrawPtr$16403[ebp], eax
$L16404:
	cmp	eax, DWORD PTR _LastDraw$16379[ebp+ebx*4]
	jae	$L16406

; 1854 : 		{
; 1855 : 			// Setup for this surface.
; 1856 : 			FBspDrawList*	Draw = DrawPtr->Ptr;

	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR _Draw$16407[ebp], edi

; 1857 : 			FBspSurf*		Surf = &Model->Surfs->Element( Draw->iSurf );

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _Model$16358[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	eax, DWORD PTR [ecx+88]

; 1858 : 
; 1859 : 			// Setup panning.
; 1860 : 			FLOAT PanU = Surf->PanU;

	movsx	ecx, WORD PTR [eax+edx*8+32]
	lea	ebx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR -72+[ebp], ecx
	fild	DWORD PTR -72+[ebp]

; 1861 : 			if( Surf->PolyFlags & PF_AutoUPan )

	mov	eax, DWORD PTR [ebx+4]
	test	ah, 2
	fstp	DWORD PTR _PanU$16409[ebp]
	je	$L16410

; 1862 : 			{
; 1863 : 				PanU += ((INT)(Frame->Level->GetLevelInfo()->TimeSeconds * 35.f * Draw->Zone->TexUPanSpeed * 256.0)&0x3ffff)/256.0;

	mov	edx, DWORD PTR _Frame$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T21499[ebp], eax
	mov	esi, DWORD PTR [eax+88]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $L21480
	push	223					; 000000dfH
	push	OFFSET FLAT:??_C@_0EF@LODM@Check?5failed?3?5Actors?$CI0?$CJ?5?$FLFile?3?4?4@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L21480:
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+12]
$L21495:
	test	eax, eax
	je	SHORT $L21492
	mov	ecx, DWORD PTR __imp_?StaticClass@ALevelInfo@@2PAVUClass@@A
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $L21481
	mov	eax, DWORD PTR [eax+96]
	jmp	SHORT $L21495
$L21492:
	push	224					; 000000e0H
	push	OFFSET FLAT:??_C@_0GD@NDIK@Check?5failed?3?5Actors?$CI0?$CJ?9?$DOIsA?$CIALe@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L21481:
	mov	edx, DWORD PTR $T21499[ebp]
	fld	DWORD PTR _PanU$16409[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	edx, DWORD PTR [edi+56]
	mov	ecx, DWORD PTR [eax]
	fld	DWORD PTR [ecx+640]
	fmul	DWORD PTR [edx+576]
	fmul	DWORD PTR $T21953
	fmul	QWORD PTR $T21954
	call	__ftol
	and	eax, 262143				; 0003ffffH
	mov	DWORD PTR -72+[ebp], eax
	fild	DWORD PTR -72+[ebp]
	fmul	QWORD PTR $T21955
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _PanU$16409[ebp]
$L16410:

; 1864 : 			}
; 1865 : 			FLOAT PanV = Surf->PanV;

	movsx	eax, WORD PTR [ebx+34]
	mov	DWORD PTR -72+[ebp], eax

; 1866 : 			if( Surf->PolyFlags & PF_AutoVPan )

	mov	eax, DWORD PTR [ebx+4]
	fild	DWORD PTR -72+[ebp]
	test	ah, 4
	fstp	DWORD PTR _PanV$16412[ebp]
	je	$L16413

; 1867 : 			{
; 1868 : 				PanV += ((INT)(Frame->Level->GetLevelInfo()->TimeSeconds * 35.f * Draw->Zone->TexVPanSpeed * 256.0)&0x3ffff)/256.0;

	mov	ecx, DWORD PTR _Frame$[ebp]
	mov	edi, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [edi+88]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $L21551
	push	223					; 000000dfH
	push	OFFSET FLAT:??_C@_0EF@LODM@Check?5failed?3?5Actors?$CI0?$CJ?5?$FLFile?3?4?4@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L21551:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+12]
$L21540:
	test	eax, eax
	je	SHORT $L21545
	mov	ecx, DWORD PTR __imp_?StaticClass@ALevelInfo@@2PAVUClass@@A
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $L21552
	mov	eax, DWORD PTR [eax+96]
	jmp	SHORT $L21540
$L21545:
	push	224					; 000000e0H
	push	OFFSET FLAT:??_C@_0GD@NDIK@Check?5failed?3?5Actors?$CI0?$CJ?9?$DOIsA?$CIALe@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L21552:
	mov	edx, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR _Draw$16407[ebp]
	fld	DWORD PTR _PanV$16412[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx+56]
	fld	DWORD PTR [eax+640]
	fmul	DWORD PTR [edx+580]
	fmul	DWORD PTR $T21953
	fmul	QWORD PTR $T21954
	call	__ftol
	and	eax, 262143				; 0003ffffH
	mov	edi, DWORD PTR _Draw$16407[ebp]
	mov	DWORD PTR -72+[ebp], eax
	fild	DWORD PTR -72+[ebp]
	fmul	QWORD PTR $T21955
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _PanV$16412[ebp]
$L16413:

; 1869 : 			}
; 1870 : 			if( Surf->PolyFlags & (PF_SmallWavy | PF_BigWavy) )

	mov	eax, DWORD PTR [ebx+4]
	test	ah, 48					; 00000030H
	je	$L16415

; 1871 : 			{
; 1872 : 				FLOAT T = Frame->Level->GetLevelInfo()->TimeSeconds;

	mov	eax, DWORD PTR _Frame$[ebp]
	mov	edi, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [edi+88]
	cmp	DWORD PTR [esi], 0
	jne	SHORT $L21605
	push	223					; 000000dfH
	push	OFFSET FLAT:??_C@_0EF@LODM@Check?5failed?3?5Actors?$CI0?$CJ?5?$FLFile?3?4?4@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L21605:
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+12]
$L21594:
	test	eax, eax
	je	SHORT $L21599
	mov	edx, DWORD PTR __imp_?StaticClass@ALevelInfo@@2PAVUClass@@A
	cmp	eax, DWORD PTR [edx]
	je	SHORT $L21606
	mov	eax, DWORD PTR [eax+96]
	jmp	SHORT $L21594
$L21599:
	push	224					; 000000e0H
	push	OFFSET FLAT:??_C@_0GD@NDIK@Check?5failed?3?5Actors?$CI0?$CJ?9?$DOIsA?$CIALe@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L21606:
	mov	eax, DWORD PTR [edi+88]

; 1873 : 				PanU += 8.0 * appSin(T) + 4.0 * appCos(2.3*T);

	sub	esp, 8
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+640]
	mov	DWORD PTR _T$16416[ebp], edx
	fld	DWORD PTR _T$16416[ebp]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp_?appSin@@YANN@Z
	fstp	QWORD PTR -96+[ebp]
	fld	DWORD PTR _T$16416[ebp]
	add	esp, 8
	fst	QWORD PTR -40+[ebp]
	fmul	QWORD PTR $T21956
	fstp	QWORD PTR -76+[ebp]
	mov	esi, DWORD PTR -76+[ebp+4]
	mov	edi, DWORD PTR -76+[ebp]
	push	esi
	push	edi
	call	DWORD PTR __imp_?appCos@@YANN@Z
	fstp	QWORD PTR -76+[ebp]
	fld	DWORD PTR _PanU$16409[ebp]
	fld	QWORD PTR -76+[ebp]
	fmul	QWORD PTR $T21957
	fld	QWORD PTR -96+[ebp]
	fmul	QWORD PTR $T21958

; 1874 : 				PanV += 8.0 * appCos(T) + 4.0 * appSin(2.3*T);

	mov	eax, DWORD PTR -40+[ebp+4]
	mov	ecx, DWORD PTR -40+[ebp]
	add	esp, 8
	faddp	ST(1), ST(0)
	push	eax
	push	ecx
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _PanU$16409[ebp]
	call	DWORD PTR __imp_?appCos@@YANN@Z
	fstp	QWORD PTR -96+[ebp]
	add	esp, 8
	push	esi
	push	edi
	call	DWORD PTR __imp_?appSin@@YANN@Z
	fstp	QWORD PTR -40+[ebp]
	fld	DWORD PTR _PanV$16412[ebp]
	fld	QWORD PTR -96+[ebp]
	fmul	QWORD PTR $T21958
	fld	QWORD PTR -40+[ebp]
	fmul	QWORD PTR $T21957
	mov	edi, DWORD PTR _Draw$16407[ebp]
	add	esp, 8
	faddp	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _PanV$16412[ebp]
$L16415:

; 1875 : 			}
; 1876 : 
; 1877 : 			// Make SurfaceInfo.
; 1878 : 			FSurfaceInfo Surface;
; 1879 : 			Surface.Level			= Frame->Level;

	mov	edx, DWORD PTR _Frame$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _Surface$16417[ebp+8], eax

; 1880 : 			Surface.PolyFlags		= Draw->PolyFlags;

	mov	ecx, DWORD PTR [edi+16]

; 1881 : 			Surface.LightMap		= NULL;

	xor	eax, eax
	mov	DWORD PTR _Surface$16417[ebp], ecx
	mov	DWORD PTR _Surface$16417[ebp+16], eax

; 1882 : 			Surface.MacroTexture	= NULL;

	mov	DWORD PTR _Surface$16417[ebp+20], eax

; 1883 : 			Surface.DetailTexture	= NULL;

	mov	DWORD PTR _Surface$16417[ebp+24], eax

; 1884 : 			Surface.FogMap			= NULL;

	mov	DWORD PTR _Surface$16417[ebp+28], eax

; 1885 : 			Surface.BumpMap			= NULL;

	mov	DWORD PTR _Surface$16417[ebp+32], eax

; 1886 : 
; 1887 : 			// Make TextureMap.
; 1888 : 			FTextureInfo TextureMap;
; 1889 : 			UTexture* Texture		= Surf->Texture ? Surf->Texture->Get(Viewport->CurrentTime) : Viewport->Actor->Level->DefaultTexture;

	mov	esi, DWORD PTR [ebx]
	cmp	esi, eax
	je	SHORT $L21390
	mov	edi, DWORD PTR _Viewport$16357[ebp]
	sub	esp, 8
	mov	ecx, esi
	fld	QWORD PTR [edi+168]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp_?Update@UTexture@@QAEXN@Z
	mov	eax, DWORD PTR [esi+188]
	test	eax, eax
	je	SHORT $L21619
	mov	esi, eax
	mov	DWORD PTR _Texture$16419[ebp], esi
	jmp	SHORT $L21391
$L21619:
	mov	DWORD PTR _Texture$16419[ebp], esi
	jmp	SHORT $L21391
$L21390:
	mov	edx, DWORD PTR _Viewport$16357[ebp]
	mov	edi, edx
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR [eax+92]
	mov	esi, DWORD PTR [ecx+920]
	mov	DWORD PTR _Texture$16419[ebp], esi
$L21391:

; 1890 : 			Texture->Lock( TextureMap, Viewport->CurrentTime );

	mov	eax, DWORD PTR [edi+172]
	mov	ecx, DWORD PTR [edi+168]
	mov	edx, DWORD PTR [esi]
	push	eax
	lea	eax, DWORD PTR _TextureMap$16418[ebp]
	push	ecx
	push	eax
	mov	ecx, esi
	call	DWORD PTR [edx+104]

; 1891 : 			TextureMap.Pan			= FVector( -PanU, -PanV, 0 );

	fld	DWORD PTR _PanU$16409[ebp]
	fchs
	fstp	DWORD PTR $T21392[ebp]
	fld	DWORD PTR _PanV$16412[ebp]
	mov	ecx, DWORD PTR $T21392[ebp]
	mov	DWORD PTR $T21392[ebp+8], 0
	mov	eax, DWORD PTR $T21392[ebp+8]
	mov	DWORD PTR _TextureMap$16418[ebp+16], ecx
	fchs
	fstp	DWORD PTR $T21392[ebp+4]
	mov	edx, DWORD PTR $T21392[ebp+4]

; 1892 : 			Surface.Texture			= &TextureMap;

	lea	ecx, DWORD PTR _TextureMap$16418[ebp]
	mov	DWORD PTR _TextureMap$16418[ebp+20], edx
	mov	DWORD PTR _TextureMap$16418[ebp+24], eax
	mov	DWORD PTR _Surface$16417[ebp+12], ecx

; 1893 : 
; 1894 : 			// Make BumpMap.
; 1895 : 			FTextureInfo BumpMap;
; 1896 : 			if( Texture->BumpMap )

	mov	ecx, DWORD PTR [esi+132]
	test	ecx, ecx
	je	SHORT $L16422

; 1897 : 			{
; 1898 : 				Texture->BumpMap->Lock( BumpMap, Viewport->CurrentTime );

	mov	eax, DWORD PTR [edi+172]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edi+168]
	push	eax
	lea	eax, DWORD PTR _BumpMap$16421[ebp]
	push	eax
	call	DWORD PTR [edx+104]

; 1899 : 				Surface.BumpMap = &BumpMap;

	lea	ecx, DWORD PTR _BumpMap$16421[ebp]
	mov	DWORD PTR _Surface$16417[ebp+32], ecx
$L16422:

; 1900 : 			}
; 1901 : 
; 1902 : 			// Make DetailTexture.
; 1903 : 			FTextureInfo DetailTexture;
; 1904 : 			if( Texture->DetailTexture )

	mov	ecx, DWORD PTR [esi+136]
	test	ecx, ecx
	je	SHORT $L16424

; 1905 : 			{
; 1906 : 				Texture->DetailTexture->Lock( DetailTexture, Viewport->CurrentTime );

	mov	eax, DWORD PTR [edi+172]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edi+168]
	push	eax
	lea	eax, DWORD PTR _DetailTexture$16423[ebp]
	push	eax
	call	DWORD PTR [edx+104]

; 1907 : 				Surface.DetailTexture = &DetailTexture;

	lea	ecx, DWORD PTR _DetailTexture$16423[ebp]
	mov	DWORD PTR _Surface$16417[ebp+24], ecx
$L16424:

; 1908 : 			}
; 1909 : 
; 1910 : 			// Make MacroTexture.
; 1911 : 			FTextureInfo MacroTexture;
; 1912 : 			if( Texture->MacroTexture )

	mov	ecx, DWORD PTR [esi+140]
	test	ecx, ecx
	je	SHORT $L16426

; 1913 : 			{
; 1914 : 				Texture->MacroTexture->Lock( MacroTexture, Viewport->CurrentTime );

	mov	eax, DWORD PTR [edi+172]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edi+168]
	push	eax
	lea	eax, DWORD PTR _MacroTexture$16425[ebp]
	push	eax
	call	DWORD PTR [edx+104]

; 1915 : 				Surface.MacroTexture = &MacroTexture;

	lea	ecx, DWORD PTR _MacroTexture$16425[ebp]
	mov	DWORD PTR _Surface$16417[ebp+20], ecx
$L16426:

; 1916 : 			}
; 1917 : 
; 1918 : 			// Make SurfaceFacet.
; 1919 : 			FSurfaceFacet Facet;

	lea	ecx, DWORD PTR _Facet$16427[ebp+48]
	call	DWORD PTR __imp_??0FCoords@@QAE@XZ

; 1920 : 			Facet.Polys = Draw->Polys;

	mov	eax, DWORD PTR _Draw$16407[ebp]

; 1921 : 			Facet.Span = &Draw->Span;
; 1922 : 			Facet.MapCoords = FCoords
; 1923 : 			(
; 1924 : 				Model->Points->Element (Surf->pBase),
; 1925 : 				Model->Vectors->Element(Surf->vTextureU),
; 1926 : 				Model->Vectors->Element(Surf->vTextureV),
; 1927 : 				Model->Vectors->Element(Surf->vNormal)
; 1928 : 			);

	lea	esi, DWORD PTR $T21393[ebp]
	lea	edi, DWORD PTR _Facet$16427[ebp]
	mov	edx, DWORD PTR [eax+72]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _Facet$16427[ebp+100], edx
	mov	edx, DWORD PTR _Model$16358[ebp]
	mov	DWORD PTR _Facet$16427[ebp+96], eax
	mov	ecx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [edx+132]
	mov	edx, DWORD PTR [edx+136]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	mov	edx, DWORD PTR [edx+88]
	mov	eax, DWORD PTR [eax+88]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T21393[ebp], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T21393[ebp+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T21393[ebp+8], ecx
	mov	ecx, DWORD PTR [ebx+16]
	lea	edx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T21393[ebp+12], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T21393[ebp+16], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T21393[ebp+20], ecx
	mov	ecx, DWORD PTR [ebx+20]
	lea	edx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T21393[ebp+24], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T21393[ebp+28], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T21393[ebp+32], ecx
	mov	ecx, DWORD PTR [ebx+12]
	lea	edx, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T21393[ebp+36], ecx
	mov	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T21393[ebp+40], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR $T21393[ebp+44], eax
	rep movsd

; 1929 : 
; 1930 : 			// Setup lighting for this surface.
; 1931 : 			if( Surf->iLightMap!=INDEX_NONE && Viewport->Actor->RendMap==REN_DynLight && Model->LightMap.Num() )

	cmp	DWORD PTR [ebx+24], -1
	je	SHORT $L16429
	mov	ecx, DWORD PTR _Viewport$16357[ebp]
	mov	edx, DWORD PTR [ecx+92]
	cmp	DWORD PTR [edx+1040], 5
	jne	SHORT $L16429
	mov	eax, DWORD PTR _Model$16358[ebp]
	mov	ecx, DWORD PTR [eax+160]
	test	ecx, ecx
	je	SHORT $L16429

; 1932 : 				GLightManager->SetupForSurf
; 1933 : 				(
; 1934 : 					Frame,
; 1935 : 					Facet.MapCoords,
; 1936 : 					Draw,
; 1937 : 					Surface.LightMap,
; 1938 : 					Surface.FogMap,
; 1939 : 					Surface.BumpMap,
; 1940 : 					Pass==0
; 1941 : 				);

	mov	edi, DWORD PTR _Pass$16367[ebp]
	xor	eax, eax
	test	edi, edi
	sete	al
	push	eax
	mov	eax, DWORD PTR _Surface$16417[ebp+32]
	push	eax
	lea	eax, DWORD PTR _Surface$16417[ebp+28]
	mov	ecx, DWORD PTR ?GLightManager@@3PAVFLightManagerBase@@A ; GLightManager
	push	eax
	lea	eax, DWORD PTR _Surface$16417[ebp+16]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR _Draw$16407[ebp]
	push	eax
	lea	eax, DWORD PTR _Facet$16427[ebp]
	push	eax
	mov	eax, DWORD PTR _Frame$[ebp]
	push	eax
	call	DWORD PTR [edx+12]
$L16429:

; 1942 : 
; 1943 : 			// Update facet.
; 1944 : 			Facet.MapCoords *= Frame->Coords;

	mov	ecx, DWORD PTR _Frame$[ebp]
	lea	edx, DWORD PTR _Temp$21689[ebp]
	lea	esi, DWORD PTR [ecx+52]
	lea	ecx, DWORD PTR _Facet$16427[ebp]
	push	esi
	push	edx
	call	DWORD PTR __imp_??GFVector@@QBE?AV0@ABV0@@Z
	lea	eax, DWORD PTR [esi+36]
	lea	ecx, DWORD PTR _Temp$21689[ebp]
	push	eax
	call	DWORD PTR __imp_??UFVector@@QBEMABV0@@Z
	fstp	DWORD PTR -48+[ebp]
	lea	ecx, DWORD PTR [esi+24]
	push	ecx
	lea	ecx, DWORD PTR _Temp$21689[ebp]
	call	DWORD PTR __imp_??UFVector@@QBEMABV0@@Z
	fstp	DWORD PTR -80+[ebp]
	lea	edx, DWORD PTR [esi+12]
	lea	ecx, DWORD PTR _Temp$21689[ebp]
	push	edx
	call	DWORD PTR __imp_??UFVector@@QBEMABV0@@Z
	mov	eax, DWORD PTR -48+[ebp]
	mov	ecx, DWORD PTR -80+[ebp]
	fstp	DWORD PTR -36+[ebp]
	mov	edx, DWORD PTR -36+[ebp]
	push	eax
	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T21684[ebp]
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	mov	eax, DWORD PTR $T21684[ebp]
	mov	ecx, DWORD PTR $T21684[ebp+4]
	mov	edx, DWORD PTR $T21684[ebp+8]
	mov	DWORD PTR _Facet$16427[ebp], eax
	lea	eax, DWORD PTR $T21685[ebp]
	mov	DWORD PTR _Facet$16427[ebp+4], ecx
	push	esi
	push	eax
	lea	ecx, DWORD PTR _Facet$16427[ebp+12]
	mov	DWORD PTR _Facet$16427[ebp+8], edx
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	DWORD PTR _Facet$16427[ebp+12], ecx
	mov	edx, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR $T21686[ebp]
	mov	DWORD PTR _Facet$16427[ebp+16], edx
	mov	eax, DWORD PTR [eax+8]
	push	ecx
	lea	ecx, DWORD PTR _Facet$16427[ebp+24]
	mov	DWORD PTR _Facet$16427[ebp+20], eax
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	DWORD PTR _Facet$16427[ebp+24], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _Facet$16427[ebp+28], ecx
	mov	edx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR $T21687[ebp]
	lea	ecx, DWORD PTR _Facet$16427[ebp+36]
	push	eax
	mov	DWORD PTR _Facet$16427[ebp+32], edx
	call	DWORD PTR __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _Facet$16427[ebp+36], ecx
	mov	edx, DWORD PTR [eax+4]

; 1945 : 
; 1946 : 			// Handle flatshading.
; 1947 : 			if
; 1948 : 			(	Viewport->Actor->RendMap==REN_Polys
; 1949 : 			||	Viewport->Actor->RendMap==REN_PolyCuts
; 1950 : 			||	Viewport->Actor->RendMap==REN_Zones )

	mov	ecx, DWORD PTR _Viewport$16357[ebp]
	mov	DWORD PTR _Facet$16427[ebp+40], edx
	mov	eax, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [ecx+92]
	mov	DWORD PTR _Facet$16427[ebp+44], eax
	mov	eax, DWORD PTR [ebx+1040]
	cmp	eax, 3
	je	SHORT $L16431
	cmp	eax, 4
	je	SHORT $L16431
	cmp	eax, 2
	jne	$L16430
$L16431:

; 1951 : 			{
; 1952 : 				UModel*		Model		= Viewport->Actor->XLevel->Model;

	mov	edx, DWORD PTR [ebx+96]

; 1953 : 				FBspNode*	Node 		= &Model->Nodes->Element( Draw->iNode );

	mov	eax, DWORD PTR _Draw$16407[ebp]
	mov	ecx, DWORD PTR [edx+192]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR -48+[ebp], eax
	mov	edx, DWORD PTR [ecx+140]

; 1954 : 				FBspSurf*	Surf 		= &Model->Surfs->Element( Node->iSurf );

	mov	ecx, DWORD PTR [ecx+144]
	shl	eax, 6
	mov	esi, DWORD PTR [edx+88]
	mov	DWORD PTR -36+[ebp], edx
	add	eax, esi
	mov	edi, DWORD PTR [eax+28]
	mov	eax, DWORD PTR [ecx+88]
	lea	edx, DWORD PTR [edi+edi*4]

; 1955 : 				UTexture*	Texture		= Surf->Texture ? Surf->Texture->Get(Viewport->CurrentTime) : Viewport->Actor->Level->DefaultTexture;

	mov	esi, DWORD PTR [eax+edx*8]
	lea	eax, DWORD PTR [eax+edx*8]
	test	esi, esi
	je	SHORT $L21394
	mov	ecx, DWORD PTR _Viewport$16357[ebp]
	sub	esp, 8
	fld	QWORD PTR [ecx+168]
	fstp	QWORD PTR [esp]
	mov	ecx, esi
	call	DWORD PTR __imp_?Update@UTexture@@QAEXN@Z
	mov	eax, DWORD PTR [esi+188]
	test	eax, eax
	je	SHORT $L21395
	mov	esi, eax
	jmp	SHORT $L21395
$L21394:
	mov	edx, DWORD PTR [ebx+92]
	mov	esi, DWORD PTR [edx+920]
$L21395:

; 1956 : 				FVector Color;
; 1957 : 				if( Viewport->Actor->RendMap!=REN_Zones || Model->Nodes->NumZones==0 )

	mov	ebx, DWORD PTR [ebx+1040]
	cmp	ebx, 2
	jne	$L16438
	mov	eax, DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR [eax+100]
	test	ecx, ecx
	je	$L16438

; 1961 : 				}
; 1962 : 				else
; 1963 : 				{
; 1964 : 					if( Draw->iZone == 0 )

	mov	ecx, DWORD PTR _Draw$16407[ebp]
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	jne	SHORT $L16443

; 1965 : 						Color = Texture->MipZero.Plane();

	xor	edx, edx
	mov	al, BYTE PTR [esi+117]
	mov	dl, BYTE PTR [esi+116]
	xor	ecx, ecx
	mov	DWORD PTR -36+[ebp], edx
	mov	cl, BYTE PTR [esi+118]
	fild	DWORD PTR -36+[ebp]
	mov	DWORD PTR -36+[ebp], eax
	fmul	DWORD PTR $T21959
	fstp	DWORD PTR $T21736[ebp]
	fild	DWORD PTR -36+[ebp]
	mov	DWORD PTR -36+[ebp], ecx
	mov	edx, DWORD PTR $T21736[ebp]
	mov	DWORD PTR _Color$16436[ebp], edx
	fmul	DWORD PTR $T21959
	fstp	DWORD PTR $T21736[ebp+4]
	fild	DWORD PTR -36+[ebp]
	mov	eax, DWORD PTR $T21736[ebp+4]
	mov	DWORD PTR _Color$16436[ebp+4], eax
	fmul	DWORD PTR $T21959
	fstp	DWORD PTR $T21736[ebp+8]
	mov	ecx, DWORD PTR $T21736[ebp+8]
	mov	DWORD PTR _Color$16436[ebp+8], ecx

; 1966 : 					else

	jmp	$L16445
$L16443:

; 1967 : 						Color = FVector( (Draw->iZone*67)&255, (Draw->iZone*1371)&255, (Draw->iZone*1991)&255 )/256.0;

	mov	edx, eax
	shl	edx, 5
	add	edx, eax
	lea	ecx, DWORD PTR [eax+edx*2]
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR -36+[ebp], ecx
	lea	ecx, DWORD PTR [eax+eax*4]
	fild	DWORD PTR -36+[ebp]
	lea	edx, DWORD PTR [ecx+ecx*8]
	lea	ecx, DWORD PTR [eax+edx*2]
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR -36+[ebp], ecx
	lea	ecx, DWORD PTR [eax+eax*4]
	fild	DWORD PTR -36+[ebp]
	shl	ecx, 2
	sub	ecx, eax
	fstp	DWORD PTR $T21743[ebp]
	neg	ecx
	lea	edx, DWORD PTR [ecx+ecx*2]
	and	edx, 255				; 000000ffH
	mov	DWORD PTR -36+[ebp], edx
	fild	DWORD PTR -36+[ebp]
	fstp	DWORD PTR $T21744[ebp]
	fmul	DWORD PTR $T21960
	fstp	DWORD PTR $T21402[ebp]
	fld	DWORD PTR $T21743[ebp]
	fmul	DWORD PTR $T21960
	mov	eax, DWORD PTR $T21402[ebp]
	mov	DWORD PTR _Color$16436[ebp], eax
	fstp	DWORD PTR $T21402[ebp+4]
	fld	DWORD PTR $T21744[ebp]
	fmul	DWORD PTR $T21960
	mov	ecx, DWORD PTR $T21402[ebp+4]
	mov	DWORD PTR _Color$16436[ebp+4], ecx
	fstp	DWORD PTR $T21402[ebp+8]
	mov	edx, DWORD PTR $T21402[ebp+8]
	mov	DWORD PTR _Color$16436[ebp+8], edx
$L16445:

; 1968 : 					Color *= (0.5 + (Draw->iNode&7)/16.0);

	mov	eax, DWORD PTR -48+[ebp]
	and	eax, 7
	mov	DWORD PTR -36+[ebp], eax
	fild	DWORD PTR -36+[ebp]
	fmul	QWORD PTR $T21961
	fsubr	QWORD PTR $T21962
	fld	ST(0)
	fmul	DWORD PTR _Color$16436[ebp]
	fstp	DWORD PTR _Color$16436[ebp]
	fld	ST(0)
	fmul	DWORD PTR _Color$16436[ebp+4]
	fstp	DWORD PTR _Color$16436[ebp+4]
	fmul	DWORD PTR _Color$16436[ebp+8]
	fstp	DWORD PTR _Color$16436[ebp+8]
	jmp	$L21752
$L16438:

; 1958 : 				{
; 1959 : 					INT Index = Viewport->Actor->RendMap==REN_Polys ? Node->iSurf : Draw->iNode;

	cmp	ebx, 3
	je	SHORT $L21397
	mov	edi, DWORD PTR -48+[ebp]
$L21397:

; 1960 : 					Color = Texture->MipZero.Plane() * (0.5 + (Index&7)/16.0);

	xor	eax, eax
	xor	ecx, ecx
	mov	al, BYTE PTR [esi+116]
	mov	cl, BYTE PTR [esi+117]
	mov	DWORD PTR -36+[ebp], eax
	xor	edx, edx
	fild	DWORD PTR -36+[ebp]
	mov	DWORD PTR -36+[ebp], ecx
	mov	dl, BYTE PTR [esi+118]
	and	edi, 7
	fmul	DWORD PTR $T21959
	fild	DWORD PTR -36+[ebp]
	mov	DWORD PTR -36+[ebp], edx
	fmul	DWORD PTR $T21959
	fstp	DWORD PTR $T21716[ebp+4]
	fild	DWORD PTR -36+[ebp]
	mov	DWORD PTR -36+[ebp], edi
	fmul	DWORD PTR $T21959
	fstp	DWORD PTR $T21716[ebp+8]
	fild	DWORD PTR -36+[ebp]
	fmul	QWORD PTR $T21961
	fsubr	QWORD PTR $T21962
	fst	DWORD PTR $T21727[ebp]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T21399[ebp]
	mov	eax, DWORD PTR $T21399[ebp]
	fstp	ST(0)
	fld	DWORD PTR $T21727[ebp]
	fmul	DWORD PTR $T21716[ebp+4]
	mov	DWORD PTR _Color$16436[ebp], eax
	fstp	DWORD PTR $T21399[ebp+4]
	fld	DWORD PTR $T21727[ebp]
	fmul	DWORD PTR $T21716[ebp+8]
	mov	ecx, DWORD PTR $T21399[ebp+4]
	mov	DWORD PTR _Color$16436[ebp+4], ecx
	fstp	DWORD PTR $T21399[ebp+8]
	mov	edx, DWORD PTR $T21399[ebp+8]
	mov	DWORD PTR _Color$16436[ebp+8], edx

; 1968 : 					Color *= (0.5 + (Draw->iNode&7)/16.0);

$L21752:

; 1969 : 				}
; 1970 : 				Surface.FlatColor = FColor(Color);

	fld	DWORD PTR _Color$16436[ebp]
	fmul	DWORD PTR $T21963
	fstp	DWORD PTR $T21757[ebp]

; 1820 : 	UModel*	   Model    = Frame->Level->Model;

	fld	DWORD PTR $T21757[ebp]

; 1821 : 	check(Model->Nodes->Num()>0);

	fsub	DWORD PTR ?Half@?1??appFloor@@YAHM@Z@4MA ; Half

; 1822 : 

	fistp	DWORD PTR _I$21799[ebp]

; 1969 : 				}
; 1970 : 				Surface.FlatColor = FColor(Color);

	mov	eax, DWORD PTR _I$21799[ebp]
	test	eax, eax
	jge	SHORT $L21802
	mov	BYTE PTR $T21404[ebp], 0
	jmp	SHORT $L21801
$L21802:
	cmp	eax, 255				; 000000ffH
	mov	BYTE PTR $T21404[ebp], al
	jl	SHORT $L21801
	mov	BYTE PTR $T21404[ebp], 255		; 000000ffH
$L21801:
	fld	DWORD PTR _Color$16436[ebp+4]
	fmul	DWORD PTR $T21963
	fstp	DWORD PTR $T21770[ebp]

; 1820 : 	UModel*	   Model    = Frame->Level->Model;

	fld	DWORD PTR $T21770[ebp]

; 1821 : 	check(Model->Nodes->Num()>0);

	fsub	DWORD PTR ?Half@?1??appFloor@@YAHM@Z@4MA ; Half

; 1822 : 

	fistp	DWORD PTR _I$21806[ebp]

; 1969 : 				}
; 1970 : 				Surface.FlatColor = FColor(Color);

	mov	eax, DWORD PTR _I$21806[ebp]
	test	eax, eax
	jge	SHORT $L21809
	mov	BYTE PTR $T21404[ebp+1], 0
	jmp	SHORT $L21808
$L21809:
	cmp	eax, 255				; 000000ffH
	mov	BYTE PTR $T21404[ebp+1], al
	jl	SHORT $L21808
	mov	BYTE PTR $T21404[ebp+1], 255		; 000000ffH
$L21808:
	fld	DWORD PTR _Color$16436[ebp+8]
	fmul	DWORD PTR $T21963
	fstp	DWORD PTR $T21783[ebp]

; 1820 : 	UModel*	   Model    = Frame->Level->Model;

	fld	DWORD PTR $T21783[ebp]

; 1821 : 	check(Model->Nodes->Num()>0);

	fsub	DWORD PTR ?Half@?1??appFloor@@YAHM@Z@4MA ; Half

; 1822 : 

	fistp	DWORD PTR _I$21813[ebp]

; 1969 : 				}
; 1970 : 				Surface.FlatColor = FColor(Color);

	mov	eax, DWORD PTR _I$21813[ebp]
	test	eax, eax
	jge	SHORT $L21816
	mov	BYTE PTR $T21404[ebp+2], 0
	jmp	SHORT $L21815
$L21816:
	cmp	eax, 255				; 000000ffH
	mov	BYTE PTR $T21404[ebp+2], al
	jl	SHORT $L21815
	mov	BYTE PTR $T21404[ebp+2], 255		; 000000ffH
$L21815:
	mov	DWORD PTR $T21796[ebp], 0

; 1820 : 	UModel*	   Model    = Frame->Level->Model;

	fld	DWORD PTR $T21796[ebp]

; 1821 : 	check(Model->Nodes->Num()>0);

	fsub	DWORD PTR ?Half@?1??appFloor@@YAHM@Z@4MA ; Half

; 1822 : 

	fistp	DWORD PTR _I$21820[ebp]

; 1969 : 				}
; 1970 : 				Surface.FlatColor = FColor(Color);

	mov	eax, DWORD PTR _I$21820[ebp]
	push	255					; 000000ffH
	push	0
	push	eax
	call	?Clamp@@YAHHHH@Z			; Clamp
	mov	BYTE PTR $T21404[ebp+3], al

; 1971 : 				Surface.PolyFlags |= PF_FlatShaded;

	mov	eax, DWORD PTR _Surface$16417[ebp]
	mov	ecx, DWORD PTR $T21404[ebp]
	add	esp, 12					; 0000000cH
	or	eax, 1073741824				; 40000000H
	mov	DWORD PTR _Surface$16417[ebp+4], ecx
	mov	DWORD PTR _Surface$16417[ebp], eax
$L16430:

; 1972 : 			}
; 1973 : 
; 1974 : 			// Draw the surface.
; 1975 : 			PUSH_HIT(Frame,HBspSurf(Draw->iSurf));

	mov	edx, DWORD PTR _Frame$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [ecx+184]
	test	eax, eax
	je	SHORT $L16451
	mov	eax, DWORD PTR _Draw$16407[ebp]
	push	12					; 0000000cH
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __imp_??_7HBspSurf@@6B@
	mov	DWORD PTR $T21406[ebp+8], edx
	lea	edx, DWORD PTR $T21406[ebp]
	push	edx
	mov	DWORD PTR $T21406[ebp], eax
	call	DWORD PTR __imp_?PushHit@UViewport@@QAEXABUHHitProxy@@H@Z
$L16451:

; 1820 : 	UModel*	   Model    = Frame->Level->Model;

	xor	eax, eax

; 1821 : 	check(Model->Nodes->Num()>0);

	DB	15					; 0000000fH

; 1822 : 

	DB	49					; 00000031H

; 1823 : 	// First, draw children.

	xor	edx, edx

; 1976 : 			clock(GStat.PolyVTime);

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+136
	sub	ecx, eax

; 1977 : 			Viewport->RenDev->DrawComplexSurface( Frame, Surface, Facet );

	mov	eax, DWORD PTR _Viewport$16357[ebp]
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+136, ecx
	mov	ecx, DWORD PTR [eax+112]
	lea	eax, DWORD PTR _Facet$16427[ebp]
	push	eax
	lea	eax, DWORD PTR _Surface$16417[ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR _Frame$[ebp]
	push	eax
	call	DWORD PTR [edx+124]

; 1820 : 	UModel*	   Model    = Frame->Level->Model;

	xor	eax, eax

; 1821 : 	check(Model->Nodes->Num()>0);

	DB	15					; 0000000fH

; 1822 : 

	DB	49					; 00000031H

; 1823 : 	// First, draw children.

	xor	edx, edx

; 1978 : 			unclock(GStat.PolyVTime);

	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+136
	lea	edx, DWORD PTR [ecx+eax-34]

; 1979 : 			POP_HIT(Frame);

	mov	eax, DWORD PTR _Frame$[ebp]
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+136, edx
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+184]
	test	eax, eax
	je	SHORT $L16454
	push	0
	call	DWORD PTR __imp_?PopHit@UViewport@@QAEXH@Z
$L16454:

; 1980 : 
; 1981 : 			// Finish up.
; 1982 : 			Texture->Unlock( TextureMap );

	mov	ecx, DWORD PTR _Texture$16419[ebp]
	lea	eax, DWORD PTR _TextureMap$16418[ebp]
	push	eax
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+108]

; 1983 : 			if( Texture->DetailTexture )

	mov	ecx, DWORD PTR _Texture$16419[ebp]
	mov	ecx, DWORD PTR [ecx+136]
	test	ecx, ecx
	je	SHORT $L16455

; 1984 : 				Texture->DetailTexture->Unlock( DetailTexture );

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR _DetailTexture$16423[ebp]
	push	eax
	call	DWORD PTR [edx+108]
$L16455:

; 1985 : 			if( Texture->MacroTexture )

	mov	ecx, DWORD PTR _Texture$16419[ebp]
	mov	ecx, DWORD PTR [ecx+140]
	test	ecx, ecx
	je	SHORT $L16456

; 1986 : 				Texture->MacroTexture->Unlock( MacroTexture );

	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR _MacroTexture$16425[ebp]
	push	eax
	call	DWORD PTR [edx+108]
$L16456:

; 1987 : 			if( Surface.LightMap || Surface.FogMap )

	mov	eax, DWORD PTR _Surface$16417[ebp+16]
	test	eax, eax
	jne	SHORT $L16458
	mov	eax, DWORD PTR _Surface$16417[ebp+28]
	test	eax, eax
	je	SHORT $L16405
$L16458:

; 1988 : 				GLightManager->FinishSurf();

	mov	ecx, DWORD PTR ?GLightManager@@3PAVFLightManagerBase@@A ; GLightManager
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+16]
$L16405:
	mov	eax, DWORD PTR _DrawPtr$16403[ebp]
	mov	ebx, DWORD PTR _Pass$16367[ebp]
	mov	edi, DWORD PTR _Frame$[ebp]
	add	eax, 4
	mov	DWORD PTR _DrawPtr$16403[ebp], eax
	jmp	$L16404
$L16406:

; 1989 : 		}
; 1990 : 		if( Pass==1 )

	cmp	ebx, 1
	jne	SHORT $L16401

; 1991 : 			for( FDynamicSprite* Sprite = Frame->Sprite; Sprite; Sprite=Sprite->RenderNext )

	mov	esi, DWORD PTR [edi+164]
$L16461:
	test	esi, esi
	je	SHORT $L16401

; 1992 : 				DrawActorSprite( Frame, Sprite );

	mov	ecx, DWORD PTR _this$[ebp]
	push	esi
	push	edi
	call	?DrawActorSprite@URender@@QAEXPAUFSceneNode@@PAUFDynamicSprite@@@Z ; URender::DrawActorSprite
	mov	esi, DWORD PTR [esi+16]
	jmp	SHORT $L16461
$L16401:

; 1848 : 
; 1849 : 	// Render everything.
; 1850 : 	for( Pass=0; Pass<3; Pass++ )

	inc	ebx
	jmp	$L21981
$L16402:

; 1993 : 	}
; 1994 : 
; 1995 : 	// Optics.
; 1996 : 	if
; 1997 : 	(	Viewport->Actor->Region.iLeaf!=INDEX_NONE
; 1998 : 	&&	Viewport->Actor->Region.Zone 
; 1999 : 	&&	Viewport->RenDev->Coronas )

	mov	ecx, DWORD PTR _Viewport$16357[ebp]
	mov	eax, DWORD PTR [ecx+92]
	cmp	DWORD PTR [eax+128], -1
	je	$L21927
	mov	edx, DWORD PTR [eax+124]
	test	edx, edx
	je	$L21927
	mov	eax, DWORD PTR [ecx+112]
	mov	ecx, DWORD PTR [eax+128]
	test	ecx, ecx
	je	$L21927

; 2000 : 	{
; 2001 : 		// Do coronas.
; 2002 : 		FCacheItem* Item;
; 2003 : 		QWORD CacheID = MakeCacheID( CID_CoronaCache, (UObject*)0 );
; 2004 : 		FCoronaLight* CoronaLights = (FCoronaLight*)GCache.Get( CacheID, Item );

	mov	esi, DWORD PTR __imp_?GCache@@3VFMemCache@@A
	mov	edi, 39					; 00000027H
	mov	ebx, 8

; 1820 : 	UModel*	   Model    = Frame->Level->Model;

	xor	eax, eax

; 1821 : 	check(Model->Nodes->Num()>0);

	DB	15					; 0000000fH

; 1822 : 

	DB	49					; 00000031H

; 1823 : 	// First, draw children.

	xor	edx, edx

; 2000 : 	{
; 2001 : 		// Do coronas.
; 2002 : 		FCacheItem* Item;
; 2003 : 		QWORD CacheID = MakeCacheID( CID_CoronaCache, (UObject*)0 );
; 2004 : 		FCoronaLight* CoronaLights = (FCoronaLight*)GCache.Get( CacheID, Item );

	mov	ecx, DWORD PTR [esi+20]
	sub	ecx, eax
	mov	eax, DWORD PTR [esi+8]
	inc	eax
	mov	DWORD PTR [esi+20], ecx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __imp_?GHashTbl@@3PAKA
	mov	ecx, DWORD PTR [eax+3072]
	mov	edx, DWORD PTR [eax+2048]
	xor	ecx, edx
	mov	edx, DWORD PTR [eax+1024]
	xor	ecx, edx
	mov	edx, DWORD PTR [eax+156]
	xor	ecx, edx
	mov	ecx, DWORD PTR [esi+ecx*4+72]
$L21856:
	test	ecx, ecx
	je	SHORT $L21858
	mov	edx, DWORD PTR [ecx]
	cmp	edx, edi
	jne	SHORT $L21857
	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax
	cmp	edx, eax
	jne	SHORT $L21857
	mov	DWORD PTR _Item$16465[ebp], ecx
	mov	edi, DWORD PTR [ecx+16]
	mov	ax, WORD PTR [esi+4]
	add	edi, 16777216				; 01000000H
	mov	WORD PTR [ecx+12], ax
	mov	DWORD PTR [ecx+16], edi

; 1820 : 	UModel*	   Model    = Frame->Level->Model;

	xor	eax, eax

; 1821 : 	check(Model->Nodes->Num()>0);

	DB	15					; 0000000fH

; 1822 : 

	DB	49					; 00000031H

; 1823 : 	// First, draw children.

	xor	edx, edx

; 2000 : 	{
; 2001 : 		// Do coronas.
; 2002 : 		FCacheItem* Item;
; 2003 : 		QWORD CacheID = MakeCacheID( CID_CoronaCache, (UObject*)0 );
; 2004 : 		FCoronaLight* CoronaLights = (FCoronaLight*)GCache.Get( CacheID, Item );

	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [esi+20]
	add	eax, -34				; ffffffdeH
	add	edx, eax
	lea	edi, DWORD PTR [ecx+ebx-1]
	dec	ebx
	mov	DWORD PTR [esi+20], edx
	not	ebx
	and	edi, ebx
	xor	esi, esi
	jmp	SHORT $L21854
$L21857:
	mov	ecx, DWORD PTR [ecx+28]
	jmp	SHORT $L21856
$L21858:

; 1820 : 	UModel*	   Model    = Frame->Level->Model;

	xor	eax, eax

; 1821 : 	check(Model->Nodes->Num()>0);

	DB	15					; 0000000fH

; 1822 : 

	DB	49					; 00000031H

; 1823 : 	// First, draw children.

	xor	edx, edx

; 2000 : 	{
; 2001 : 		// Do coronas.
; 2002 : 		FCacheItem* Item;
; 2003 : 		QWORD CacheID = MakeCacheID( CID_CoronaCache, (UObject*)0 );
; 2004 : 		FCoronaLight* CoronaLights = (FCoronaLight*)GCache.Get( CacheID, Item );

	mov	ecx, DWORD PTR [esi+20]
	add	eax, -34				; ffffffdeH
	add	ecx, eax
	mov	DWORD PTR [esi+20], ecx
	xor	esi, esi
	xor	edi, edi
$L21854:

; 2005 : 		if( !CoronaLights )

	cmp	edi, esi
	jne	SHORT $L16476

; 2006 : 		{
; 2007 : 			CoronaLights = (FCoronaLight*)GCache.Create( CacheID, Item, MAX_CORONA_LIGHTS * sizeof(FCoronaLight) );

	push	esi
	mov	ecx, DWORD PTR __imp_?GCache@@3VFMemCache@@A
	push	esi
	push	8
	lea	edx, DWORD PTR _Item$16465[ebp]
	push	384					; 00000180H
	xor	eax, eax
	push	edx
	push	eax
	mov	eax, 39					; 00000027H
	push	eax
	call	DWORD PTR __imp_?Create@FMemCache@@QAEPAE_KAAPAVFCacheItem@1@HHHH@Z
	mov	edi, eax

; 2008 : 			for( int i=0; i<MAX_CORONA_LIGHTS; i++ )

	xor	eax, eax
$L16474:
	cmp	eax, 32					; 00000020H
	jge	SHORT $L16476

; 2009 : 				CoronaLights[i]._Actor = NULL;

	lea	ecx, DWORD PTR [eax+eax*2]
	inc	eax
	mov	DWORD PTR [edi+ecx*4], esi
	jmp	SHORT $L16474
$L16476:

; 2010 : 		}
; 2011 : 
; 2012 : 		// Corona and lens flare lighting.
; 2013 : 		static DOUBLE LastTime = appSeconds();

	mov	al, BYTE PTR _?$S117@?EI@??DrawFrame@URender@@QAEXPAUFSceneNode@@@Z@4EA$S16480
	test	al, 1
	jne	SHORT $L16481
	or	al, 1
	mov	BYTE PTR _?$S117@?EI@??DrawFrame@URender@@QAEXPAUFSceneNode@@@Z@4EA$S16480, al

; 1821 : 	check(Model->Nodes->Num()>0);

	xor	eax, eax

; 1822 : 

	xor	edx, edx

; 1823 : 	// First, draw children.

	DB	15					; 0000000fH

; 1824 : 	for( FSceneNode* F=Frame->Child; F; F=F->Sibling )

	DB	49					; 00000031H

; 1825 : 		DrawFrame( F );

	mov	DWORD PTR _L$21863[ebp], eax

; 1826 : 

	mov	DWORD PTR _H$21864[ebp], edx

; 2010 : 		}
; 2011 : 
; 2012 : 		// Corona and lens flare lighting.
; 2013 : 		static DOUBLE LastTime = appSeconds();

	mov	edx, DWORD PTR _L$21863[ebp]
	mov	eax, DWORD PTR _H$21864[ebp]
	mov	DWORD PTR -32+[ebp], edx
	mov	DWORD PTR -32+[ebp+4], esi
	fild	QWORD PTR -32+[ebp]
	mov	DWORD PTR -32+[ebp], eax
	mov	DWORD PTR -32+[ebp+4], esi
	fild	QWORD PTR -32+[ebp]
	mov	ecx, DWORD PTR __imp_?GSecondsPerCycle@@3NA
	fmul	QWORD PTR $T21964
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR [ecx]
	fstp	QWORD PTR _?LastTime@?EI@??DrawFrame@URender@@QAEXPAUFSceneNode@@@Z@4NA$S16478
$L16481:

; 1821 : 	check(Model->Nodes->Num()>0);

	xor	eax, eax

; 1822 : 

	xor	edx, edx

; 1823 : 	// First, draw children.

	DB	15					; 0000000fH

; 1824 : 	for( FSceneNode* F=Frame->Child; F; F=F->Sibling )

	DB	49					; 00000031H

; 1825 : 		DrawFrame( F );

	mov	DWORD PTR _L$21867[ebp], eax

; 1826 : 

	mov	DWORD PTR _H$21868[ebp], edx

; 2014 : 		FLOAT Delta            = 3.0 * (appSeconds() - LastTime);

	mov	edx, DWORD PTR _L$21867[ebp]
	mov	eax, DWORD PTR _H$21868[ebp]
	mov	DWORD PTR -32+[ebp], edx
	mov	DWORD PTR -32+[ebp+4], esi
	fild	QWORD PTR -32+[ebp]
	mov	DWORD PTR -32+[ebp], eax
	mov	DWORD PTR -32+[ebp+4], esi
	fild	QWORD PTR -32+[ebp]
	mov	ecx, DWORD PTR __imp_?GSecondsPerCycle@@3NA
	fmul	QWORD PTR $T21964
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR [ecx]
	fsub	QWORD PTR _?LastTime@?EI@??DrawFrame@URender@@QAEXPAUFSceneNode@@@Z@4NA$S16478
	fmul	QWORD PTR $T21965
	fstp	DWORD PTR _Delta$16482[ebp]

; 1821 : 	check(Model->Nodes->Num()>0);

	xor	eax, eax

; 1822 : 

	xor	edx, edx

; 1823 : 	// First, draw children.

	DB	15					; 0000000fH

; 1824 : 	for( FSceneNode* F=Frame->Child; F; F=F->Sibling )

	DB	49					; 00000031H

; 1825 : 		DrawFrame( F );

	mov	DWORD PTR _L$21871[ebp], eax

; 1826 : 

	mov	DWORD PTR _H$21872[ebp], edx

; 2015 : 		LastTime               = appSeconds();

	mov	edx, DWORD PTR _L$21871[ebp]
	mov	eax, DWORD PTR _H$21872[ebp]
	mov	DWORD PTR -32+[ebp], edx
	mov	DWORD PTR -32+[ebp+4], esi
	fild	QWORD PTR -32+[ebp]
	mov	DWORD PTR -32+[ebp], eax
	mov	DWORD PTR -32+[ebp+4], esi
	fild	QWORD PTR -32+[ebp]
	mov	ecx, DWORD PTR __imp_?GSecondsPerCycle@@3NA

; 2016 : 		for( int i=0; i<MAX_CORONA_LIGHTS; i++ )

	xor	edx, edx
	fmul	QWORD PTR $T21964
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR [ecx]
	fstp	QWORD PTR _?LastTime@?EI@??DrawFrame@URender@@QAEXPAUFSceneNode@@@Z@4NA$S16478
$L16484:
	cmp	edx, 32					; 00000020H
	jge	SHORT $L16486

; 2017 : 			if( CoronaLights[i]._Actor && (CoronaLights[i].Bright-=Delta)<0 )

	lea	eax, DWORD PTR [edx+edx*2]
	lea	ecx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [edi+eax*4]
	cmp	eax, esi
	je	SHORT $L16485
	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR _Delta$16482[ebp]
	fst	DWORD PTR [ecx+8]
	fcomp	DWORD PTR $T18924
	fnstsw	ax
	test	ah, 1
	je	SHORT $L16485

; 2018 : 				CoronaLights[i]._Actor = NULL;

	mov	DWORD PTR [ecx], esi
$L16485:

; 2016 : 		for( int i=0; i<MAX_CORONA_LIGHTS; i++ )

	inc	edx
	jmp	SHORT $L16484
$L16486:

; 2019 : 		INT iFree=0;
; 2020 : 		INT iPermeating = Viewport->Actor->XLevel->Model->Leaves(Viewport->Actor->Region.iLeaf).iPermeating;

	mov	ecx, DWORD PTR _Viewport$16357[ebp]
	mov	DWORD PTR _iFree$16488[ebp], esi
	mov	eax, DWORD PTR [ecx+92]
	mov	edx, DWORD PTR [eax+96]
	mov	eax, DWORD PTR [eax+128]
	mov	ecx, DWORD PTR [edx+192]
	lea	eax, DWORD PTR [eax+eax*4]
	mov	edx, DWORD PTR [ecx+204]
	mov	eax, DWORD PTR [edx+eax*4+4]

; 2021 : 		if( iPermeating!=INDEX_NONE )

	cmp	eax, -1
	je	SHORT $L21975

; 2022 : 		{
; 2023 : 			AActor** LightPtr = &Viewport->Actor->XLevel->Model->Lights(iPermeating);

	mov	ecx, DWORD PTR [ecx+216]
	mov	ebx, DWORD PTR _Delta$16482[ebp]
	lea	esi, DWORD PTR [ecx+eax*4]
$L16493:

; 2024 : 			while( *LightPtr )

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $L16494

; 2025 : 				GAddCorona( CoronaLights, iFree, Viewport, Viewport->Actor, *LightPtr++, Delta );

	push	ebx
	push	eax
	mov	eax, DWORD PTR _Viewport$16357[ebp]
	add	esi, 4
	mov	edx, DWORD PTR [eax+92]
	push	edx
	push	eax
	lea	eax, DWORD PTR _iFree$16488[ebp]
	push	eax
	push	edi
	call	?GAddCorona@@YAXPAUFCoronaLight@@AAHPAVUViewport@@PAVAPawn@@PAVAActor@@M@Z ; GAddCorona
	add	esp, 24					; 00000018H
	jmp	SHORT $L16493
$L21975:
	mov	ebx, DWORD PTR _Delta$16482[ebp]
$L16494:

; 2026 : 		}
; 2027 : 		for( FVolActorLink* Link=LeafLights[Viewport->Actor->Region.iLeaf]; Link; Link=Link->Next )

	mov	ecx, DWORD PTR _Viewport$16357[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	ecx, DWORD PTR ?LeafLights@URender@@2PAPAUFVolActorLink@@A ; URender::LeafLights
	mov	eax, DWORD PTR [edx+128]
	mov	esi, DWORD PTR [ecx+eax*4]
$L16496:
	test	esi, esi
	je	SHORT $L16498

; 2028 : 			GAddCorona( CoronaLights, iFree, Viewport, Viewport->Actor, Link->Actor, Delta );

	mov	eax, DWORD PTR _Viewport$16357[ebp]
	mov	edx, DWORD PTR [esi+12]
	push	ebx
	push	edx
	mov	ecx, DWORD PTR [eax+92]
	lea	edx, DWORD PTR _iFree$16488[ebp]
	push	ecx
	push	eax
	push	edx
	push	edi
	call	?GAddCorona@@YAXPAUFCoronaLight@@AAHPAVUViewport@@PAVAPawn@@PAVAActor@@M@Z ; GAddCorona
	mov	esi, DWORD PTR [esi+16]
	add	esp, 24					; 00000018H
	jmp	SHORT $L16496
$L16498:

; 2029 : 		for( i=0; i<MAX_CORONA_LIGHTS; i++ )

	xor	eax, eax
	mov	DWORD PTR _i$16483[ebp], eax
$L16499:
	cmp	eax, 32					; 00000020H
	jge	$L16501

; 2030 : 		{
; 2031 : 			AActor* Light = CoronaLights[i]._Actor;

	lea	eax, DWORD PTR [eax+eax*2]
	mov	esi, DWORD PTR [edi+eax*4]
	lea	ebx, DWORD PTR [edi+eax*4]

; 2032 : 			if( Light && CoronaLights[i].iActor<=Viewport->Actor->XLevel->Num() && Viewport->Actor->XLevel->Actors(CoronaLights[i].iActor)==Light )

	test	esi, esi
	je	$L16500
	mov	ecx, DWORD PTR _Viewport$16357[ebp]
	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ecx+92]
	mov	ecx, DWORD PTR [edx+96]
	cmp	eax, DWORD PTR [ecx+92]
	jg	$L16500
	mov	ecx, DWORD PTR [ecx+88]
	cmp	DWORD PTR [ecx+eax*4], esi
	jne	$L16500

; 2033 : 			{
; 2034 : 				check(Light->IsValid());

	mov	ecx, esi
	call	DWORD PTR __imp_?IsValid@UObject@@QAEHXZ
	test	eax, eax
	jne	SHORT $L16504
	push	2034					; 000007f2H
	push	OFFSET FLAT:$SG16505
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L16504:

; 2035 : 				FVector Loc = Light->Location.TransformPointBy( Frame->Coords );

	mov	eax, DWORD PTR _Frame$[ebp]
	push	ecx
	fld	DWORD PTR [esi+212]
	fsub	DWORD PTR [eax+60]
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [esi+208]
	fsub	DWORD PTR [eax+56]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR [esi+204]
	fsub	DWORD PTR [eax+52]
	push	ecx
	lea	ecx, DWORD PTR _Temp$21899[ebp]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z
	mov	eax, DWORD PTR _Frame$[ebp]
	push	ecx
	fld	DWORD PTR _Temp$21899[ebp]
	fmul	DWORD PTR [eax+88]
	fld	DWORD PTR [eax+92]
	fmul	DWORD PTR _Temp$21899[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+96]
	fmul	DWORD PTR _Temp$21899[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR [esp]
	fld	DWORD PTR _Temp$21899[ebp]
	fmul	DWORD PTR [eax+76]
	fld	DWORD PTR [eax+80]
	fmul	DWORD PTR _Temp$21899[ebp+4]
	push	ecx
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+84]
	fmul	DWORD PTR _Temp$21899[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR [esp]
	fld	DWORD PTR _Temp$21899[ebp]
	fmul	DWORD PTR [eax+64]
	fld	DWORD PTR [eax+68]
	fmul	DWORD PTR _Temp$21899[ebp+4]
	push	ecx
	lea	ecx, DWORD PTR _Loc$16506[ebp]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+72]
	fmul	DWORD PTR _Temp$21899[ebp+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp_??0FVector@@QAE@MMM@Z

; 2036 : 				if( Loc.Z > 1.0 )

	fld	DWORD PTR _Loc$16506[ebp+8]
	fcomp	QWORD PTR $T19299
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L16500

; 2037 : 				{
; 2038 : 					BYTE    H     = Light->LightHue;

	mov	al, BYTE PTR [esi+363]

; 2039 : 					FVector Hue   = (H<86) ? FVector((85-H)/85.f,(H-0)/85.f,0) : (H<171) ? FVector(0,(170-H)/85.f,(H-85)/85.f) : FVector((H-170)/85.f,0,(255-H)/84.f);

	cmp	al, 86					; 00000056H
	mov	BYTE PTR _H$16509[ebp], al
	jae	SHORT $L21414
	mov	eax, DWORD PTR _H$16509[ebp]
	mov	edx, 85					; 00000055H
	and	eax, 255				; 000000ffH
	mov	DWORD PTR $T21408[ebp+8], 0
	sub	edx, eax
	mov	DWORD PTR -64+[ebp], eax
	mov	DWORD PTR -28+[ebp], edx
	lea	eax, DWORD PTR $T21408[ebp]
	fild	DWORD PTR -28+[ebp]
	fmul	DWORD PTR $T21966
	fstp	DWORD PTR $T21408[ebp]
	fild	DWORD PTR -64+[ebp]
	fmul	DWORD PTR $T21966
	fstp	DWORD PTR $T21408[ebp+4]
	jmp	$L21413
$L21414:
	cmp	al, 171					; 000000abH
	jae	SHORT $L21412
	mov	eax, DWORD PTR _H$16509[ebp]
	mov	ecx, 170				; 000000aaH
	and	eax, 255				; 000000ffH
	mov	DWORD PTR $T21410[ebp], 0
	sub	ecx, eax
	add	eax, -85				; ffffffabH
	mov	DWORD PTR -28+[ebp], ecx
	fild	DWORD PTR -28+[ebp]
	mov	DWORD PTR -28+[ebp], eax
	lea	eax, DWORD PTR $T21410[ebp]
	fmul	DWORD PTR $T21966
	fstp	DWORD PTR $T21410[ebp+4]
	fild	DWORD PTR -28+[ebp]
	fmul	DWORD PTR $T21966
	fstp	DWORD PTR $T21410[ebp+8]
	jmp	SHORT $L21413
$L21412:
	mov	eax, DWORD PTR _H$16509[ebp]
	mov	ecx, 255				; 000000ffH
	and	eax, 255				; 000000ffH
	mov	DWORD PTR $T21411[ebp+4], 0
	sub	ecx, eax
	lea	edx, DWORD PTR [eax-170]
	lea	eax, DWORD PTR $T21411[ebp]
	mov	DWORD PTR -28+[ebp], edx
	fild	DWORD PTR -28+[ebp]
	mov	DWORD PTR -28+[ebp], ecx
	fmul	DWORD PTR $T21966
	fstp	DWORD PTR $T21411[ebp]
	fild	DWORD PTR -28+[ebp]
	fmul	DWORD PTR $T21967
	fstp	DWORD PTR $T21411[ebp+8]
$L21413:
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _Hue$16510[ebp], edx
	mov	edx, DWORD PTR [eax+8]

; 2040 : 					FLOAT	Alpha = Light->LightSaturation / 255.0;

	xor	eax, eax
	mov	DWORD PTR _Hue$16510[ebp+4], ecx
	mov	al, BYTE PTR [esi+364]
	mov	DWORD PTR _Hue$16510[ebp+8], edx
	mov	DWORD PTR -28+[ebp], eax

; 2041 : 					FVector Color = (Hue + Alpha * (FVector(1,1,1) - Hue));
; 2042 : 					FLOAT   RZ    = Frame->Proj.Z / Loc.Z;

	mov	eax, DWORD PTR _Frame$[ebp]
	fild	DWORD PTR -28+[ebp]

; 2043 : 					FLOAT   X     = Loc.X * RZ + Frame->FX2;
; 2044 : 					FLOAT   Y     = Loc.Y * RZ + Frame->FY2;
; 2045 : 					FLOAT   Scale = 512.f * Light->DrawScale * Frame->X/640;
; 2046 : 					/*for( int j=0; j<5; j++ )
; 2047 : 					{
; 2048 : 						FLOAT A  = (j-2)/1.3;
; 2049 : 						FLOAT XX = X + (Viewport->FX2-X)*A;
; 2050 : 						FLOAT YY = Y + (Viewport->FY2-Y)*A;
; 2051 : 						FLOAT Sc = Scale * (1.0-Abs(j-2)/2.2);
; 2052 : 						GRend->DrawIcon( Viewport, Light->Region.Zone->LensFlares[Abs(j-2)], XX-Sc/2, YY-Sc/2, Sc, Sc, NULL, 1.0, GCoronaLights[i].Bright * Color );
; 2053 : 					}*/
; 2054 : 					Viewport->Canvas->DrawIcon( Light->Skin, X-Scale/2, Y-Scale/2, Scale, Scale, NULL, 1.0, CoronaLights[i].Bright * Color, FPlane(0,0,0,0), PF_TwoSided | PF_Translucent );

	push	260					; 00000104H
	mov	DWORD PTR $T21419[ebp], 0
	mov	edx, DWORD PTR $T21419[ebp]
	sub	esp, 16					; 00000010H
	fmul	QWORD PTR $T21968
	fld	DWORD PTR $T19072
	fsub	DWORD PTR _Hue$16510[ebp]
	fld	DWORD PTR $T19072
	fsub	DWORD PTR _Hue$16510[ebp+4]
	mov	ecx, esp
	mov	DWORD PTR $T21419[ebp+4], 0
	mov	DWORD PTR $T21419[ebp+8], 0
	mov	DWORD PTR $T21419[ebp+12], 0
	fstp	DWORD PTR $T21417[ebp+4]
	fld	DWORD PTR $T19072
	fsub	DWORD PTR _Hue$16510[ebp+8]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR $T21419[ebp+8]
	fstp	DWORD PTR $T21417[ebp+8]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T21418[ebp]
	fld	DWORD PTR $T21417[ebp+4]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR $T21418[ebp+4]
	fmul	DWORD PTR $T21417[ebp+8]
	fld	DWORD PTR $T21418[ebp]
	fadd	DWORD PTR _Hue$16510[ebp]
	fstp	DWORD PTR _Color$16517[ebp]
	fld	DWORD PTR $T21418[ebp+4]
	fadd	DWORD PTR _Hue$16510[ebp+4]
	fstp	DWORD PTR _Color$16517[ebp+4]
	fadd	DWORD PTR _Hue$16510[ebp+8]
	fstp	DWORD PTR _Color$16517[ebp+8]
	fld	DWORD PTR [eax+240]
	fdiv	DWORD PTR _Loc$16506[ebp+8]
	fld	ST(0)
	fmul	DWORD PTR _Loc$16506[ebp]
	fadd	DWORD PTR [eax+216]
	fstp	DWORD PTR _X$16523[ebp]
	fmul	DWORD PTR _Loc$16506[ebp+4]
	fadd	DWORD PTR [eax+220]
	fstp	DWORD PTR _Y$16524[ebp]
	fild	DWORD PTR [eax+176]
	mov	eax, DWORD PTR $T21419[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR $T21419[ebp+12]
	fmul	DWORD PTR [esi+308]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [ebx+8]
	fmul	DWORD PTR $T21969
	mov	DWORD PTR [ecx+12], eax
	lea	ecx, DWORD PTR _Color$16517[ebp]
	push	ecx
	lea	eax, DWORD PTR $T21421[ebp]
	push	edx
	push	eax
	fstp	DWORD PTR _Scale$16525[ebp]
	call	??D@YA?AVFVector@@MABV0@@Z		; operator*
	add	esp, -4					; fffffffcH
	mov	ecx, esp
	mov	DWORD PTR $T21420[ebp], esp
	push	eax
	call	DWORD PTR __imp_??0FPlane@@QAE@ABVFVector@@@Z
	fld	DWORD PTR _Scale$16525[ebp]
	fmul	DWORD PTR $T21970
	mov	ecx, DWORD PTR _Viewport$16357[ebp]
	mov	eax, DWORD PTR _Scale$16525[ebp]
	fld	DWORD PTR _Y$16524[ebp]
	mov	ecx, DWORD PTR [ecx+104]
	push	1065353216				; 3f800000H
	push	0
	push	eax
	fsub	ST(0), ST(1)
	push	eax
	push	ecx
	mov	eax, DWORD PTR [esi+296]
	mov	edx, DWORD PTR [ecx]
	fstp	DWORD PTR [esp]
	fld	DWORD PTR _X$16523[ebp]
	fsub	ST(0), ST(1)
	push	ecx
	fstp	DWORD PTR [esp]
	push	eax
	fstp	ST(0)
	call	DWORD PTR [edx+128]
$L16500:
	mov	eax, DWORD PTR _i$16483[ebp]
	inc	eax
	mov	DWORD PTR _i$16483[ebp], eax
	jmp	$L16499
$L16501:

; 2055 : 				}
; 2056 : 			}
; 2057 : 		}
; 2058 : 		Item->Unlock();

	mov	eax, DWORD PTR _Item$16465[ebp]
	mov	edi, DWORD PTR _Frame$[ebp]
	add	DWORD PTR [eax+16], -16777216		; ff000000H
$L21927:

; 2059 : 	}
; 2060 : 
; 2061 : 	// Finish up.
; 2062 : 	STAT(GStat.GMem += GMem.GetByteCount());

	mov	ecx, DWORD PTR __imp_?GMem@@3VFMemStack@@A
	mov	esi, DWORD PTR __imp_?GetByteCount@FMemStack@@QAEHXZ
	call	esi
	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+184
	add	ecx, eax
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+184, ecx

; 2063 : 	STAT(GStat.GDynMem += GDynMem.GetByteCount());

	mov	ecx, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	call	esi
	mov	ecx, DWORD PTR ?GStat@@3UFRenderStats@@A+188
	add	ecx, eax
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+188, ecx

; 2064 : 	STAT(GStat.NodesTotal += Frame->Level->Model->Nodes->Num());

	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [ecx+192]
	mov	eax, DWORD PTR [edx+140]
	mov	ecx, DWORD PTR [eax+92]
	mov	eax, DWORD PTR ?GStat@@3UFRenderStats@@A+84
	add	eax, ecx
	mov	DWORD PTR ?GStat@@3UFRenderStats@@A+84, eax

; 2066 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L21424:

; 2065 : 	unguard;

	mov	edx, DWORD PTR _Err$16529[ebp]
	lea	eax, DWORD PTR $T21422[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	eax
	mov	DWORD PTR $T21422[ebp], edx
	call	__CxxThrowException@8
	mov	eax, $L16356
	ret	0
$L21425:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??DrawFrame@URender@@QAEXPAUFSceneNode@@@Z@4PBDB$S16355
	push	OFFSET FLAT:$SG16531
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L16356
	ret	0
$L16356:

; 2066 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
$L21980:
	mov	eax, OFFSET FLAT:$T21934
	jmp	___CxxFrameHandler
text$x	ENDS
?DrawFrame@URender@@QAEXPAUFSceneNode@@@Z ENDP		; URender::DrawFrame
;	COMDAT ??D@YA?AVFVector@@MABV0@@Z
_TEXT	SEGMENT
_Scale$ = 12
_V$ = 16
___$ReturnUdt$ = 8
??D@YA?AVFVector@@MABV0@@Z PROC NEAR			; operator*, COMDAT

; 222  : 		return FVector( V.X * Scale, V.Y * Scale, V.Z * Scale );

	mov	eax, DWORD PTR _V$[esp-4]
	fld	DWORD PTR [eax]
	fld	DWORD PTR [eax+4]
	fld	DWORD PTR [eax+8]
	fxch	ST(2)
	fmul	DWORD PTR _Scale$[esp-4]
	fxch	ST(1)
	fmul	DWORD PTR _Scale$[esp-4]
	fxch	ST(2)
	fmul	DWORD PTR _Scale$[esp-4]
	fxch	ST(1)
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	fstp	DWORD PTR [eax]
	fxch	ST(1)
	fstp	DWORD PTR [eax+4]
	fstp	DWORD PTR [eax+8]

; 223  : 	}

	ret	0
??D@YA?AVFVector@@MABV0@@Z ENDP				; operator*
_TEXT	ENDS
EXTRN	__imp_?SingleLineCheck@ULevel@@QAEHAAUFCheckResult@@PAVAActor@@ABVFVector@@2KV4@E@Z:NEAR
EXTRN	__imp_?GetActorIndex@ULevel@@QAEHPAVAActor@@@Z:NEAR
CONST	SEGMENT
$T22019	DD	0c0000000r			; -2
$T22020	DD	040000000r			; 2
CONST	ENDS
_TEXT	SEGMENT
$T21990 = -56
_CoronaLights$ = 8
_iFree$ = 12
_Viewport$ = 16
_Actor$ = 20
_Light$ = 24
_Delta$ = 28
_Hit$ = -44
?GAddCorona@@YAXPAUFCoronaLight@@AAHPAVUViewport@@PAVAPawn@@PAVAActor@@M@Z PROC NEAR ; GAddCorona

; 1720 : {

	sub	esp, 56					; 00000038H
	push	esi
	push	edi

; 1721 : 	FCheckResult Hit;
; 1722 : 	if
; 1723 : 	(	Light->bCorona
; 1724 : 	&&	Light->Skin
; 1725 : 	&& !Light->bDeleteMe
; 1726 : 	&&  Viewport->Actor->XLevel->SingleLineCheck( Hit, Actor, Light->Location, Actor->Location, TRACE_VisBlocking, FVector(0,0,0) ) )

	mov	edi, DWORD PTR _Light$[esp+60]
	test	BYTE PTR [edi+372], 4
	je	$L16293
	mov	eax, DWORD PTR [edi+296]
	test	eax, eax
	je	$L16293
	mov	eax, DWORD PTR [edi+200]
	test	ah, 16					; 00000010H
	jne	$L16293
	push	0
	mov	DWORD PTR $T21990[esp+68], 0
	mov	ecx, DWORD PTR $T21990[esp+68]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T21990[esp+84], 0
	mov	edx, DWORD PTR $T21990[esp+84]
	mov	DWORD PTR $T21990[esp+88], 0
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR $T21990[esp+88]
	push	6
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	mov	eax, DWORD PTR _Actor$[esp+80]
	lea	ecx, DWORD PTR [edi+204]
	lea	edx, DWORD PTR [eax+204]
	push	edx
	push	ecx
	push	eax
	mov	eax, DWORD PTR _Viewport$[esp+92]
	lea	edx, DWORD PTR _Hit$[esp+96]
	mov	ecx, DWORD PTR [eax+92]
	push	edx
	mov	ecx, DWORD PTR [ecx+96]
	call	DWORD PTR __imp_?SingleLineCheck@ULevel@@QAEHAAUFCheckResult@@PAVAActor@@ABVFVector@@2KV4@E@Z
	test	eax, eax
	je	$L16293

; 1727 : 	{
; 1728 : 		for( int i=0; i<MAX_CORONA_LIGHTS; i++ )

	mov	edx, DWORD PTR _CoronaLights$[esp+60]
	xor	eax, eax
	mov	ecx, edx
$L16281:

; 1729 : 			if( CoronaLights[i]._Actor == Light )

	cmp	DWORD PTR [ecx], edi
	je	SHORT $L22016
	inc	eax
	add	ecx, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jl	SHORT $L16281
$L22016:

; 1730 : 				break;
; 1731 : 		if( i<MAX_CORONA_LIGHTS )

	cmp	eax, 32					; 00000020H
	jge	SHORT $L22015

; 1732 : 		{
; 1733 : 			CoronaLights[i].Bright = Min(1.f,CoronaLights[i].Bright+2.f*Delta);

	fld	DWORD PTR _Delta$[esp+60]
	fmul	DWORD PTR $T22019
	lea	eax, DWORD PTR [eax+eax*2]
	fsubr	DWORD PTR [edx+eax*4+8]
	fld	DWORD PTR $T19072
	lea	ecx, DWORD PTR [edx+eax*4+8]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L22004
	fstp	ST(0)
	fld	DWORD PTR $T19072
$L22004:
	fstp	DWORD PTR [ecx]

; 1744 : 			}
; 1745 : 		}
; 1746 : 	}
; 1747 : }

	pop	edi
	pop	esi
	add	esp, 56					; 00000038H
	ret	0
$L22015:

; 1734 : 		}
; 1735 : 		else
; 1736 : 		{
; 1737 : 			while( iFree<MAX_CORONA_LIGHTS && CoronaLights[iFree]._Actor )

	mov	ecx, DWORD PTR _iFree$[esp+60]
	cmp	DWORD PTR [ecx], 32			; 00000020H
	jge	SHORT $L16292
$L16291:
	mov	eax, DWORD PTR [ecx]
	lea	esi, DWORD PTR [eax+eax*2]
	cmp	DWORD PTR [edx+esi*4], 0
	je	SHORT $L16292

; 1738 : 				iFree++;

	inc	eax
	cmp	eax, 32					; 00000020H
	mov	DWORD PTR [ecx], eax
	jl	SHORT $L16291
$L16292:

; 1739 : 			if( iFree<MAX_CORONA_LIGHTS )

	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, 32					; 00000020H
	jge	SHORT $L16293

; 1740 : 			{
; 1741 : 				CoronaLights[iFree]._Actor = Light;

	lea	ecx, DWORD PTR [ecx+ecx*2]

; 1742 : 				CoronaLights[iFree].iActor = Light->XLevel->GetActorIndex(Light);

	push	edi
	lea	esi, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [edi+96]
	mov	DWORD PTR [esi], edi
	call	DWORD PTR __imp_?GetActorIndex@ULevel@@QAEHPAVAActor@@@Z

; 1743 : 				CoronaLights[iFree].Bright = Min(1.f,2.f*Delta);

	fld	DWORD PTR _Delta$[esp+60]
	fadd	ST(0), ST(0)
	fld	DWORD PTR $T19072
	mov	DWORD PTR [esi+4], eax
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L22010
	fstp	ST(0)
	fld	DWORD PTR $T19072
$L22010:
	fstp	DWORD PTR [esi+8]
$L16293:

; 1744 : 			}
; 1745 : 		}
; 1746 : 	}
; 1747 : }

	pop	edi
	pop	esi
	add	esp, 56					; 00000038H
	ret	0
?GAddCorona@@YAXPAUFCoronaLight@@AAHPAVUViewport@@PAVAPawn@@PAVAActor@@M@Z ENDP ; GAddCorona
_TEXT	ENDS
EXTRN	__imp_?GIsEditor@@3HA:DWORD
EXTRN	__imp_?ENGINE_InvCalcView@@3VFName@@A:DWORD
EXTRN	__imp_?SetActorZone@ULevel@@QAEXPAVAActor@@HH@Z:NEAR
xdata$x	SEGMENT
$T22063	DD	019930520H
	DD	02H
	DD	FLAT:$T22077
	DD	01H
	DD	FLAT:$T22078
	DD	2 DUP(00H)
	ORG $+4
$T22077	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T22078	DD	00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:$T22079
	ORG $+4
$T22079	DD	00H
	DD	FLAT:??_R0PAD@8
	DD	0ffffffe0H
	DD	FLAT:$L22023
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L22024
xdata$x	ENDS
_TEXT	SEGMENT
_Frame$ = 8
_this$ = -20
_SceneMark$16544 = -80
_MemMark$16545 = -48
_DynMark$16546 = -64
_VectorMark$16547 = -96
_Viewport$16548 = -28
_Err$16550 = -32
$T22021 = 8
__$EHRec$ = -16
?DrawWorld@URender@@UAEXPAUFSceneNode@@@Z PROC NEAR	; URender::DrawWorld

; 2072 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	$L22076
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 80					; 00000050H
	push	ebx

; 2073 : 	guard(URender::DrawWorld);
; 2074 : 	FMemMark SceneMark(GSceneMem);

	push	esi

; 2075 : 	FMemMark MemMark(GMem);

	push	edi

; 2078 : 
; 2079 : 	// Occlude and render all scene frames.
; 2080 : 	OccludeFrame( Frame );

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2073 : 	guard(URender::DrawWorld);
; 2074 : 	FMemMark SceneMark(GSceneMem);

	mov	ebx, DWORD PTR __imp_?GSceneMem@@3VFMemStack@@A

; 2075 : 	FMemMark MemMark(GMem);

	mov	esi, DWORD PTR __imp_?GMem@@3VFMemStack@@A
	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR _SceneMark$16544[ebp+4], eax
	mov	eax, DWORD PTR [ebx+20]

; 2076 : 	FMemMark DynMark(GDynMem);

	mov	edi, DWORD PTR __imp_?GDynMem@@3VFMemStack@@A
	mov	DWORD PTR _SceneMark$16544[ebp+12], eax
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _SceneMark$16544[ebp+8], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _MemMark$16545[ebp+8], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _MemMark$16545[ebp+4], edx
	mov	edx, DWORD PTR [esi+20]
	mov	DWORD PTR _DynMark$16546[ebp+4], eax
	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _MemMark$16545[ebp+12], edx
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR _DynMark$16546[ebp+12], eax

; 2077 : 	FMemMark VectorMark( VectorMem );

	mov	eax, DWORD PTR ?VectorMem@URender@@2VFMemStack@@A+8
	mov	DWORD PTR _DynMark$16546[ebp+8], edx
	mov	edx, DWORD PTR ?VectorMem@URender@@2VFMemStack@@A+4
	mov	DWORD PTR _VectorMark$16547[ebp+8], eax

; 2078 : 
; 2079 : 	// Occlude and render all scene frames.
; 2080 : 	OccludeFrame( Frame );

	mov	eax, DWORD PTR _Frame$[ebp]
	mov	DWORD PTR _VectorMark$16547[ebp+4], edx
	mov	edx, DWORD PTR ?VectorMem@URender@@2VFMemStack@@A+20
	push	eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR _VectorMark$16547[ebp+12], edx
	call	?OccludeFrame@URender@@QAEXPAUFSceneNode@@@Z ; URender::OccludeFrame

; 2081 : 	DrawFrame( Frame );

	mov	ecx, DWORD PTR _Frame$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawFrame@URender@@QAEXPAUFSceneNode@@@Z ; URender::DrawFrame

; 2082 : 
; 2083 : 	// Draw the player's weapon on top.
; 2084 : 	UViewport* Viewport = Frame->Viewport;

	mov	edx, DWORD PTR _Frame$[ebp]

; 2085 : 	if( !GIsEditor && Viewport->Actor->Weapon && !Viewport->Actor->bBehindView && (Viewport->Actor->ShowFlags & SHOW_Actors) )

	mov	ecx, DWORD PTR __imp_?GIsEditor@@3HA
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	mov	DWORD PTR _Viewport$16548[ebp], eax
	jne	$L16549
	mov	eax, DWORD PTR [eax+92]
	mov	DWORD PTR -24+[ebp], eax
	mov	ecx, DWORD PTR [eax+544]
	test	ecx, ecx
	mov	DWORD PTR -20+[ebp], ecx
	je	SHORT $L16549
	test	BYTE PTR [eax+668], 1
	jne	SHORT $L16549
	test	BYTE PTR [eax+1036], 8
	je	SHORT $L16549

; 2086 : 	{
; 2087 : 		Viewport->Actor->Weapon->InvCalcView();

	mov	eax, DWORD PTR __imp_?ENGINE_InvCalcView@@3VFName@@A
	mov	edx, DWORD PTR [ecx]
	push	0
	mov	eax, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [edx+16]

; 2088 : 		Viewport->Actor->Weapon->bHidden = 0;

	mov	eax, DWORD PTR -20+[ebp]

; 2089 : 		Viewport->Actor->XLevel->SetActorZone( Viewport->Actor->Weapon, 1, 0 );

	mov	ecx, DWORD PTR -24+[ebp]
	push	0
	push	1
	mov	edx, DWORD PTR [eax+200]
	mov	ecx, DWORD PTR [ecx+96]
	and	edx, -3					; fffffffdH
	push	eax
	mov	DWORD PTR [eax+200], edx
	call	DWORD PTR __imp_?SetActorZone@ULevel@@QAEXPAVAActor@@HH@Z

; 2090 : 		GRender->DrawActor( Frame, Viewport->Actor->Weapon );

	mov	eax, DWORD PTR -20+[ebp]
	mov	ecx, DWORD PTR ?GRender@@3PAVURender@@A	; GRender
	push	eax
	mov	eax, DWORD PTR _Frame$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [edx+128]

; 2091 : 		Viewport->Actor->Weapon->bHidden = 1;

	mov	ecx, DWORD PTR _Viewport$16548[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR [edx+544]
	or	DWORD PTR [eax+200], 2
$L16549:

; 2092 : 	}
; 2093 : 
; 2094 : 	MemMark.Pop();

	mov	ecx, DWORD PTR _MemMark$16545[ebp+12]
	mov	eax, DWORD PTR [esi+20]
	cmp	ecx, eax
	jle	SHORT $L22068
	push	155					; 0000009bH
	push	OFFSET FLAT:??_C@_0FH@FKFD@Check?5failed?3?5ActiveChunks?$DM?$DNMem?9@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	mov	ecx, DWORD PTR _MemMark$16545[ebp+12]
	add	esp, 8
$L22068:
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, ecx
	jle	SHORT $L22040
	dec	eax
	mov	DWORD PTR [esi+20], eax
	mov	eax, DWORD PTR [esi+eax*4+28]
	add	DWORD PTR [eax+16], -16777216		; ff000000H
	jmp	SHORT $L22068
$L22040:
	mov	eax, DWORD PTR _MemMark$16545[ebp+4]
	mov	ecx, DWORD PTR _MemMark$16545[ebp+8]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ecx

; 2095 : 	DynMark.Pop();

	mov	esi, DWORD PTR _DynMark$16546[ebp+12]
	mov	eax, DWORD PTR [edi+20]
	cmp	esi, eax
	jle	SHORT $L22069
	push	155					; 0000009bH
	push	OFFSET FLAT:??_C@_0FH@FKFD@Check?5failed?3?5ActiveChunks?$DM?$DNMem?9@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L22069:
	mov	eax, DWORD PTR [edi+20]
	cmp	eax, esi
	jle	SHORT $L22047
	dec	eax
	mov	DWORD PTR [edi+20], eax
	mov	eax, DWORD PTR [edi+eax*4+28]
	add	DWORD PTR [eax+16], -16777216		; ff000000H
	jmp	SHORT $L22069
$L22047:
	mov	edx, DWORD PTR _DynMark$16546[ebp+4]
	mov	eax, DWORD PTR _DynMark$16546[ebp+8]
	mov	DWORD PTR [edi+4], edx
	mov	DWORD PTR [edi+8], eax

; 2096 : 	SceneMark.Pop();

	mov	edi, DWORD PTR _SceneMark$16544[ebp+12]
	mov	eax, DWORD PTR [ebx+20]
	cmp	edi, eax
	jle	SHORT $L22070
	push	155					; 0000009bH
	push	OFFSET FLAT:??_C@_0FH@FKFD@Check?5failed?3?5ActiveChunks?$DM?$DNMem?9@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L22070:
	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, edi
	jle	SHORT $L22054
	dec	eax
	mov	DWORD PTR [ebx+20], eax
	mov	eax, DWORD PTR [ebx+eax*4+28]
	add	DWORD PTR [eax+16], -16777216		; ff000000H
	jmp	SHORT $L22070
$L22054:
	mov	ecx, DWORD PTR _SceneMark$16544[ebp+4]
	mov	edx, DWORD PTR _SceneMark$16544[ebp+8]

; 2097 : 	VectorMark.Pop();

	mov	edi, OFFSET FLAT:?VectorMem@URender@@2VFMemStack@@A ; URender::VectorMem
	mov	DWORD PTR [ebx+4], ecx
	mov	DWORD PTR [ebx+8], edx
	mov	ebx, DWORD PTR _VectorMark$16547[ebp+12]
	cmp	ebx, DWORD PTR [edi+20]
	jle	SHORT $L22071
	push	155					; 0000009bH
	push	OFFSET FLAT:??_C@_0FH@FKFD@Check?5failed?3?5ActiveChunks?$DM?$DNMem?9@ ; `string'
	call	DWORD PTR __imp_?appErrorf@@YAXPBDZZ
	add	esp, 8
$L22071:
	mov	eax, DWORD PTR [edi+20]
	cmp	eax, ebx
	jle	SHORT $L22061
	dec	eax
	mov	DWORD PTR [edi+20], eax
	mov	eax, DWORD PTR [edi+eax*4+28]
	add	DWORD PTR [eax+16], -16777216		; ff000000H
	jmp	SHORT $L22071
$L22061:
	mov	eax, DWORD PTR _VectorMark$16547[ebp+4]
	mov	ecx, DWORD PTR _VectorMark$16547[ebp+8]
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], ecx

; 2099 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L22023:

; 2098 : 	unguard;

	mov	edx, DWORD PTR _Err$16550[ebp]
	lea	eax, DWORD PTR $T22021[ebp]
	push	OFFSET FLAT:__TI2PAD
	push	eax
	mov	DWORD PTR $T22021[ebp], edx
	call	__CxxThrowException@8
	mov	eax, $L16543
	ret	0
$L22024:
	push	OFFSET FLAT:_?__FUNC_NAME__@?2??DrawWorld@URender@@UAEXPAUFSceneNode@@@Z@4PBDB$S16542
	push	OFFSET FLAT:$SG16552
	call	DWORD PTR __imp_?appUnwindf@@YAXPBDZZ
	add	esp, 8
	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $L16543
	ret	0
$L16543:

; 2099 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
$L22076:
	mov	eax, OFFSET FLAT:$T22063
	jmp	___CxxFrameHandler
text$x	ENDS
?DrawWorld@URender@@UAEXPAUFSceneNode@@@Z ENDP		; URender::DrawWorld
EXTRN	__imp_?Realloc@FArray@@IAEXH@Z:NEAR
;	COMDAT ?Add@?$TArray@H@@QAEHH@Z
_TEXT	SEGMENT
_n$ = 8
?Add@?$TArray@H@@QAEHH@Z PROC NEAR			; TArray<int>::Add, COMDAT

; 188  : 		guardSlow(TArray::Add);
; 189  : 		checkarray(n>=0);
; 190  : 		checkarray(ArrayNum>=0);
; 191  : 		checkarray(ArrayMax>=ArrayNum);
; 192  : 		INT Index=ArrayNum;
; 193  : 		if( (ArrayNum+=n)>ArrayMax )

	mov	eax, DWORD PTR _n$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	lea	esi, DWORD PTR [eax+edi]
	mov	eax, DWORD PTR [ecx+8]
	cmp	esi, eax
	mov	DWORD PTR [ecx+4], esi
	jle	SHORT $L16821

; 194  : 		{
; 195  : 			ArrayMax = ArrayNum + ArrayNum/4 + 32;

	mov	eax, esi

; 196  : 			Realloc( sizeof(T) );

	push	4
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	lea	edx, DWORD PTR [eax+esi+32]
	mov	DWORD PTR [ecx+8], edx
	call	DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L16821:

; 197  : 		}
; 198  : 		return Index;

	mov	eax, edi

; 199  : 		unguardSlow;
; 200  : 	}

	pop	edi
	pop	esi
	ret	4
?Add@?$TArray@H@@QAEHH@Z ENDP				; TArray<int>::Add
_TEXT	ENDS
;	COMDAT ?Clamp@@YAHHHH@Z
_TEXT	SEGMENT
_X$ = 8
_Min$ = 12
_Max$ = 16
?Clamp@@YAHHHH@Z PROC NEAR				; Clamp, COMDAT

; 35   : 	return X<Min ? Min : X<Max ? X : Max;

	mov	ecx, DWORD PTR _X$[esp-4]
	mov	eax, DWORD PTR _Min$[esp-4]
	cmp	ecx, eax
	jl	SHORT $L22081
	mov	eax, DWORD PTR _Max$[esp-4]
	cmp	ecx, eax
	jge	SHORT $L22081
	mov	eax, ecx
$L22081:

; 36   : }

	ret	0
?Clamp@@YAHHHH@Z ENDP					; Clamp
_TEXT	ENDS
;	COMDAT ?appSort@@YAXPAUFBspDrawListPtr@@HH@Z
_TEXT	SEGMENT
_Array$ = 8
_Num$ = 12
_SortCutoff$ = 16
_FirstStack$17359 = -128
_LastStack$17360 = -256
_StackIndex$17361 = -264
?appSort@@YAXPAUFBspDrawListPtr@@HH@Z PROC NEAR		; appSort, COMDAT

; 385  : 	guard(appSort);
; 386  :     if( Num < 2 )

	mov	eax, DWORD PTR _Num$[esp-4]
	sub	esp, 268				; 0000010cH
	cmp	eax, 2
	push	ebx
	push	ebp
	push	esi
	push	edi
	jl	$L17411

; 387  :         return;
; 388  : 
; 389  : 	// Simulated stack.
; 390  : 	T* FirstStack[32];
; 391  : 	T* LastStack[32];
; 392  :     INT StackIndex = 0;
; 393  : 
; 394  : 	// Pointers to first and last.
; 395  :     T* First = Array;

	mov	ecx, DWORD PTR _Array$[esp+280]
	lea	ebx, DWORD PTR _FirstStack$17359[esp+284]
	mov	DWORD PTR _StackIndex$17361[esp+284], 0
	mov	DWORD PTR -260+[esp+284], ebx

; 396  :     T* Last = Array + Num - 1;

	lea	esi, DWORD PTR [ecx+eax*4-4]
	lea	eax, DWORD PTR _LastStack$17360[esp+284]
	mov	DWORD PTR -268+[esp+284], eax
$Resort$17364:

; 397  : 
; 398  : Resort:
; 399  :     INT Size = Last - First + 1;
; 400  : 	if( Size <= SortCutoff )

	mov	edx, DWORD PTR _SortCutoff$[esp+280]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 2
	inc	eax
	cmp	eax, edx
	jg	SHORT $L17366

; 401  : 	{
; 402  : 		// Bubble-sort small arrays.
; 403  : 		T* NewLast = Last;
; 404  : 		while( NewLast > First )

	cmp	esi, ecx
	mov	edx, esi
	jbe	SHORT $L17410

; 405  : 		{
; 406  : 			T* Max = First;
; 407  : 			for( T* P=First+1; P<=NewLast; P++ )

	lea	edi, DWORD PTR [ecx+4]
$L17369:
	mov	eax, edi
	mov	esi, ecx
	cmp	eax, edx
	ja	SHORT $L17375
$L17373:

; 408  : 			{
; 409  : 				if( Compare(*P, *Max) > 0 )

	mov	ebp, DWORD PTR [eax]
	mov	ebx, DWORD PTR [esi]
	mov	ebp, DWORD PTR [ebp+12]
	sub	ebp, DWORD PTR [ebx+12]
	test	ebp, ebp
	jle	SHORT $L17374

; 410  : 					Max = P;

	mov	esi, eax
$L17374:

; 405  : 		{
; 406  : 			T* Max = First;
; 407  : 			for( T* P=First+1; P<=NewLast; P++ )

	add	eax, 4
	cmp	eax, edx
	jbe	SHORT $L17373
	mov	ebx, DWORD PTR -260+[esp+284]
$L17375:

; 411  : 			}
; 412  : 			Exchange( *Max, *NewLast );

	mov	ebp, DWORD PTR [edx]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [edx], eax

; 413  : 			NewLast--;

	sub	edx, 4
	cmp	edx, ecx
	ja	SHORT $L17369
$L17410:

; 461  :             }
; 462  :         }
; 463  :     }
; 464  :     if( --StackIndex >= 0 )

	mov	eax, DWORD PTR _StackIndex$17361[esp+284]
	mov	edx, DWORD PTR -268+[esp+284]
	dec	eax
	sub	ebx, 4
	sub	edx, 4
	mov	DWORD PTR _StackIndex$17361[esp+284], eax
	test	eax, eax
	mov	DWORD PTR -260+[esp+284], ebx
	mov	DWORD PTR -268+[esp+284], edx
	jl	SHORT $L17411

; 465  : 	{
; 466  : 		// Sort array on stack.
; 467  :         First = FirstStack[StackIndex];

	mov	ecx, DWORD PTR [ebx]

; 468  :         Last = LastStack[StackIndex];

	mov	eax, edx
	mov	esi, DWORD PTR [eax]

; 469  :         goto Resort;

	jmp	SHORT $Resort$17364
$L17411:

; 470  :     }
; 471  : 	unguard;
; 472  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 268				; 0000010cH
	ret	0
$L17366:

; 414  : 		}
; 415  : 	}
; 416  :     else
; 417  : 	{
; 418  :         T* Middle = First + (Size / 2);

	cdq

; 419  :         Exchange( *Middle, *First );

	mov	edi, DWORD PTR [ecx]
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR [ecx+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [ecx], edx

; 420  :         T* FirstPtr = First;

	mov	edx, ecx

; 421  :         T* LastPtr = Last + 1;

	lea	eax, DWORD PTR [esi+4]
$L17390:

; 422  :         for( ; ; )
; 423  : 		{
; 424  :             do FirstPtr++; while( FirstPtr <= Last && Compare(*FirstPtr, *First) <= 0 );

	add	edx, 4
	cmp	edx, esi
	ja	SHORT $L17394
	mov	ebp, DWORD PTR [edx]
	mov	edi, DWORD PTR [ecx]
	mov	ebp, DWORD PTR [ebp+12]
	sub	ebp, DWORD PTR [edi+12]
	test	ebp, ebp
	jle	SHORT $L17390
$L17394:

; 425  :             do LastPtr--; while( LastPtr > First && Compare(*LastPtr, *First) >= 0 );

	sub	eax, 4
	cmp	eax, ecx
	jbe	SHORT $L17397
	mov	ebp, DWORD PTR [eax]
	mov	edi, DWORD PTR [ecx]
	mov	ebp, DWORD PTR [ebp+12]
	sub	ebp, DWORD PTR [edi+12]
	jns	SHORT $L17394
$L17397:

; 426  :             if( LastPtr < FirstPtr )

	cmp	eax, edx
	jb	SHORT $L22110

; 427  :                 break;
; 428  :             Exchange( *FirstPtr, *LastPtr );

	mov	ebp, DWORD PTR [eax]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [edx], ebp
	mov	DWORD PTR [eax], edi

; 429  :         }

	jmp	SHORT $L17390
$L22110:

; 430  :         Exchange( *First, *LastPtr );

	mov	ebp, DWORD PTR [eax]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], ebp
	mov	DWORD PTR [eax], edi

; 431  :         if( LastPtr-1-First >= Last-FirstPtr )

	mov	edi, eax
	mov	ebp, esi
	sub	edi, ecx
	sub	ebp, edx
	sub	edi, 4
	and	ebp, -4					; fffffffcH
	and	edi, -4					; fffffffcH
	cmp	edi, ebp
	jl	SHORT $L17405

; 432  : 		{
; 433  :             if( First + 1 < LastPtr )

	lea	edi, DWORD PTR [ecx+4]
	cmp	edi, eax
	jae	SHORT $L17406

; 434  : 			{
; 435  : 				// Sort larger subset later.
; 436  :                 FirstStack[StackIndex] = First;
; 437  :                 LastStack[StackIndex] = LastPtr - 1;
; 438  :                 StackIndex++;

	mov	ebp, DWORD PTR _StackIndex$17361[esp+284]
	mov	DWORD PTR [ebx], ecx
	lea	ecx, DWORD PTR [eax-4]
	mov	eax, DWORD PTR -268+[esp+284]
	inc	ebp
	add	ebx, 4
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	mov	DWORD PTR _StackIndex$17361[esp+284], ebp
	mov	DWORD PTR -260+[esp+284], ebx
	mov	DWORD PTR -268+[esp+284], eax
$L17406:

; 439  :             }
; 440  :             if( FirstPtr < Last )

	cmp	edx, esi
	jae	$L17410

; 441  : 			{
; 442  : 				// Sort smaller subset now.
; 443  :                 First = FirstPtr;

	mov	ecx, edx

; 444  :                 goto Resort;

	jmp	$Resort$17364
$L17405:

; 445  :             }
; 446  :         }
; 447  :         else
; 448  : 		{
; 449  :             if( FirstPtr < Last )

	cmp	edx, esi
	jae	SHORT $L17409

; 450  : 			{
; 451  : 				// Sort larger subset later.
; 452  :                 FirstStack[StackIndex] = FirstPtr;
; 453  :                 LastStack[StackIndex] = Last;
; 454  :                 StackIndex++;

	mov	ebp, DWORD PTR _StackIndex$17361[esp+284]
	mov	DWORD PTR [ebx], edx
	mov	edx, DWORD PTR -268+[esp+284]
	inc	ebp
	add	ebx, 4
	mov	DWORD PTR _StackIndex$17361[esp+284], ebp
	mov	DWORD PTR [edx], esi
	add	edx, 4
	mov	DWORD PTR -260+[esp+284], ebx
	mov	DWORD PTR -268+[esp+284], edx
$L17409:

; 455  :             }
; 456  :             if( First + 1 < LastPtr )

	lea	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jae	$L17410

; 457  : 			{
; 458  : 				// Sort smaller subset now.
; 459  :                 Last = LastPtr - 1;

	lea	esi, DWORD PTR [eax-4]

; 460  :                 goto Resort;

	jmp	$Resort$17364
?appSort@@YAXPAUFBspDrawListPtr@@HH@Z ENDP		; appSort
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	mov	eax, DWORD PTR ___n$[esp-4]
	dec	eax
	js	SHORT $L10026
	push	edi
	push	esi
	mov	esi, DWORD PTR ___t$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR ___s$[esp+8]
	push	ebx
	mov	ebx, DWORD PTR ___f$[esp+12]
	lea	edi, DWORD PTR [eax+1]
$L10025:
	mov	ecx, esi
	call	ebx
	add	esi, ebp
	dec	edi
	jne	SHORT $L10025
	pop	ebx
	pop	ebp
	pop	esi
	pop	edi
$L10026:
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
;	COMDAT ?Project@FTransform@@QAEXPBUFSceneNode@@@Z
_TEXT	SEGMENT
_I$22123 = -4
$T22124 = 8
_Frame$ = 8
?Project@FTransform@@QAEXPBUFSceneNode@@@Z PROC NEAR	; FTransform::Project, COMDAT

; 109  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 110  : 		RZ      = 1.0 / Point.Z;

	fld	DWORD PTR [ecx+8]
	fdivr	QWORD PTR $T19299

; 111  : 		ScreenX = Point.X * Frame->Proj.Z * RZ + Frame->FX15;

	mov	eax, DWORD PTR _Frame$[ebp]
	fst	DWORD PTR [ecx+28]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR [eax+240]
	fmul	ST(0), ST(1)
	fadd	DWORD PTR [eax+200]
	fstp	DWORD PTR [ecx+16]

; 112  : 		ScreenY = Point.Y * Frame->Proj.Z * RZ + Frame->FY15;

	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR [eax+240]
	fmulp	ST(1), ST(0)
	fadd	DWORD PTR [eax+204]
	fst	DWORD PTR [ecx+20]

; 113  : 		IntY    = appFloor( ScreenY );

	fstp	DWORD PTR $T22124[ebp]

; 112  : 		ScreenY = Point.Y * Frame->Proj.Z * RZ + Frame->FY15;

	fld	DWORD PTR $T22124[ebp]

; 113  : 		IntY    = appFloor( ScreenY );

	fsub	DWORD PTR ?Half@?1??appFloor@@YAHM@Z@4MA ; Half

; 114  : 	}

	fistp	DWORD PTR _I$22123[ebp]

; 113  : 		IntY    = appFloor( ScreenY );

	mov	eax, DWORD PTR _I$22123[ebp]
	mov	DWORD PTR [ecx+24], eax

; 114  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Project@FTransform@@QAEXPBUFSceneNode@@@Z ENDP		; FTransform::Project
_TEXT	ENDS
;	COMDAT ?InternalConstructor@URender@@SAXPAX@Z
_TEXT	SEGMENT
_X$ = 8
?InternalConstructor@URender@@SAXPAX@Z PROC NEAR	; URender::InternalConstructor, COMDAT

; 418  : 	DECLARE_CLASS(URender,URenderBase)

	mov	ecx, DWORD PTR _X$[esp-4]
	test	ecx, ecx
	je	SHORT $L22127
	jmp	??0URender@@QAE@XZ			; URender::URender
$L22127:
	ret	0
?InternalConstructor@URender@@SAXPAX@Z ENDP		; URender::InternalConstructor
_TEXT	ENDS
PUBLIC	??1URender@@UAE@XZ				; URender::~URender
PUBLIC	??_GURender@@UAEPAXI@Z				; URender::`scalar deleting destructor'
EXTRN	__imp_??3UObject@@SAXPAXI@Z:NEAR
;	COMDAT ??_GURender@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GURender@@UAEPAXI@Z PROC NEAR			; URender::`scalar deleting destructor', COMDAT
	push	esi
	mov	esi, ecx
	call	??1URender@@UAE@XZ			; URender::~URender
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L15118
	push	240					; 000000f0H
	push	esi
	call	DWORD PTR __imp_??3UObject@@SAXPAXI@Z
	add	esp, 8
$L15118:
	mov	eax, esi
	pop	esi
	ret	4
??_GURender@@UAEPAXI@Z ENDP				; URender::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??_7URenderBase@@6BUObject@@@:BYTE
EXTRN	__imp_??_7URenderBase@@6BFExec@@@:DWORD
EXTRN	__imp_??1UObject@@UAE@XZ:NEAR
EXTRN	__imp_??1USubsystem@@UAE@XZ:NEAR
EXTRN	__imp_??_7USubsystem@@6BUObject@@@:BYTE
EXTRN	__imp_??_7USubsystem@@6BFExec@@@:DWORD
EXTRN	__imp_?ConditionalDestroy@UObject@@QAEXXZ:NEAR
;	COMDAT xdata$x
; File ..\..\Core\Inc\UnCorObj.h
xdata$x	SEGMENT
$T22142	DD	019930520H
	DD	03H
	DD	FLAT:$T22144
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T22144	DD	0ffffffffH
	DD	FLAT:$L22133
	DD	0ffffffffH
	DD	FLAT:$L22135
	DD	0ffffffffH
	DD	FLAT:$L22137
xdata$x	ENDS
;	COMDAT ??1URender@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1URender@@UAE@XZ PROC NEAR				; URender::~URender, COMDAT

; 418  : 	DECLARE_CLASS(URender,URenderBase)

	push	-1
	push	$L22143
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7URender@@6BUObject@@@ ; URender::`vftable'
	mov	DWORD PTR [esi+88], OFFSET FLAT:??_7URender@@6BFExec@@@ ; URender::`vftable'
	mov	edi, DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEXXZ
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	edi
	mov	eax, DWORD PTR __imp_??_7URenderBase@@6BUObject@@@
	mov	ecx, DWORD PTR __imp_??_7URenderBase@@6BFExec@@@
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+88], ecx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 1
	call	edi
	mov	edx, DWORD PTR __imp_??_7USubsystem@@6BUObject@@@
	mov	eax, DWORD PTR __imp_??_7USubsystem@@6BFExec@@@
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+88], eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], 2
	call	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	DWORD PTR __imp_??1UObject@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L22133:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1URenderBase@@UAE@XZ
$L22135:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1USubsystem@@UAE@XZ
$L22137:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1UObject@@UAE@XZ
$L22143:
	mov	eax, OFFSET FLAT:$T22142
	jmp	___CxxFrameHandler
text$x	ENDS
??1URender@@UAE@XZ ENDP					; URender::~URender
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
;	COMDAT ??_EURender@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EURender@@UAEPAXI@Z PROC NEAR			; URender::`vector deleting destructor', COMDAT
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	push	esi
	push	edi
	test	bl, 2
	mov	esi, ecx
	je	SHORT $L15121
	mov	eax, DWORD PTR [esi-4]
	lea	edi, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1URender@@UAE@XZ		; URender::~URender
	push	eax
	push	240					; 000000f0H
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
$L15121:
	mov	ecx, esi
	call	??1URender@@UAE@XZ			; URender::~URender
	test	bl, 1
	je	SHORT $L15124
	push	240					; 000000f0H
	push	esi
	call	DWORD PTR __imp_??3UObject@@SAXPAXI@Z
	add	esp, 8
$L15124:
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	ret	4
??_EURender@@UAEPAXI@Z ENDP				; URender::`vector deleting destructor'
_TEXT	ENDS
END
